<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>2021届信息学院暑期编程集训 | 离心的书</title><meta name="keywords" content="C语言小游戏"><meta name="author" content="离心"><meta name="copyright" content="离心"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一次不太理想但学到很多的编程复健">
<meta property="og:type" content="article">
<meta property="og:title" content="2021届信息学院暑期编程集训">
<meta property="og:url" content="https://centrifugalai.github.io/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/index.html">
<meta property="og:site_name" content="离心的书">
<meta property="og:description" content="一次不太理想但学到很多的编程复健">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s1.ax1x.com/2022/08/06/vuoKbV.png">
<meta property="article:published_time" content="2022-08-31T12:38:49.000Z">
<meta property="article:modified_time" content="2023-02-01T03:22:30.159Z">
<meta property="article:author" content="离心">
<meta property="article:tag" content="C语言小游戏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s1.ax1x.com/2022/08/06/vuoKbV.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://centrifugalai.github.io/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2021届信息学院暑期编程集训',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-01 11:22:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom/custom.css"><link rel="stylesheet" href="/css/categoryBar.css"><link rel="stylesheet" href="/css/MainColor.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s1.ax1x.com/2022/08/06/vuHnKA.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-music"></i><span> 竞赛笔记</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-video"></i><span> 课程笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/02/01/WKXls1aTNVn5gLo.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">离心的书</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 学习</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E7%AB%9E%E8%B5%9B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-music"></i><span> 竞赛笔记</span></a></li><li><a class="site-page child" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-video"></i><span> 课程笔记</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">2021届信息学院暑期编程集训</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-08-31T12:38:49.000Z" title="发表于 2022-08-31 20:38:49">2022-08-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-01T03:22:30.159Z" title="更新于 2023-02-01 11:22:30">2023-02-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/C%E8%AF%AD%E8%A8%80/">C语言</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="2021届信息学院暑期编程集训"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本次编程集训的两个比较重要的任务是五子棋 <code>AI</code> 算法设计和贪吃蛇算法设计</p>
<p>两个游戏的共同点是：</p>
<ul>
<li><p>系统每次都会传给程序当前的游戏状态，而程序每次都重新调用——因此程序是没有“记忆”的：只能得到当前的状态，无法获取当前状态是经过了什么演变得到的</p>
</li>
<li><p>AI 的目标都是根据当前的场景作出最有利的决策——就是需要根据当前的状态进行一定的“对局面的预测”，使得即使不能获取局势的演变信息也能作出比较长远的估计</p>
</li>
</ul>
<h1 id="五子棋算法设计思路"><a href="#五子棋算法设计思路" class="headerlink" title="五子棋算法设计思路"></a>五子棋算法设计思路</h1><h2 id="落子权值估计"><a href="#落子权值估计" class="headerlink" title="落子权值估计"></a>落子权值估计</h2><p>落子的权值估计主要通过考虑各种情形的“价值”，五子棋中比较常规的棋形可以归结为下面几种：</p>
<p>五连、活四、单四、活三、单三、活二、单二、活一、单一……</p>
<p>此外，有几种棋形具有特殊的优势：</p>
<ul>
<li>两个单四的组合</li>
<li>单四和活三的组合</li>
<li>两个活三的组合</li>
</ul>
<p>在这三种情况下，原有的棋形会具有更高的威胁，因此应该为它们加上额外的 <code>BUFF</code> 分值，让 <code>AI</code> 能够更加贴合实际中的场景</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*六连的返回值为</span></span><br><span class="line"><span class="type">int</span> Large_Than_Six = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*以下三个值作为基准值,它们都是必胜局面的情形*//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Five_1 = <span class="number">500000</span>; <span class="comment">//*(1)如果将棋子放在这个位置,会产生一个五连,那么威力值设置为 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*必杀棋形</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Live_Four_1 = <span class="number">10000</span>;       <span class="comment">//*(2)如果将棋子放在这个位置,未产生(1),但产生一个活四,威力值设置为 1000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Single_Four_2_BUFF = <span class="number">7000</span>; <span class="comment">//*(3)如果将棋子放在这个位置,不会产生(1)(2),但是会产生两个单四,其威力值设置为 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*准必杀棋形 BUFF 在原有基准上如果满足这种</span></span><br><span class="line"><span class="comment">//*下面两个值是即将会产生必胜局面的情形,不论哪方造成威力都很大,因此不区分自己和对手*//</span></span><br><span class="line"><span class="comment">//*这些值由九个基因进行训练,数据灵敏度 2,数据范围 2 - 1024</span></span><br><span class="line"><span class="type">int</span> Single_Four_1_And_Live_Three_1_BUFF = <span class="number">5000</span>; <span class="comment">//*(4)如果将棋子放在这个位置,不会产生(1)(2)(3)而会产生一个单四和一个活三</span></span><br><span class="line"><span class="type">int</span> Live_Three_2_BUFF = <span class="number">4900</span>;                   <span class="comment">//*(5)如果将棋子放在这个位置,不会产生上述情况,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="comment">//*这些值由七个基因进行训练,数据灵敏度 2,数据范围 2 - 256</span></span><br><span class="line"><span class="type">int</span> My_Single_Four = <span class="number">5500</span>;       <span class="comment">//*(6)我方单四</span></span><br><span class="line"><span class="type">int</span> Opposite_Single_Four = <span class="number">5500</span>; <span class="comment">//*(7)对方单四</span></span><br><span class="line"><span class="type">int</span> My_Live_Three = <span class="number">3000</span>;        <span class="comment">//*(8)我方活三</span></span><br><span class="line"><span class="type">int</span> Opposite_Live_Three = <span class="number">3000</span>;  <span class="comment">//*(9)对方活三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况的威胁很低,不需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="type">int</span> Single_Three = <span class="number">500</span>; <span class="comment">//*(10)单三</span></span><br><span class="line"><span class="type">int</span> Live_Two = <span class="number">100</span>;     <span class="comment">//*(11)活二</span></span><br><span class="line"><span class="type">int</span> Single_Two = <span class="number">50</span>;    <span class="comment">//*(12)单二</span></span><br><span class="line"><span class="type">int</span> Live_One = <span class="number">1</span>;       <span class="comment">//*(13)活一</span></span><br><span class="line"><span class="type">int</span> Single_One = <span class="number">1</span>;     <span class="comment">//*(14)单一</span></span><br></pre></td></tr></table></figure>
<p>而评估函数的设计方法是：</p>
<ul>
<li>遍历棋盘的每一个斜行、每一个横行、每一个竖列——找到棋盘中的各种上述棋形，然后将它们进行加和，作为一个棋盘状态的“价值”</li>
<li>我们的落子应该使得两个状态之间的价值差最大化</li>
</ul>
<p>评估函数的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValueSum</span><span class="params">(PieceColor cur_player_color, Board tempBoard)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> valueSum = <span class="number">0</span>; <span class="comment">//*棋盘上各种棋型的价值总和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! pieceType必须采用指针传参的形式以保证pieceType的值能被记录</span></span><br><span class="line">    Type **piecesType = <span class="keyword">new</span> Type *[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        piecesType[i] = <span class="keyword">new</span> Type[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有横行是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子并且数组中还有值,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*如果尺寸为0,不进行清算,这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有竖列是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[j][i].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[j][i]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是我的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有撇斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-14</span>; b &lt;= <span class="number">14</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++) <span class="comment">//!读取一个斜行的所有可读值并进行判定与加和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + b;</span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有捺斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = -i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">28</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = -i + b;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//!用于当一个节点的类型为 Single_Four 或 Live_Three 时,加入绝杀 BUFF</span></span><br><span class="line">    valueSum += <span class="built_in">getBuffValue</span>(piecesType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] piecesType; <span class="comment">//!每次使用时 piecesType 重新定义并及时删除,防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> valueSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述分值的确认值来自于网上的估计和相关资料的查阅，但是实际情况来看并不完全适用于真实对战中的场景</p>
<p>过程中也有过先在本地搭建一个五子棋平台，然后通过已有算法作为陪练对参数（估值）使用自适应的遗传算法进行参数优化，但是因为时间紧促，考虑到每局耗时过长，很难争取到足够的训练时间，遂放弃。</p>
<h2 id="Alpha-Beta-剪支算法框架"><a href="#Alpha-Beta-剪支算法框架" class="headerlink" title="Alpha-Beta 剪支算法框架"></a><code>Alpha-Beta</code> 剪支算法框架</h2><p>对抗搜索是一种可以在理论上寻找到完美策略的策略，这里不作详细介绍，仅简单总结一下基于本次五子棋 <code>AI</code> 开发任务设计的 <code>Alpha-Beta</code> 剪支算法框架</p>
<p>本次采用的 <code>Alpha-Beta</code> 剪支算法框架流程如下：</p>
<p>首先介绍一下针对五子棋对抗搜索算法设计的数据结构 <code>Node</code>，具体的数据涵义已经在代码注释中说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">structNode</span>(Board board, NodeType nodeType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodeType = nodeType;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.col = <span class="number">0</span>;</span><br><span class="line">        value = (nodeType == my_max) ? max_LB : min_UB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure>
<h3 id="alphaBetaSearch函数外：外层遍历-函数调用"><a href="#alphaBetaSearch函数外：外层遍历-函数调用" class="headerlink" title="alphaBetaSearch函数外：外层遍历 + 函数调用"></a><code>alphaBetaSearch</code>函数外：外层遍历 + 函数调用</h3><p>遍历每一个可能放置棋子的节点，对这些节点进行 <code>Alpha-Beta</code> 剪支算法搜索，并返回这些节点的最终估值</p>
<p>这些节点就是我们下一步要放置棋子的位置——所以它们应该是最大层节点，即 <code>nodeType = my_max</code>（节点的另一种属性是 <code>opposite_min</code>）</p>
<blockquote>
<p>事实证明：对抗搜索中，根据目的弄清楚初始节点的属性是 <code>my_max</code> 还是 <code>opposite_min</code> 非常重要</p>
</blockquote>
<p>我们刚刚已经提出，对一个节点的估值方法是——计算该节点对应的棋盘上我方棋子的总价值减去对方棋子的总价值</p>
<p>这样，最大层节点和最小层节点的目标也就一目了然了——最大层节点应使节点的 <code>value</code> 值尽量大，最小层节点应使节点的 <code>value</code>值尽量小</p>
<h3 id="alphaBetaSearch函数外：深度优先搜索-节点价值更新"><a href="#alphaBetaSearch函数外：深度优先搜索-节点价值更新" class="headerlink" title="alphaBetaSearch函数外：深度优先搜索 + 节点价值更新"></a><code>alphaBetaSearch</code>函数外：深度优先搜索 + 节点价值更新</h3><p>对抗搜索的框架和深度优先搜索的框架有一定相似性，准确地说，对抗搜索是深度搜索加入新特性的一种演变</p>
<p>我定义的函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，<code>lastNode</code> 指的是上一层的节点，也就是上一层决策后的棋盘状态，而我们要往下传递的就是当前层的节点</p>
<p>首先根据上层节点的信息来对本层节点进行定义和赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node curNode = lastNode;</span><br><span class="line">curNode.nodeType = <span class="built_in">NodeType</span>(!lastNode.nodeType);</span><br><span class="line">curNode.value = (curNode.nodeType == my_max) ? curNode.max_LB : curNode.min_UB;</span><br></pre></td></tr></table></figure>
<p>然后和深度优先搜索一样，应该进行边界判断，当发现游戏结束或者达到搜索深度时应该估算并返回当前节点的价值，将这个价值向上传递</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!如果深度数值耗尽,则不再进行操作和向深处搜索,直接返回当前的节点及其价值</span></span><br><span class="line"><span class="keyword">if</span> (depth == <span class="number">0</span> || <span class="built_in">getValueSum</span>(myColor, lastNode.board) &gt;= <span class="number">500000</span> || <span class="built_in">getValueSum</span>(oppositeColor, lastNode.board) &gt;= <span class="number">500000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//!通过节点评估获取最后一层节点的准确价值,并直接返回</span></span><br><span class="line">    curNode.value = <span class="built_in">evaluateNode</span>(curNode);</span><br><span class="line">    <span class="comment">// check(returnNode.board);</span></span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如下图所示：只有最下面一层节点是可以通过对局面的状态估算得到确切价值，其它节点都是通过对抗搜索得到的</p>
<center><img src = https://s1.ax1x.com/2022/09/01/v5DbHe.jpg width = 60%></center>


</blockquote>
<p>接下来应该获取每个可以放置棋子的位置，将这些位置整合到一个数组中等待遍历</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Piece&gt; maybeChosenPiece; <span class="comment">//*可能会被遍历到的棋子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*如果一个位置的颜色为空并且附近有棋子</span></span><br><span class="line">        <span class="keyword">if</span> (lastNode.board.pieces[i][j].color == none &amp;&amp; <span class="built_in">havePieceNearby</span>(lastNode.board.pieces[i][j].pos, lastNode.board, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//*将这个位置作为一种选择放入可选序列中</span></span><br><span class="line">            <span class="comment">// pieceCnt++;</span></span><br><span class="line">            maybeChosenPiece.<span class="built_in">push_back</span>(lastNode.board.pieces[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后对这个存放可下棋位置的数组进行遍历，也就是在这些位置落子，然后将落子后的新状态作为 <code>lastNode</code> 参数，递归地调用 <code>alphaBetaSearch</code> 函数，得到这些落子情况下获得的棋盘状态价值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">   &#123;</span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">       Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value;</span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>相对于深度优先搜索附加的并且非常重要的一点是：</p>
<p>在递归返回后的处理不仅包括状态回溯，还包括更新自身的的最优值（<code>max</code> 层则取 <code>max</code>，<code>min</code> 层则取 <code>min</code>），经过一个循环的最优值更新后，得到的 <code>curNode</code> 就是我们要返回的节点</p>
</blockquote>
<h2 id="算法加速和改进"><a href="#算法加速和改进" class="headerlink" title="算法加速和改进"></a>算法加速和改进</h2><p>上述给出的代码实际上 <code>min-max</code> 算法的代码，我们要对这个代码进行加速，实际上只需要加上几行代码进行剪枝，就能得到 <code>Alpha-Beta</code> 搜索算法</p>
<p>这里很重要的一点就是我们在传递节点的过程中，实际上也传递了上一层节点的 <code>lastNode.value</code> 值，</p>
<p>对于这个 <code>lastNode.value</code> 值的理解非常重要——</p>
<p>它相当于一个“指导值”，可以形象化地理解这个值：</p>
<blockquote>
<p>每一层节点都会向下一次层节点传递一个包含当前节点信息的节点，它就是下一层节点的 <code>lastNode</code> 参数</p>
<p>这个参数相当于一个指导值，比如下一层节点是 <code>max</code> 节点，那么如果 <code>max</code> 节点搜索到了一个比 <code>lastNode.value</code> 值大的结果，很显然，由于这个 <code>max</code> 节点要取自己所有子节点的最大值并返回，返回的值一定会大于 <code>lastNode.value</code> ，无法对 <code>lastNode.value</code> 照成改动，很显然这个 <code>max</code> 节点就是一个无效节点，直接剪枝是不会影响最终得到的结果的</p>
</blockquote>
<p>将上面的搜索代码修改如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">    &#123;</span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">        Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value;</span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure>
<p>由于剪枝的方式实际上就是直接停止当前节点的搜索进程，直接返回当前节点。所以需要进行的改动也就是在 <code>max</code> 和 <code>min</code> 节点的情况中分别增加了一句判断返回代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure>
<p>另外，对于一些周围没有任何棋子的节点，我们没有必要进行搜索，一般情况下，不会有人会在这些位置落子，判断函数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*该函数返回半径为 r 的范围内是否有棋子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">havePieceNearby</span><span class="params">(Pos pos, Board tempBoard, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check(tempBoard);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos.row - r; i &lt;= pos.row + r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = pos.col - r; j &lt;= pos.col + r; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">14</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">14</span>)</span><br><span class="line">                flag += (tempBoard.pieces[i][j].color != none); <span class="comment">//*如果这个位置有棋子,就将flag+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;flag is &quot; &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (flag &gt; <span class="number">0</span>); <span class="comment">//!附近有棋子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="统一的对抗搜索模板"><a href="#统一的对抗搜索模板" class="headerlink" title="统一的对抗搜索模板"></a>统一的对抗搜索模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>lastNode</code>：上一层节点的状态</p>
<p><code>curNode</code>：当前节点状态</p>
<p><code>nextNode</code>：下一层节点的状态</p>
<p>关于 <code>Node</code> 的定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>第一步：进行边界判断，是否达到搜索深度或者博弈结局</p>
</li>
<li><p>第二步：搜索整个决策空间，将可行决策纳入一个数组中</p>
<blockquote>
<p>第二步有一定的剪枝空间，可以调整决策空间的大小</p>
</blockquote>
</li>
<li><p>第三步：遍历整个可行决策数组，对于每个可行决策，对 <code>curNode</code> 进行修改并作为参数调用 <code>alphaBetaSearch</code> ，将返回的节点作为 <code>nextNode</code></p>
</li>
<li><p>第四步：根据 <code>nextNode.value</code> 是否比 <code>curNode.value</code> 更优来决定是否对本层节点的 <code>value</code> 值进行更新</p>
</li>
<li><p>第五步：如果更新后的节点可以确认当层节点的 <code>curNode.value</code> 值一定不能达到对 <code>lastNode.value</code> 的修改条件，就直接剪枝（当场返回当前节点）</p>
</li>
<li><p>第六步：不满足第五步的操作条件，那么对 <code>curNode</code> 进行状态回溯，继续第三、四、五步的循环中的剩余部分，完成循环后， 则 <code>curNode.value</code> 已经被更新为最优值，返回。</p>
</li>
</ul>
<h1 id="贪吃蛇算法设计思路"><a href="#贪吃蛇算法设计思路" class="headerlink" title="贪吃蛇算法设计思路"></a>贪吃蛇算法设计思路</h1><h2 id="食物价值传播"><a href="#食物价值传播" class="headerlink" title="食物价值传播"></a>食物价值传播</h2><p>该贪吃蛇游戏的食物分布是遍布全图的，但是也会碰到这样一种尴尬的情况：就是一些在一些区域中自己的搜索范围内不存在任何的食物，这种情况很有可能就会导致蛇原地打转，非常影响发育。其次，即使有搜索能力，搜索范围过小也有可能导致蛇进入“短视”的状态，体现为它并不关心更远距离的高分值食物，而是只会追逐近距离的低分值食物。因此，引入了食物价值传播的函数——</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foodValueSpread</span><span class="params">(<span class="type">int</span> round)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= round; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">29</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">39</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j - <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j][k - <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= <span class="number">29</span>)</span><br><span class="line">                    map[j + <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt;= <span class="number">39</span>)</span><br><span class="line">                    map[j][k + <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的作用是：将具有食物的位置的“食物价值”按照一定的衰减比例散布到周围四个位置，当我们进行了若干轮这样的传播以后，如果将食物的分值视为高度，整个地图的纵直方向的形状就类似于山地分布——我们的蛇只要向山地中的较高处运动，就能够保证兼具食物价值判断和追逐食物两个效果。</p>
<p>经过实践调整参数，食物价值传播的轮次设置为 $5$，食物价值传播的价值衰减率设置为 $0.57$</p>
<h2 id="大区域和小区域的权衡"><a href="#大区域和小区域的权衡" class="headerlink" title="大区域和小区域的权衡"></a>大区域和小区域的权衡</h2><p>在衡量一个位置的价值时，尽管有上述的食物价值图传播操作，但是传播的数量毕竟只有几轮，没办法普及到整个地图的所有位置，因此蛇的方向选择能然有可能只在局部上看来是较优的，但是从全局看来，蛇并没有主动地去移动到资源丰富的地区。所以，一个比较好的方法是同时衡量大区域的移动收益和小区域的移动收益选出最佳的移动方向。</p>
<p>对于大区域的移动收益，我主要采用区域价值密度作为衡量标准进行量化，考虑的标准有：</p>
<ul>
<li>区域的显示价值：所有食物和道具的价值总和</li>
<li>区域的隐式价值：当有蛇处在这个区域中，杀死它可以获得丰富的收益，这种收益被称为区域的隐式价值</li>
<li>区域的距离：一个区域距离自己越远，它的价值就相应地降低</li>
<li>区域的风险：其它蛇和障碍物会给一个区域带来风险——区域的风险对于区域价值而言是负增长的</li>
</ul>
<p>将这些因素乘以它们相应的权重，就能够得到一个区域的总价值，在程序中，这个总价值被称为 <code>largeZoneEvaluation</code> ，相应地，一个节点对应的近距离价值收益被称为 <code>closeZoneEvaluation</code>，<code>largeZoneEvaluation</code> 和 <code>closeZoneEvaluation</code> 乘以各自的权重，最终组成一个点的价值总和，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个点的利益（最终决策函数）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">getPosValue</span><span class="params">(Pos position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 求出这一点的宏观收益 largeZoneValue</span></span><br><span class="line">    <span class="comment">// 思路：判断这一点的位置和自己的当前位置相比是否距离最富裕区域更近</span></span><br><span class="line">    Pos direc = &#123;position.row - me.bodies.<span class="built_in">front</span>().row, position.col - me.bodies.<span class="built_in">front</span>().col&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> largeZoneValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (direc.row &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(down, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.row &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(up, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(right, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(left, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出这一点的纯粹价值收益 pureValue</span></span><br><span class="line">    <span class="comment">// 思路：bfs 图传播</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> closeZoneValue = <span class="built_in">closeZoneEvaluation</span>(position, SearchDepth);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> temp_Large_Zone_Weight = Large_Zone_Weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp_Large_Zone_Weight * largeZoneValue / Large_Zone_Evaluation_Standard + Close_Zone_Weight * closeZoneValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当参数调整得当时，理想的效果应该是，蛇会以资源丰富地区为大方向，并且向这个大方向不断靠近，过程中会主动选择吃掉得分较高的食物，实现快速发育的目标。</p>
<h2 id="策略计算和选择"><a href="#策略计算和选择" class="headerlink" title="策略计算和选择"></a>策略计算和选择</h2><p>本程序中，在决定向上下左右移动或是使用盾牌/障碍物前，会先经过一个策略选择的流程——</p>
<p>我为贪吃蛇程序确定了四种策略，它们分别是</p>
<ul>
<li>发育策略</li>
<li>逃跑策略</li>
<li>攻击策略</li>
<li>防御策略</li>
</ul>
<p>进行策略选择有以下这些流程：</p>
<ul>
<li>第一步：判断自己当前是否处在危险当中</li>
</ul>
<blockquote>
<p>主要通过判断区域的风险程度，并且设置一个“危险阈值”参数，当超过这个参数时，就会认定这片区域是存在风险的。这个参数越大，蛇的表现就会越“大胆”</p>
</blockquote>
<ul>
<li>第二步：计算贪心路径和逃跑路径的收益总和</li>
</ul>
<blockquote>
<p>进行深度为 $5$ 的搜索，计算出贪心路径和逃跑路径的总收益</p>
<p>逃跑路径指的是将风险权重设为 $0.7$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条逃跑路径的价值总和</p>
<p>贪心路径指的是将风险权重设置为 $0.3$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条贪心路径的价值总和</p>
<p>在第一步中，如果判断为非危险，就不可能采取逃跑路径，如果判定为危险，就会选择贪心路径或逃跑路径，此时需要对它们进一步判断</p>
<p>设置一个贪心阈值，如果两条路径的价值差超过了贪心阈值，就会采取贪心路径，否则认为不值得冒险，采取逃跑路径。贪心阈值越大，蛇的表现就会越“贪心”</p>
</blockquote>
<ul>
<li>第三步：计算当前是否值得采取攻击策略或是防御策略</li>
</ul>
<blockquote>
<p>当第一步中判断此时处在危险当中时，就会决定是否采取两个特殊策略</p>
<p>这两个特殊策略都是经过特判决定是否采取，特判的标准有：被攻击蛇的价值，附近蛇的数量，时间……</p>
</blockquote>
<ul>
<li>第四步：根据以上得到的数据选择一个策略</li>
</ul>
<p>事实上，以上操作的主要算法思想还是贪心：关键在于如何对贪心进行改善，使得不易陷入局部最优解并且通过对风险进行估值，使决策的结果考虑了一定“对抗”的因素</p>
<h1 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h1><h2 id="参数管理和优化"><a href="#参数管理和优化" class="headerlink" title="参数管理和优化"></a>参数管理和优化</h2><p>这点缺陷在贪吃蛇项目中显得尤为明显——总共设置的参数多达二十多个，这种情况下，参数管理显得尤为艰难，很多函数/功能在最后比赛时其实反到没有发挥它们的效果</p>
<p>在程序设计时，尽管设计每个参数都有考虑这些参数包含的涵义，但是当参数数量多时，很容易出现数据崩坏——一些参数的标准值一旦无法确定，就会增加很大的不确定性，那么，二十多个参数的组合很快就会成为一组混沌而无法预测的参数系统。</p>
<p>直到最后，调节参数很大程度基于直觉，这就让模型失去原有的意义，所以，参数的个数并不越多越好，并且尽量应该在设定一个参数后及时测量它们的标准，防止出现数据过于膨胀导致的问题。</p>
<h2 id="模型构建和实现步骤"><a href="#模型构建和实现步骤" class="headerlink" title="模型构建和实现步骤"></a>模型构建和实现步骤</h2><p>本次集训中发现的另一个问题是：在模型的构建过程总是期待一举建成完善和全面的模型，而调 <code>BUG</code> 的时间往往达到构建模型时间的两倍以上，事实上这是并不合理的一种开发方式——</p>
<p>以贪吃蛇为例，这个游戏的两个难点应该是各种棋形的判断和<code>Alpha-Beta</code> 剪枝函数的设计。我的做法是一次性地写好各种棋形的判断和 <code>Alpha-Beta</code> 剪枝函数，但是最后调 <code>BUG</code> 时发现了问题只好在整个程序中一步步搜寻。</p>
<p>但是，倘若在设计完棋形判断的函数后，并不马上进行 <code>Alpha-Beta</code> 剪枝函数的设计，而是先写一个根据每一点分值高低进行下棋的贪心算法程序。运行后根据下棋的效果很容易就能发现自己漏判断了什么棋形（或者哪种棋形判断出错），将棋形判断函数修改完善以后，再进行 <code>Alpha-Beta</code> 剪枝函数的设计，后续如果又出现问题，那么就在 <code>Alpha-Beta</code> 剪枝函数中寻找 <code>BUG</code> ，这样降低了代码检查的范围。</p>
<p>所以，很重要的一点教训就是——罗马非一日建成。复杂是简单的叠加，即使一开始就构思出非常复杂的模型时，也应该思考如何将这些复杂程序分解成小的步骤，如何在这些小的步骤中插入检测点，使得能够在逐步完成大作业最终任务的同时保证其正确性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://centrifugalai.github.io">离心</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://centrifugalai.github.io/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/">https://centrifugalai.github.io/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://centrifugalai.github.io" target="_blank">离心的书</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C%E8%AF%AD%E8%A8%80%E5%B0%8F%E6%B8%B8%E6%88%8F/">C语言小游戏</a></div><div class="post_share"><div class="social-share" data-image="https://s1.ax1x.com/2022/08/06/vuoKbV.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/08/31/cOpenMP%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"><img class="prev-cover" src="https://s1.ax1x.com/2022/08/06/vuoKbV.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OpenMP 入门指南</div></div></a></div><div class="next-post pull-right"><a href="/2022/08/21/cLINGO%E6%8C%87%E5%8D%97/"><img class="next-cover" src="https://s1.ax1x.com/2022/08/06/vuTX6A.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LINGO 语言入门指南</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/08/18/cdoublesnake/" title="锻炼左右脑协调的贪吃蛇游戏——《Double Snakes》完整 C 语言代码！"><img class="cover" src="https://s1.ax1x.com/2022/08/06/vuoKbV.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-18</div><div class="title">锻炼左右脑协调的贪吃蛇游戏——《Double Snakes》完整 C 语言代码！</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s1.ax1x.com/2022/08/06/vuHnKA.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">离心</div><div class="author-info__description">人民大学图灵班某 21 级本科生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/CentrifugalAI"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/weixin_60491948?spm=1010.2135.3001.5343" target="_blank" title="CSDN"><i class="fab fa-cuttlefish"></i></a><a class="social-icon" href="https://github.com/CentrifugalAI" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2021201613@ruc.edu.cn" target="_blank" title="E-Mail"><i class="fab fa-envelope"></i></a><a class="social-icon" href="https://www.zhihu.com/people/chi-xin-5-10" target="_blank" title="ZhiHu"><i class="fab fa-zhihu"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这个网站用来记录我从大二起上过的所有专业课和比较硬核的选修课，随时弃坑.jpg（雾）；入坑的理由来源于据称人类最好的学习方法——费曼学习法：输出是巩固输入的最佳方法。由于大一暑假才开始入坑写博客，so 大一的内容就不包含进去（大一的学习内容基本也只有初级数学课和编程基础）；附：本人 RUC 图灵班地下室水平，所以谬误难免。博客中误区欢迎交流，请多指教！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%A6%81"><span class="toc-number">1.</span> <span class="toc-text">概要</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E5%AD%90%E6%A3%8B%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">2.</span> <span class="toc-text">五子棋算法设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%90%BD%E5%AD%90%E6%9D%83%E5%80%BC%E4%BC%B0%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">落子权值估计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Alpha-Beta-%E5%89%AA%E6%94%AF%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6"><span class="toc-number">2.2.</span> <span class="toc-text">Alpha-Beta 剪支算法框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alphaBetaSearch%E5%87%BD%E6%95%B0%E5%A4%96%EF%BC%9A%E5%A4%96%E5%B1%82%E9%81%8D%E5%8E%86-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">alphaBetaSearch函数外：外层遍历 + 函数调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alphaBetaSearch%E5%87%BD%E6%95%B0%E5%A4%96%EF%BC%9A%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E8%8A%82%E7%82%B9%E4%BB%B7%E5%80%BC%E6%9B%B4%E6%96%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">alphaBetaSearch函数外：深度优先搜索 + 节点价值更新</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%8A%A0%E9%80%9F%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">2.3.</span> <span class="toc-text">算法加速和改进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%AF%B9%E6%8A%97%E6%90%9C%E7%B4%A2%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.4.</span> <span class="toc-text">统一的对抗搜索模板</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B4%AA%E5%90%83%E8%9B%87%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">贪吃蛇算法设计思路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A3%9F%E7%89%A9%E4%BB%B7%E5%80%BC%E4%BC%A0%E6%92%AD"><span class="toc-number">3.1.</span> <span class="toc-text">食物价值传播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%B0%8F%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">3.2.</span> <span class="toc-text">大区域和小区域的权衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E8%AE%A1%E7%AE%97%E5%92%8C%E9%80%89%E6%8B%A9"><span class="toc-number">3.3.</span> <span class="toc-text">策略计算和选择</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E6%80%9D%E5%92%8C%E6%80%BB%E7%BB%93"><span class="toc-number">4.</span> <span class="toc-text">反思和总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%AE%A1%E7%90%86%E5%92%8C%E4%BC%98%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">参数管理和优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%9E%84%E5%BB%BA%E5%92%8C%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.2.</span> <span class="toc-text">模型构建和实现步骤</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/02/09/c%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/" title="粒子群优化算法原理与代码实现"><img src="https://s1.ax1x.com/2022/08/06/vuTX6A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="粒子群优化算法原理与代码实现"/></a><div class="content"><a class="title" href="/2023/02/09/c%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/" title="粒子群优化算法原理与代码实现">粒子群优化算法原理与代码实现</a><time datetime="2023-02-09T05:38:49.000Z" title="发表于 2023-02-09 13:38:49">2023-02-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/08/c%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/" title="从蚁群算法到可进化高阶蚁群算法"><img src="https://s1.ax1x.com/2022/08/06/vuTX6A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从蚁群算法到可进化高阶蚁群算法"/></a><div class="content"><a class="title" href="/2023/02/08/c%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/" title="从蚁群算法到可进化高阶蚁群算法">从蚁群算法到可进化高阶蚁群算法</a><time datetime="2023-02-08T05:38:49.000Z" title="发表于 2023-02-08 13:38:49">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/02/07/c%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/" title="从模拟退火到退火进化算法（原理、实现）"><img src="https://s1.ax1x.com/2022/08/06/vuTX6A.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从模拟退火到退火进化算法（原理、实现）"/></a><div class="content"><a class="title" href="/2023/02/07/c%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/" title="从模拟退火到退火进化算法（原理、实现）">从模拟退火到退火进化算法（原理、实现）</a><time datetime="2023-02-07T05:38:49.000Z" title="发表于 2023-02-07 13:38:49">2023-02-07</time></div></div></div></div></div></div></main><footer id="footer" style="background: linear-gradient( 135deg,"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 离心</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script></div><script src="/js/categoryBar.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.7" zIndex="-1" mobile="false" data-click="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":225,"height":450},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>