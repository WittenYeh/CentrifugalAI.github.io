<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>绪论：编译原理概论</title>
      <link href="/2023/02/17/c%E7%BC%96%E5%8E%9F1%E5%82%A8%E8%AE%BA/"/>
      <url>/2023/02/17/c%E7%BC%96%E5%8E%9F1%E5%82%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="编译系统与编译器的结构"><a href="#编译系统与编译器的结构" class="headerlink" title="编译系统与编译器的结构"></a>编译系统与编译器的结构</h1><h2 id="编译系统结构"><a href="#编译系统结构" class="headerlink" title="编译系统结构"></a>编译系统结构</h2><p>整个编译系统由预处理器、编译器、汇编器、链接器和加载器组成。</p><center><img src = https://s2.loli.net/2023/03/15/3WQrigcJXaDOjLd.png width = 100%></center><p>其中预处理器负责把存储在不同文件中的源程序聚合在一起（<code>#include</code> 处理），把被成为宏的缩写替换为原始语句（宏定义展开）</p><p>编译器负责将经过预处理以后的源程序（仍然是高级语言）翻译成汇编语言程序。</p><p>汇编器负责将汇编语言程序翻译为<strong>可重定位的机器代码</strong></p><p>链接器将多个可重定位的机器语言代码文件（包括静态库文件）链接到一起，并解决外部内存地址的问题。</p><p>加载器负责修改可重定位的地址，并将修改后的指令和数据放到内存中适当的位置。</p><blockquote><p>关于链接器和加载器对作用和功能，在 CSAPP 相关章节中有另外详细的描述。</p></blockquote><p>经过链接器和加载器的处理后，源程序已经完全转变为目标机器代码，能够被机器直接执行。</p><p>本课程的内容在于介绍编译器，即重点在于将源程序翻译为汇编语言程序的过程。</p><h2 id="编译器结构"><a href="#编译器结构" class="headerlink" title="编译器结构"></a>编译器结构</h2><p>编译器的结构可以用下图表示。其大致可以分为两个部分：</p><ul><li>分析部分（前端，front end），这个部分主要负责对源语言的分析；</li><li>综合部分（后端，back end），这个部分主要负责分析后的源语言到目标语言的转化。</li></ul><center><img src = https://s2.loli.net/2023/03/15/vdTfK6jW8DzBLgR.png width = 70%></center><p>接下来的内容将介绍各个部分负责的任务内容。</p><hr><h1 id="编译系统相关任务概述"><a href="#编译系统相关任务概述" class="headerlink" title="编译系统相关任务概述"></a>编译系统相关任务概述</h1><h2 id="词法分析概述"><a href="#词法分析概述" class="headerlink" title="词法分析概述"></a>词法分析概述</h2><p>词法分析的主要任务是，对源程序各个字符进行逐一的扫描，经过一定规则的分析后，识别出源程序中的各个<strong>单词</strong>，并利用词法单元（token）来表示单词。</p><p>词法单元 token 可以用二元组表示：&lt;种别码，属性值&gt;</p><blockquote><p>“一型一码”就是一整种类型的单词都用同一个种别码表示。</p><p>“多词一码”就是一种类型中的多个单词都用同一个种别码表示。</p></blockquote><p>种别码用于表示单词的类型，属性值则用于表示单词的具体内容，以便对“一型一码”和“多词一码”的情况进一步地区分。</p><blockquote><p>采用“一词一码”规则的单词，用种别码即可进行辨别，这种情况不需要再赋予属性值</p></blockquote><p>下面的表格给出了各种类型单词的种别码的设置建议。</p><center><img src = https://s2.loli.net/2023/03/15/9OjW8uGknDfQb4X.png width = 80%></center><p>如下是一个对于词法分析返回 <code>token</code> 序列的例子，这个例子中，关键字采用一词一码，标识符采用多词一码，常量采用“一型一码”，运算符采用一词一码，界限符采用一词一码。对于常量，其属性值就是它的常量值；对于标识符，其属性值就是这个表示标识符的字符串。</p><h2 id="语法分析概述"><a href="#语法分析概述" class="headerlink" title="语法分析概述"></a>语法分析概述</h2><p>语法分析器（parser）的作用是对词法分析器中输出的 token 序列进行解析，识别出不同的各类“短语”，并构造出属于这个 token 序列的语法分析树（parse tree）：</p><center><img src = https://s2.loli.net/2023/03/15/Qq9gwvM4GzksT5D.png width = 70%></center><p>你可能疑惑于此处“短语”的概念，但后续内容会对这个概念进行严格的定义，此处只要理解为：“短语”就类似于英文中的“词组”的概念，就是数个单词联结而成的组合</p><p>为了规范语法分析的过程，我们还需要引入“文法”的概念，如下就是一种文法：</p><script type="math/tex; mode=display"><D> \rightarrow <T> <IDS>;\\<T> \rightarrow int | real | char | bool;<IDS> \rightarrow id | <IDS>, id</script><p>其中 $D$ 表示声明语句（declaration），$T$ 表示 类型（type），$IDS$ 表示标识符的一个序列（identify sequence），$id$ 则表示一个单独的标识符。</p><p>这三行文法的含义是：</p><p>一个声明语句是由一个类型符加上一串多个标识符组成的序列 $IDS$ 构成的，类型符可以是 <code>int</code> 、<code>real</code> 、<code>char</code> 或 <code>bool</code> 四个关键字。而 $IDS$ 则可以递归地表示一个更短的标识符序列和一个标识符（中间加上逗号的串接），或者表示为单个的标识符。</p><blockquote><p>关于 $<IDS>$ 这种有点类似于“套娃”的递归设定，不熟悉递归定义的读者可能需要对这种定义方式稍作适应。</p></blockquote><h2 id="语义分析概述"><a href="#语义分析概述" class="headerlink" title="语义分析概述"></a>语义分析概述</h2><p>语义分析阶段的主要任务包括：<strong>收集各个标识符的属性信息和语义检查</strong></p><p>标识符地属性信息包括：</p><ul><li>该标识符表示对象属于哪个种属（Kind），例如简单变量、复合变量（数组、结构体等）、过程（函数）</li><li>该标识符表示对象属于种属中的何种类型（Type），如整型、浮点型、字符型、布尔型、指针型或其他结构体等类型</li><li>该标识符表示对象的存储位置、以及占用内存大小</li><li>该标识符表示对象的值（如果该标识符表示对象是一个变量的话）</li><li>该标识符表示对象的作用域（局部？全局？）</li><li>该标识符表示对象的参数和返回值信息（如果该标识符表示对象是一个函数的话）<blockquote><p>包括参数个数、参数类型、参数传递方式、返回值类型等信息</p></blockquote></li></ul><p>以上属性信息均使用符号表（一种专门用于存放标识符属性信息的数据结构）记录，记录格式如下图：</p><center><img src = https://s2.loli.net/2023/03/15/xM3Wk1OlsRwpEKh.png width = 90%></center><p>其中 <code>NAME</code> 字段的记录方式比较特殊，它并不是直接存放字符串的内容，而是在内存中开辟一段连续的空间存放字符，然后记录每个标识符 <code>NAME</code> 字段的起始地址和长度，这样就在对应内存空间中找到目标字符串。</p><p>而语义检查步骤主要检查以下内容：</p><blockquote><p>过程相当于 C 语言中的函数，此后不再提示</p></blockquote><ul><li>变量或过程名是否未经声明就使用</li><li>变量或过程名是否重复声明</li><li>运算分量类型不匹配<blockquote><p>运算分量指的是运算操作符两边的标识符表示的对象，比如 <code>getNum + num</code>，其中 <code>num</code> 是一个变量，而 <code>getNum</code> 是一个函数，这种情况就属于运算分量类型不匹配</p></blockquote></li><li>操作符与操作数之间的类型不匹配<ul><li>数组访问运算符（<code>[]</code>）的操作数不是正整数</li><li>对非数组变量使用数组访问操作符</li><li>对非过程名使用过程调用操作符 <code>()</code></li><li>过程调用的参数类型或数目不匹配</li><li>函数返回类型有误</li></ul></li></ul><p>上述这些错误都会在语义检查阶段被发现，并由编译器提出错误通报</p><h2 id="中间代码生成概述"><a href="#中间代码生成概述" class="headerlink" title="中间代码生成概述"></a>中间代码生成概述</h2><p>在分析过程中，经过词法分析器进行分词，语法分析器提炼“短语”并将代码语句组织成语法树的形式，语义分析器收集标识符属性并检查语义，返回的是已经组织成语法树的源程序。</p><p>而中间代码生成器的任务则是将语法分析得到的<strong>语法树结构</strong>进行转换，生成<strong>中间表示形式</strong>。</p><p>常见的中间表示形式有以下两种：</p><ul><li>三地址码（Three-address Code）</li><li>语法树/语法结构树（Syntax Trees）<blockquote><p>这里的语法结构树和前面介绍的语法分析树有所不同，后续章节将详细介绍</p></blockquote></li></ul><p>此处主要介绍一下三地址码：</p><p>三地址码中的“地址”可以用以下形式表示：</p><ul><li>源程序中变量/过程的名字</li><li>常量的值</li><li>编译器生成的临时变量</li></ul><blockquote><p>因为在符号表中，标识符表示对象的地址（ADDR）、名称（NAME）和常量的值（VAR）都可以互相唯一地对应</p></blockquote><p>常用的三地址指令有以下几种：</p><center><img src = https://s2.loli.net/2023/03/15/2zboEI5n9OahLsA.png width = 50%></center><blockquote><p><code>relop</code> 表示关系运算符，比如 C 语言中的 <code>==</code> ，<code>&lt;</code>，<code>&gt;</code> 等运算符</p></blockquote><p>这些三地址指令都可以用四元式 <code>(op,y,z,x)</code> 来表示，其中第一个元素 <code>op</code> 表示操作符，而 <code>x</code>，<code>y</code> 和 <code>z</code> 分别对应上表中各个指令的 <code>x</code> ，<code>y</code> 和 <code>z</code></p><blockquote><p>某些指令不包含 <code>x</code>，<code>y</code> 和 <code>z</code> 的其中一个/两个，直接在四元式中的相应位置置为空即可</p></blockquote><p>下面是上表中的三地址指令的四元式表示：</p><center><img src = https://s2.loli.net/2023/03/15/uWUeDJptAm5FdNr.png width = 50%></center><blockquote><p><code>=[]</code> 、<code>[]=</code> 、<code>=*</code> 和 <code>*=</code> 都表示地址操作</p></blockquote><p>下面就是将一棵已经经过分析的语法树转化为四元式形式的中间代码的例子：</p><center><img src = https://s2.loli.net/2023/03/15/Q1HXdDLeKhbuAUO.png width = 90%></center><blockquote><p><code>j&lt;</code> 符号中的 <code>j</code> 表示 <code>jump</code>，即条件跳转指令，这里表示在 <code>&lt;</code> 关系满足时执行条件跳转，其它类似命令同理</p></blockquote><h2 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h2><p>目标代码生成以源程序的中间代码作为输入，输出目标语言（比如常见的汇编语言）</p><p>目标代码生成器的一个重要任务是为程序中使用的变量合理<strong>分配寄存器</strong></p><p>目标代码优化器则以已经生成的目标语言代码为输入，输出改进后的目标语言代码，这种改进往往在不会影响源程序原意的基础上，使得运行速度更快，占用空间更小。</p><hr><h1 id="语言及其文法基本概念"><a href="#语言及其文法基本概念" class="headerlink" title="语言及其文法基本概念"></a>语言及其文法基本概念</h1><h2 id="字母表及其运算"><a href="#字母表及其运算" class="headerlink" title="字母表及其运算"></a>字母表及其运算</h2><h3 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h3><p>字母表 $\Sigma$ 是一个有穷符号集合</p><blockquote><p>比如 ASCII 字符集，Unicode 字符集都是字母表</p></blockquote><h3 id="字母表的乘积"><a href="#字母表的乘积" class="headerlink" title="字母表的乘积"></a>字母表的乘积</h3><p>字母表的乘积运算定义为字母表上<strong>字符的拼接</strong></p><p>比如 $\Sigma_1\Sigma_2 = \{ab | a\in \Sigma_1, b\in \Sigma_2\}$</p><p>就是从 $\Sigma_1$ 和 $\Sigma_2$ 中各取出一个字符然后按顺序拼接在一起。</p><blockquote><p>e.g. $\{0,1\}\{a,b\} = \{0a,0b,1a,1b\}$</p></blockquote><h3 id="字母表的幂"><a href="#字母表的幂" class="headerlink" title="字母表的幂"></a>字母表的幂</h3><p>字母表 $\Sigma$ 的 $n$ 次幂就是 $n$ 个字母表 $Sigma$ 的乘积，特别地，我们规定字母表 $\Sigma$ 的零次幂是一个空集。</p><p>严谨地，字母表的乘积可以使用如下递归的定义描述：</p><script type="math/tex; mode=display">\Sigma^0 = \{\epsilon\}</script><script type="math/tex; mode=display">\Sigma^n = \Sigma^{n-1}\Sigma,\;\; n \ge 1</script><p>$\epsilon$ 在此处表示“空字符串”</p><h3 id="字母表的正闭包"><a href="#字母表的正闭包" class="headerlink" title="字母表的正闭包"></a>字母表的正闭包</h3><p>字母表的正闭包 $\Sigma^+$ 表示一个字母表中所有字符任意组合成任何非空字符串的集合。严格定义为：</p><script type="math/tex; mode=display">\Sigma^+ = \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \cdots</script><p>比如 $\{a,b,c\}^+$ 实际上就是：</p><script type="math/tex; mode=display">\{a,b,c,aa,ab,ac,ba,bb,bc,ca,cb,cc,aaa,aab,aac,aba,abb,abc\cdots\}</script><p>它们是用字符 $a,b,c$ 组成的任意长度的非空字符串</p><h3 id="字母表的克林闭包"><a href="#字母表的克林闭包" class="headerlink" title="字母表的克林闭包"></a>字母表的克林闭包</h3><p>字母表的克林闭包 $\Sigma^*$ 在定义上仅比字母表的正闭包多包含一个空字符串，即：</p><script type="math/tex; mode=display">\Sigma^* = \Sigma \cup \Sigma^2 \cup \Sigma^3 \cup \cdots</script><p>克林闭包就是任意符号串（可以是空串）构成的集合</p><h2 id="串及其运算"><a href="#串及其运算" class="headerlink" title="串及其运算"></a>串及其运算</h2><h3 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h3><p>设 $\Sigma$ 是一个字母表，则 $\forall x \in \Sigma^*$，$x$ 称为是 $\Sigma$ 上的一个串</p><p>串就是字母表中符号的一个<strong>有穷</strong>序列</p><p>我们可以定义串 $s$ 的长度，用 $|s|$ 表示，例如 $|aab| = 3$，空串显然就是长度为 $0$ 的串：$|\epsilon| = 0$</p><h3 id="串的连接运算"><a href="#串的连接运算" class="headerlink" title="串的连接运算"></a>串的连接运算</h3><p>串 $x$ 和 $y$ 的连接运算就是直接将串 $y$ 拼接在串 $x$ 后面，记为 $xy$</p><blockquote><p>串的连接运算讲究先后顺序，因此并不满足交换律</p><p>注意串的连接和字母表的乘积之间的区别，前者得到的结果是串，后者得到的结果是串的集合</p></blockquote><p>空串是连接运算的单位元，$\epsilon s = s\epsilon = s$</p><p>设 $x,y,z$ 是三个字符串，如果 $x = yz$ ，则称 $y$ 是 $x$ 的前缀，$z$ 是 $x$ 的后缀</p><h3 id="串的幂运算"><a href="#串的幂运算" class="headerlink" title="串的幂运算"></a>串的幂运算</h3><p>串 $s$ 的 $n$ 次幂运算就是将相同的 $n$ 个串 $s$ 连接起来，任何串的 $0$ 次幂都是空串，它同样可以递归地定义：</p><script type="math/tex; mode=display">s^0 = \epsilon</script><script type="math/tex; mode=display">s^n = s^{n-1}s,\;\; n\ge 1</script><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><h3 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h3><p>下面就是一个简化英文文法的例子：</p><center><img src = https://s2.loli.net/2023/03/15/2NObAv6iXxHgc1o.png width = 70%></center><p>每种文法系统 $G$ 都可以用一个四元组表示：</p><script type="math/tex; mode=display">G  = (V_T, V_N, P, S)</script><ul><li>$V_T$ 被称为终结符集合（vector of teminal），终结符是文法系统中的<strong>最基本的不可再分的符号</strong>，也写作 token<blockquote><p>比如上述英文文法中，$V_T = \{apple,boy,eat,little\cdots\}$</p></blockquote></li><li>$V_N$ 被称为非终结符集合（vector of nonteminal），非终结符用于表示语法成分，亦称“语法变量”<blockquote><p>比如上述英文文法中，$V_N = \{句子,&lt;名词短语&gt;,&lt;动词短语&gt;,&lt;名词&gt;,&lt;动词&gt;,\cdots\}$</p></blockquote></li></ul><div class="note info flat"><p>终结符和非终结符的集合称为文法符号集，并且终结符和非终结符的交集为空集，即 $V_T \cap V_N = \{\epsilon\}$</p></div><ul><li>$P$ 称为产生式集合，每个产生式（production）描述了将终结符和非终结符组合成串的方法<ul><li>产生式一般写作：$\alpha\rightarrow \beta$，读作“$\alpha$ 定义为 $\beta$”</li><li>$\alpha$ 是产生式的头部（head）或左部（left side）， $\alpha \in (V_T \cup V_N)^+$，各种文法往往都规定 $\alpha$ 中至少包含一个非终结符。</li><li>$\beta$ 是产生式的体（body）或右部（right side），$\beta \in (V_T\cup V_N)*$</li></ul></li><li>$S$ 被称为开始符号，开始符号是这个文法系统中最大的语法成分<blockquote><p>比如上式中就有 $S = &lt;句子&gt;$</p></blockquote></li></ul><div class="note info flat"><p>下面一个算式表达式文法的例子可以辅助理解这四个概念：</p><script type="math/tex; mode=display">V_T = \{id, +, *, (, ) \}</script><script type="math/tex; mode=display">V_N = \{E\}</script><script type="math/tex; mode=display">G =(V_T, \{E\}, P, E)</script><script type="math/tex; mode=display">P = \{\\E\rightarrow E+E,\\E\rightarrow E * E,\\E\rightarrow (E)  \\E\rightarrow id \\\}</script><p>在不引起歧义地前提下，可以只写产生式来简要地代表一个文法系统，如下：</p><script type="math/tex; mode=display">G:\\E\rightarrow E+E\\E\rightarrow E * E\\E\rightarrow (E)\\E\rightarrow id</script><p>这个产生式可以进一步地简写，一组相同左部的产生式</p><script type="math/tex; mode=display">\alpha\rightarrow \beta_1,\alpha\rightarrow \beta_2,\cdots,\alpha\rightarrow \beta_n</script><p>可以简化地记为：</p><script type="math/tex; mode=display">\alpha\rightarrow \beta_1 | \beta_2 | \cdots | \beta_n</script></div><h3 id="符号规定"><a href="#符号规定" class="headerlink" title="符号规定"></a>符号规定</h3><ul><li>常用于表示终结符的符号：<ul><li>字母表中排名靠前的<strong>小写字母</strong>，如 $a,b,c,\cdots$</li><li>运算符，如 $+,*$</li><li>标点符号，如括号，逗号等</li><li>数字，$1,2,3,\cdots$</li><li>粗体写出的字符串，如 $if,then,id,\cdots$</li></ul></li><li>常用于表示非终结符的符号：<ul><li>字母表中排名靠前的<strong>大写字母</strong>，如 $A,B,C,\cdots$</li><li>用于表示开始符号的 $S$，$S$ 也是一个非终结符</li><li>小写斜体的字符串，如 $expr,stnt$（expression 和 statement）</li><li>代表程序构造的大写字母。如 $E$（表达式）、$T$（项）和 $F$（因子）</li></ul></li></ul><p>文法符号集常用排名靠后的大写字母 $X,Y,Z$ 表示</p><p>字母表中排名靠后的小写字母（$u,v,\cdots,z$）常用于表示终结符号串，终结符号串指的是仅有终结符组成的符号串。</p><p>小写希腊字母 $\alpha,\beta,\gamma,\cdots$ 常用于表示文法符号串，文法符号串可以由所有文法符号（非终结符和终结符）组成</p><p>简要地用下面一个表格来表示，方便记忆：</p><div class="table-container"><table><thead><tr><th>表示对象</th><th>符号</th></tr></thead><tbody><tr><td>终结符</td><td>$a,b,c$</td></tr><tr><td>非终结符</td><td>$A,B,C$</td></tr><tr><td>文法符号</td><td>$X,Y,Z$</td></tr><tr><td>终结符号串</td><td>$u,v,\cdots,z$</td></tr><tr><td>文法符号串</td><td>$\alpha,\beta,\gamma$</td></tr></tbody></table></div><h2 id="文法的推导和规约"><a href="#文法的推导和规约" class="headerlink" title="文法的推导和规约"></a>文法的推导和规约</h2><h3 id="文法的推导"><a href="#文法的推导" class="headerlink" title="文法的推导"></a>文法的推导</h3><p>对于给定文法系统 $G = (V_T, V_N, P, S)$，在文法 $G$ 上的推导定义为：</p><p>存在 $\alpha \rightarrow \beta \in P$，那么可以将符号串 $\gamma\alpha\sigma$ 等价地替换为 $\gamma\beta\sigma$，此时称文法中的符号串 $\gamma\alpha\sigma$ 直接推导出 $\gamma\beta\sigma$，记作 $\gamma\alpha\sigma \Rightarrow \gamma\beta\sigma$</p><p>推导是输入符号串而输出符号串的过程，因此连续的推导也是允许的：</p><ul><li>$\Rightarrow^0$ 为 $0$ 步推导，任何符号串的零步推导得到其本身</li><li>$\Rightarrow^+$ 表示正数步推导</li><li>$\Rightarrow^*$ 表示任意步推导（包含零步推导）</li></ul><h3 id="文法的规约"><a href="#文法的规约" class="headerlink" title="文法的规约"></a>文法的规约</h3><p>文法的规约是文法推导的逆过程，存在 $\alpha \rightarrow \beta \in P$，那么可以将字符串中的 $\beta$ 等价地替换为 $\alpha$，一步步回溯上推，最终得到开始符号 $S$</p><p>如下图，就是对上述英语自然语言文法进行规约的例子：</p><center><img src = https://s2.loli.net/2023/03/15/YkiAJRIcreNdmpZ.png width = 90%></center><h2 id="句型、句子和语言"><a href="#句型、句子和语言" class="headerlink" title="句型、句子和语言"></a>句型、句子和语言</h2><h3 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h3><p>如果 $S\Rightarrow^* \alpha$，$\alpha \in (V_T \cup V_N)$，则称 $\alpha$ 是 $G$ 的一个句型（sentential form）</p><blockquote><p>一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串</p></blockquote><h3 id="句子"><a href="#句子" class="headerlink" title="句子"></a>句子</h3><p>句子是一种特殊的句型：如果一个句型不包含非终结符，则称它是一个句子。即：$S \Rightarrow^<em> w$，$w\in V_T^</em>$</p><div class="note warning flat"><p>根据定义，句子有可能是空串</p><p>但并不能认为 $\forall w \in V_T^*$ 都是句子，因为一些终结符组成的串事实上并不能由开始符号推出。</p></div><h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><h4 id="形式化定义"><a href="#形式化定义" class="headerlink" title="形式化定义"></a>形式化定义</h4><p>由文法 $G$ 的开始符号 $S$ 推导出的<strong>所有句子</strong>构成的集合称为文法 $G$ 生成的语言，记为 $L(G)$，即：</p><script type="math/tex; mode=display">L(G) - \{w | S \Rightarrow^* w, w\in V_T^*\}</script><h4 id="语言的运算"><a href="#语言的运算" class="headerlink" title="语言的运算"></a>语言的运算</h4><p>在语言上同样可以定义如下几种运算：</p><ul><li>$L$ 和 $M$ 的并：$L\cup M = \{ s|s 属于 L 或者 s 属于 M\}$</li><li>$L$ 和 $M$ 的连接：$LM = \{ s|s 属于 L 且 s 属于 M\}$</li><li>$L$ 的幂：$L^0 = \{\epsilon\},\;\; L^n = L^{n-1},\;n\ge 1$</li><li>$L$ 的克林闭包：$L^* = \cup_{i=0}^\infin L^i$</li><li>$L$ 的正闭包：$L^+ = \cup_{i=1}^\infin L^i$</li></ul><h4 id="《语言》例题-1"><a href="#《语言》例题-1" class="headerlink" title="《语言》例题 1"></a>《语言》例题 1</h4><p>文法 $G$：</p><ul><li>$S \rightarrow L | LT$</li><li>$T \rightarrow L | D | TL | TD$</li><li>$L \rightarrow a | b | c | \cdots | z$</li><li>$D \rightarrow 0 | 1 | 2 | \cdots | 9$</li></ul><p>该文法的开始符号推导 $S \rightarrow L | LT$ 就确定了任意一个句子必须以字母串为开头</p><blockquote><p>$LT$ 是符号串的连接</p></blockquote><h4 id="《语言》例题-2"><a href="#《语言》例题-2" class="headerlink" title="《语言》例题 2"></a>《语言》例题 2</h4><p>无符号整数的文法 $G$ ：</p><ul><li>$S \rightarrow T$</li><li>$T \rightarrow L | TL$</li><li>$L \rightarrow 0 | 1 | 2 | \cdots | 9$</li></ul><p>浮点数的文法 $G$：</p><ul><li>$S \rightarrow T.T$</li><li>$T \right L | TL$</li><li>$L \rightarrow 0 | 1 | 2 | \cdots | 9$</li></ul><blockquote><p>在开始符号串为左部的产生式中，引入一个中间符号串 $T$ 来描述约束条件，是一种非常实用的策略，比如上述三题中都引入的 $T$，就是这样的“中间符号串”</p></blockquote><hr><h1 id="文法初步"><a href="#文法初步" class="headerlink" title="文法初步"></a>文法初步</h1><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>文法大体可以分为四类：</p><h3 id="0-型文法"><a href="#0-型文法" class="headerlink" title="0 型文法"></a>0 型文法</h3><p>0 型文法右称为无限制文法（Unrestricted Grammar, UG）或短语结构文法（Phrase Structure Grammar, PSG）</p><p>$\forall \alpha \rightarrow \beta \in P$，要求 $\alpha$ 中至少包含一个非终结符。</p><p>由 0 型文法 $G$ 生成的语言 $L(G)$ 称为 0 型语言</p><h3 id="1-型文法"><a href="#1-型文法" class="headerlink" title="1 型文法"></a>1 型文法</h3><p>1 型文法称为上下文有关文法（Context-Sensitive Grammar, CSG）</p><p>1 型文法要求满足如下两条要求，即：</p><ul><li>$\forall \alpha \rightarrow \beta \in P$，要求 $\alpha$ 中至少包含一个非终结符。</li><li>$\forall \alpha \rightarrow \beta \in P$，$|\alpha| \le |\beta|$</li></ul><p>可以看出，1 型文法的第一条要求完全就是 0 型文法的要求，它的要求比 0 型文法更加严格。</p><p>1 型文法的产生式通常写作：$\alpha_1 A \alpha_2 \rightarrow \alpha_1 \beta \alpha_2$</p><p>上式中 $\alpha_1$ 和 $\alpha_2$ 都可以为空串，但 $\beta$ 必然不为空串。</p><h3 id="2-型文法"><a href="#2-型文法" class="headerlink" title="2 型文法"></a>2 型文法</h3><p>2 型文法称为上下文有关文法（Context-Free Grammar, CFG）</p><p>2 型文法要求满足：$\forall \alpha \rightarrow \beta \in P$，$\alpha \in V_N$</p><p>2 型文法虽然仅有一条要求，但实际上，当我们进一步要求 2 型文法的产生式右部不能为空串时， 2 型文法的严格程度在 1 型文法之上：</p><ul><li>1 型文法要求的产生式左部至少有一个非终结符，2 型文法产生式左部就是非终结符，满足 1 型文法的要求</li><li>1 型文法要求产生式左部串长度应该小于等于右部串长度，2 型文法产生式左部的长度恒为 1，右部只要不是空串，即满足 1 型文法的要求</li></ul><p>2 型文法的产生式就是令 1 型文法产生式中的 $\alpha_1$ 和 $\alpha_2$ 等于空串：$A\rightarrow \beta$</p><blockquote><p>比如上述<a href="#语言例题-1">标识符的文法</a>就是一个上下文无关文法</p></blockquote><h3 id="3-型文法"><a href="#3-型文法" class="headerlink" title="3 型文法"></a>3 型文法</h3><p>3 型文法称为正则文法（Regular Grammar，RG），正则文法不仅在 2 型文法的基础上要求产生式左部必须为非终结符，还要求产生式右部至少含有一个终结符，甚至对非终结符的位置都作出要求。</p><p>正则文法可以分为右线性文法（Right Linear）和左线性（Left Linear）文法，它们分别有不同的产生式规则：</p><ul><li>右线性文法：$A\rightarrow wB$ 或 $A\rightarrow w$</li><li>左线性文法：$A\rightarrow Bw$ 或 $A\rightarrow w$</li></ul><p>右线性文法要求若产生式右部含有非终结符，这个非终结符必然在终结符的左侧，左线性文法反之。</p><h3 id="四种文法的关系"><a href="#四种文法的关系" class="headerlink" title="四种文法的关系"></a>四种文法的关系</h3><p>根据上述描述，事实上已经可以发现四种文法呈逐级限制的关系：</p><ul><li>0 型文法：$\alpha$ 至少包含一个非终结符</li><li>1 型文法：$\alpha$ 至少包含一个非终结符，且 $|\alpha| \le |\beta|$</li><li>2 型文法：$\alpha \in V_N$</li><li>3 型文法<ul><li>$A \rightarrow Bw$ 或 $A \rightarrow w$（左线性）</li><li>$A \rightarrow wB$ 或 $A \rightarrow w$（右线性）</li></ul></li></ul><center><img src = https://s2.loli.net/2023/03/15/yAJiHdzYoIvrBcp.png width = 70%></center><p>事实上，编译原理课程中主要研究的文法是 $RG$ 和 $CFG$ 文法，前者被发现适用于描述各种单词的构造，后者主要用于描述表达式的构造</p><p>文法的意义在于将无穷多的句子用有穷的形式表示出来。</p><h2 id="CFG-语法分析树"><a href="#CFG-语法分析树" class="headerlink" title="CFG 语法分析树"></a>CFG 语法分析树</h2><h3 id="CFG-分析树结构"><a href="#CFG-分析树结构" class="headerlink" title="CFG 分析树结构"></a>CFG 分析树结构</h3><h3 id="CFG-分析树结构介绍"><a href="#CFG-分析树结构介绍" class="headerlink" title="CFG 分析树结构介绍"></a>CFG 分析树结构介绍</h3><p>CFG 分析树的每个节点都包含一个文法符号（终结符/非终结符），其中根节点的标号就是文法开始符号。</p><p>树的内部节点及其孩子节点表示一个产生式 $A \rightarrow \beta$，这个内部节点即表示非终结符 $A$，孩子节点分别表示 $\beta$ 中的各个文法符号</p><p>树的叶结点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点标号得到的符号串即称为树的<strong>产出（yield）或边缘（frontier）</strong></p><p>CFG 分析树实际上是文法中推导的图形化表示，对于给定的一个推导 $S\Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow \alpha_n$ 中的任意一个 $\alpha_i$，均可以构造出一个边缘为 $\alpha_i$ 的分析树</p><h4 id="《CFG-分析树结构》例题-1"><a href="#《CFG-分析树结构》例题-1" class="headerlink" title="《CFG 分析树结构》例题 1"></a>《CFG 分析树结构》例题 1</h4><p>例如对于上述介绍的算术表达式文法，要构造句型 $-(id + id)$，可以经过如下推导：</p><script type="math/tex; mode=display">E \Rightarrow -E \Rightarrow -(E) \Rightarrow -(E + E) \Rightarrow -(id + E) \Rightarrow -(id + id)</script><p>这个推导可以用如下 CFG 分析树表示，分析树的边沿就是 $-(id + id)$</p><center><img src = https://s2.loli.net/2023/03/15/Euc137LdbIj6FRx.png width = 40%></center><h3 id="句型的短语"><a href="#句型的短语" class="headerlink" title="句型的短语"></a>句型的短语</h3><p>给定一个句型，其对应分析树中的每一棵<strong>子树</strong>的边缘称为该句型的一个短语（phrase）</p><blockquote><p>鉴于最大的子树就是这棵树本身，因此一个句型本身也是一个短语</p></blockquote><p>如果一个子树高度为 2，那么这棵子树的边缘就称为这个句型的一个直接短语（immediate phrase）</p><p>例如上述<a href="#cfg-分析树结构例题-1">例题</a>中，分析树的短语有 $-(id + id),(id+id),id+id$，其中 $id + id$ 是该句型的一个直接短语</p><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><h4 id="二义性的产生"><a href="#二义性的产生" class="headerlink" title="二义性的产生"></a>二义性的产生</h4><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p><p>例如一个条件判断结构的文法 $G$：</p><ul><li>$S  \rightarrow if\; E\; then\; S$</li><li>$S \rightarrow if \; E \; then \; S \; else \; S$</li><li>$S \rightarrow other_statement$</li></ul><p>下面一个句型 $if \; E_1 \; then \; if \; E_2 \; then \; S_1 \; else \; S_2$，可以构造出下面两棵分析树：</p><center><img src = https://s2.loli.net/2023/03/15/tORJq5hP61oKNCI.png width = 90%></center><p>引发这一结果的原因是 <code>else</code> 与第一个/第二个 <code>if</code> 的对应不清</p><h4 id="二义性的消歧"><a href="#二义性的消歧" class="headerlink" title="二义性的消歧"></a>二义性的消歧</h4><p>上述问题的解决方法就是引入一个消歧规则，比如我们规定每个 <code>else</code> 都默认与<strong>最近的尚未匹配的</strong> <code>if</code> 匹配，那么第二棵语法树就被舍弃。</p><blockquote><p>你也许注意到了，匹配的 <code>if</code> 和 <code>else</code> 在语法树中位于高度相同的同一层</p></blockquote><p>事实上并不存在一个算法来判定任意一个上下无关文法是否具有二义性，但是可以给出一组充分条件使得满足这组充分条件的文法是无二义性的。这些内容将在后续章节介绍。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法原理与代码实现</title>
      <link href="/2023/02/09/c%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/09/c%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）简介与概述"><a href="#（壹）简介与概述" class="headerlink" title="（壹）简介与概述"></a>（壹）简介与概述</h1><p>粒子群算法是一种群智能算法，其核心思想在于将解编码成粒子的位置，并且让这些粒子进行一种同时具有逻辑性和随机性的偏移运动</p><p>这些粒子的偏移运动将受到粒子自身和群体环境的影响，并最终收敛到一个最优解中。</p><p>整体而言，这是一种具备全局搜索能力的启发式算法，并且以超参数较少的优点而受到使用者的追捧。</p><h1 id="（贰）粒子群优化算法流程"><a href="#（贰）粒子群优化算法流程" class="headerlink" title="（贰）粒子群优化算法流程"></a>（贰）粒子群优化算法流程</h1><h2 id="初始化粒子的位置和速度"><a href="#初始化粒子的位置和速度" class="headerlink" title="初始化粒子的位置和速度"></a>初始化粒子的位置和速度</h2><h3 id="粒子位置-rightarrow-解"><a href="#粒子位置-rightarrow-解" class="headerlink" title="粒子位置 $\rightarrow$ 解"></a>粒子位置 $\rightarrow$ 解</h3><p>粒子群优化算法的抽象方式是将待优化参数的值编码为每个粒子的位置。因此解空间的维度就是粒子运动空间的维度。如果我们要优化的参数有 $n$ 个，也就是目标函数的变量维度是 $n$，那么假设 $X_i(t)$ 是粒子群系统第 $t$ 次迭代中第 $i$ 个粒子的坐标，也就是第 $t$ 次迭代中存在于系统中的一组解，即：</p><script type="math/tex; mode=display">X_i(t) = (x^t_{i1},x^t_{i2},x^t_{i3},\cdots,x^t_{in})</script><p>其中 $x^t_{ij}$ 表示粒子群系统第 $t$ 次迭代中第 $i$ 个粒子位置的第 $j$ 维分量。</p><blockquote><p>这里的位置只是一个形象的表述方式，实际上 $X_i(t)$ 对应于一个 $n$ 维空间上的坐标</p></blockquote><h3 id="粒子速度-rightarrow-解（坐标）偏移量"><a href="#粒子速度-rightarrow-解（坐标）偏移量" class="headerlink" title="粒子速度 $\rightarrow$ 解（坐标）偏移量"></a>粒子速度 $\rightarrow$ 解（坐标）偏移量</h3><p>我们用粒子的速度来反映一组解的偏移情况，速度维度同样是 $n$，我们将粒子群系统第 $t$ 次迭代中第 $i$ 个粒子的速度记为 $V_i(t)$，如下：</p><script type="math/tex; mode=display">V_i(t) = (v^t_{i1},v^t_{i2},v^t_{i3},\cdots,v^t_{in})</script><p>粒子速度实际上用于表示粒子坐标的偏移量，它在每次迭代中改变粒子的坐标：</p><blockquote><p>每个粒子最初始的位置都是随机设置的，而在此后迭代中速度的更新遵循如下规则：</p></blockquote><script type="math/tex; mode=display">X_i(t + 1) = X_i(t) + V_i(t) \tag{1}</script><blockquote><p>上述式子是一个向量等式，本节内容将会大量采用向量等式来简化公式，请注意辨别</p><p>这里的速度只是一个形象的表述，实际上 $V_i(t)$ 代表一个 $n$ 维空间坐标各分量的偏移值</p></blockquote><p>稍后我们将看到，算法的核心机制实际上就是对速度的调整，它将指引代表解（粒子）向目标方向靠拢。</p><h2 id="速度的更新"><a href="#速度的更新" class="headerlink" title="速度的更新"></a>速度的更新</h2><blockquote><p>每个粒子最初始的速度都是随机设置的，而在此后迭代中速度的更新遵循如下规则</p></blockquote><p>从第 $t$ 次迭代到第 $t+1$ 次迭代的速度更新公式由三部分组成：惯性部分、认知部分和社会部分</p><h3 id="惯性部分"><a href="#惯性部分" class="headerlink" title="惯性部分"></a>惯性部分</h3><p><strong>惯性部分旨在继承第 $t$ 次迭代中的速度</strong>，类似于进化算法中亲本的传递，它维持原有运动状态的稳定性，用 $inertance$ 表示惯性部分：</p><script type="math/tex; mode=display">inertance = \omega V_i(t)\tag{2}</script><p>其中 $\omega$ 表示惯性权重，用于衡量上次迭代中速度的稳定性，也就是对于原有偏移值得信任程度。</p><h3 id="认知部分"><a href="#认知部分" class="headerlink" title="认知部分"></a>认知部分</h3><p><strong>认知部分强调粒子根据自身“经验”作出的判断</strong>，即第 $i$ 个粒子根据自身当前位置 $X_i(t)$ 和自己到达过的最优位置 $PB_i$ （$personal\; best$）的偏差来调整速度。用 $cognize$ 表示认知部分：</p><script type="math/tex; mode=display">cognize = c_1\cdot rand(0,1) \cdot (PB_i - X_i(t))\tag{3}</script><p>其中 $c_1$ 表示个体学习因子，代表认知部分的重要程度，$rand(0,1)$ 是一个随机值，用于为速度的调节增加一定随机性，使得算法拥有一定随机搜索的能力，防止过早陷入局部最优。</p><h3 id="社会部分"><a href="#社会部分" class="headerlink" title="社会部分"></a>社会部分</h3><p><strong>社会部分强调粒子对群体的最优经验的参考</strong>，并据此调整自己的速度。用 $GB$（$group\;best$）表示所有粒子在历史迭代中到达过的最佳位置，将社会部分记为 $society$ ：</p><script type="math/tex; mode=display">society = c_2\cdot rand(0,1)\cdot(GB - X_i(t))\tag{4}</script><p>其中 $c_2$ 是群体学习因子，用于表示社会部分的重要程度。</p><h3 id="更新公式"><a href="#更新公式" class="headerlink" title="更新公式"></a>更新公式</h3><p><strong>速度的更新公式即惯性部分、认知部分和社会部分的叠加</strong>，即有第 $i$ 个粒子的速度更新公式如下：</p><script type="math/tex; mode=display">V_i(t + 1) = V_i(t) + inertance + cognize + society</script><script type="math/tex; mode=display">V_i(t+1) = \omega V_i(t) + c_1r_1(PB_i - X_i(t)) + c_2r_1(GB - X_i(t)) \tag{5}</script><blockquote><p>注意认知部分和社会部分的两个随机数是分别生成的，以示区别，这里将两个随机数分别记为 $r_1$ 和 $r_2$</p></blockquote><h2 id="最优位置的衡量与更新"><a href="#最优位置的衡量与更新" class="headerlink" title="最优位置的衡量与更新"></a>最优位置的衡量与更新</h2><p>上述速度更新公式中使用到的两个重要概念就是“单个粒子最优位置”和“粒子群体最优位置”</p><p>衡量哪个位置最优实际上就是衡量哪个位置对应的解能使得目标函数取得最优值（在我们的算法中，默认是最小值）。</p><p>假设我们要优化的目标函数为 $f$，自然，根据上述定义 $f$ 应该具有 $n$ 个参数，每个粒子的位置都对应一个函数值，在群智能算法中，它被称为“适应值”，如下：</p><script type="math/tex; mode=display">f(X_i(t)) = f(x_{i1}^t,x_{i2}^t,x_{i3}^t,\cdots,x_{in}^t)</script><p>第 $i$ 个粒子个体的历史最佳适应值应为：</p><script type="math/tex; mode=display">f(PB_i) = min\{f(X_i(1)),f(X_i(2)),f(X_i(3)),\cdots,f(X_i(n))\}</script><p>第 $i$ 个粒子个体的历史最佳位置就是对应于 $f(PB_i)$ 值的一个位置（解） </p><script type="math/tex; mode=display">PB_i = arg\ min\;\{f(X_i(1)),f(X_i(2)),f(X_i(3)),\cdots,f(X_i(n))\}\tag{6}</script><p>同理，粒子群体的历史最佳位置也可以表示称如下形式：</p><script type="math/tex; mode=display">GB = arg\ min\;\{f(PB_1),f(PB_2),f(PB_3),\cdots,f(PB_n)\}\tag{7}</script><h2 id="完整算法流程"><a href="#完整算法流程" class="headerlink" title="完整算法流程"></a>完整算法流程</h2><p>粒子群进化算法的完整算法流程如下流程图所示：</p><center><img src = https://s2.loli.net/2023/02/09/59lQVJGjIBhnxSt.png></center><p>其中退出条件一般指如下两种情况：</p><ul><li>两次迭代产生的粒子群体的历史最佳适应值差已经达到精度要求</li><li>迭代次数已经达到预定的最大次数</li></ul><h2 id="调参技巧"><a href="#调参技巧" class="headerlink" title="调参技巧"></a>调参技巧</h2><p>上述粒子群算法一共包含如下几个超参数：</p><blockquote><p>迭代次数充足即可，此处不论</p></blockquote><ul><li>惯性部分的权重 $\omega$</li><li>认知部分和社会部分的学习因子：$c_1$ 和 $c_2$</li></ul><p>对于惯性部分的权重 $\omega$，其值越大越有利于全局搜索，因为<strong>惯性部分越强，该算法越不容易受到“历史最佳”的诱导，“历史最佳”虽然为粒子的前进方向提供了一定有利的指引，但也容易使粒子陷入局部最优的境地</strong>。相反，较小的 $\omega$ 有利于局部搜索，并加快算法的收敛速度。一般设置在 $[0.4,2]$</p><p><strong>一些流行的观点认为，$\omega$ 应该设为一个动态的值</strong>，让它处于一个区间 $[\omega_{min},\omega_{max}]$ 内，在算法的初期，我们希望粒子群拥有更强的全局搜索能力，在算法后期，我们则希望粒子群算法更快地收敛到一个解，因此我们可以采用如下方法:</p><script type="math/tex; mode=display">\omega = \omega_{max} - (\omega_{max} - \omega_{min})\frac{curr\_iter}{max\_iter}</script><p>其中 $curr_iter$ 表示当前迭代次数，而 $max_iter$ 表示最大迭代次数</p><p>对于学习因子 $c_1$ 和 $c_2$，一般取值在 $[0,4]$ 之间，比如 $c_1 = c_2 = 2$ 和 $c_1 = 1.6, c_2 = 1.8$。当然使用进化算法或其它启发式算法来优化参数也是可行之策，具体见此篇 <a href="https://www.lixinbook.cn/2023/02/08/c%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/">笔记（点击跳转）</a>，这篇笔记中就提供了利用进化算法来优化蚁群算法的思路。</p><h1 id="（叁）粒子群算法代码构建"><a href="#（叁）粒子群算法代码构建" class="headerlink" title="（叁）粒子群算法代码构建"></a>（叁）粒子群算法代码构建</h1><p>此处采用 <code>scikit-opt</code> 库来实现粒子群算法</p><p>其主要入参涵义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func       <span class="comment"># 目标待优化函数</span></span><br><span class="line">n_dim      <span class="comment"># 目标函数维度，待优化的参数个数</span></span><br><span class="line">size_pop   <span class="comment"># 粒子群规模 </span></span><br><span class="line">max_iter   <span class="comment"># 最大迭代次数</span></span><br><span class="line">lb         <span class="comment"># 每个参数的下界</span></span><br><span class="line">ub         <span class="comment"># 每个参数的上界</span></span><br><span class="line">w          <span class="comment"># 惯性权重</span></span><br><span class="line">c1         <span class="comment"># 认知部分权重（个体学习因子）</span></span><br><span class="line">c2         <span class="comment"># 社会部分权重（集体学习因子）</span></span><br></pre></td></tr></table></figure><p>输出值为 <code>gbest_x</code> 和 <code>gbest_y</code>，前者是达到最终集体最优时所有参数的取值，后者是最终的集体最优值</p><p>同时，还可以通过查看 <code>gbest_y_hist</code> 属性来得到每次迭代的集体历史最优值，并以此作出优化过程曲线图。</p><p><code>PSO</code> 类还使用一个数据结构 <code>record_value</code> 来记录每次迭代中每个粒子的位置和对应的适应值，<code>record</code> 数据结构是一个字典，<code>&#39;X&#39;</code> 词条对应记录历次迭代中所有点位置的二维数组，<code>&#39;Y&#39;</code> 词条对应记录历次迭代中所有点适应值的一维数组。<code>sciopt-kit</code> 库中采用如下语句记录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recorder</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.record_mode:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.record_value[<span class="string">&#x27;X&#x27;</span>].append(self.X)</span><br><span class="line">    self.record_value[<span class="string">&#x27;Y&#x27;</span>].append(self.Y)</span><br></pre></td></tr></table></figure><p>如果要启用记录功能，还应该将 <code>record_mode</code> 初始化为 <code>True</code>：<code>pso.record_mode = True</code>。</p><blockquote><p>如果是二维变量，可以建立二维或三维坐标系形象化迭代过程，就是将每代粒子的位置绘出，但高维问题一般没有这样处理的必要了</p></blockquote><p>下面是官方文档提供的一个例子，由于此前 <a href="https://www.lixinbook.cn/2023/02/03/c%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/">笔记（点击跳转）</a>中对于这个框架分析很透彻了，此处就不再详细解释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib.animation <span class="keyword">import</span> FuncAnimation</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.PSO <span class="keyword">import</span> PSO</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">demo_func</span>(<span class="params">x</span>):</span><br><span class="line">    x1, x2 = x</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">20</span> * np.exp(-<span class="number">0.2</span> * np.sqrt(<span class="number">0.5</span> * (x1 ** <span class="number">2</span> + x2 ** <span class="number">2</span>))) - np.exp(</span><br><span class="line">        <span class="number">0.5</span> * (np.cos(<span class="number">2</span> * np.pi * x1) + np.cos(<span class="number">2</span> * np.pi * x2))) + <span class="number">20</span> + np.e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">constraint_ueq = (<span class="keyword">lambda</span> x: (x[<span class="number">0</span>] - <span class="number">1</span>) ** <span class="number">2</span> + (x[<span class="number">1</span>] - <span class="number">0</span>) ** <span class="number">2</span> - <span class="number">0.5</span> ** <span class="number">2</span>, )</span><br><span class="line">max_iter = <span class="number">50</span></span><br><span class="line">pso = PSO(func=demo_func, n_dim=<span class="number">2</span>, pop=<span class="number">40</span>, max_iter=max_iter,</span><br><span class="line">          lb=[-<span class="number">2</span>, -<span class="number">2</span>], ub=[<span class="number">2</span>, <span class="number">2</span>], constraint_ueq=constraint_ueq)</span><br><span class="line">pso.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best_x is &#x27;</span>, pso.gbest_x, <span class="string">&#x27;best_y is&#x27;</span>, pso.gbest_y)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从蚁群算法到可进化高阶蚁群算法</title>
      <link href="/2023/02/08/c%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/08/c%E8%9A%81%E7%BE%A4%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）简介与概述"><a href="#（壹）简介与概述" class="headerlink" title="（壹）简介与概述"></a>（壹）简介与概述</h1><p>蚁群算法是一种最优寻路算法，一般而言并非通用优化算法，而是往往用在最佳路径求解问题上。</p><p>该算法的灵感及核心思路就是蚁群的一种正反馈机制：</p><p>蚂蚁寻找食物时，在走过的历经上释放一种称为“信息素”的激素，越多蚂蚁走过的路径信息素越多，又会增加这条路径的信息素数量，最终导致解收敛。</p><h1 id="（贰）蚁群算法过程"><a href="#（贰）蚁群算法过程" class="headerlink" title="（贰）蚁群算法过程"></a>（贰）蚁群算法过程</h1><h2 id="转移概率"><a href="#转移概率" class="headerlink" title="转移概率"></a>转移概率</h2><p>我们不妨通过旅行商问题来描述蚁群算法，旅行商问题是指商人如何以最短的路径访问完全部的 $n$ 座城市（要求每座城市都只能访问一次）</p><p>假设蚂蚁种群的规模为 $m$，城市的数量为 $n$，城市 $i$ 和城市 $j$ 之间的距离记为 $d_{i,j}$，在时刻 $t$ 时城市之间连接路径上的信息素浓度为 $\tau_{i,j}(t)$</p><p>在初始情况下，所有蚂蚁分布在各个城市里，各个城市连接路径上的信息素浓度都相同，设为 $\tau_{init}$，即有：</p><script type="math/tex; mode=display">\tau_{i,j}(0) = \tau_{init},\;\;\; i ,j = 1,2,\cdots,n  \tag{1}</script><p>我们将 $t$ 时刻下种群中的第 $k$ 蚂蚁从城市 $i$ 转移到城市 $j$ 的概率设为 $P^k_{i,j}(t)$，另外，我们规定了蚂蚁只能访问没去过的城市，因此用 $A_k$ 表示第 $k$ 只蚂蚁允许访问的城市集合，</p><p>为了让路径距离对初始时蚂蚁的选择造成一定影响，防止蚂蚁无序随机地乱走而导致算法退化为随机搜索，我们增加一个启发值的概念，并切实影响到 $P^k_{i,j}(t)$ 的结果。我们将每只蚂蚁在时刻 $t$ 时城市 $i$ 到 $j$ 路径上的启发值记为 $\eta_{i,j}(t)$，通常启发值被设置为对应路径距离的倒数，即：</p><script type="math/tex; mode=display">\eta_{i,j}(t) = \frac{1}{d_{i,j}}\tag{2}</script><p>在蚁群算法中，我们像下面这样定义 $P^k_{i,j}(t)$：</p><script type="math/tex; mode=display">P_{i,j}^k(t) = \left\{    \begin{aligned}        &\frac{[\tau_{i,j}(t)]^\alpha \cdot [\eta_{i,j}(t)]^\beta}{\sum_{s\in A_k}[\tau_{i,s}(t)]^\alpha \cdot [\eta_{i,s}(t)]^\beta},\;\;\;if\; j \in A_k\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{3}</script><p>上式中 $\alpha$ 和 $\beta$ 分别用于表示信息素浓度和启发值两者之间的重要程度。</p><p>这个式子实际上就是蚁群算法的核心，它形式复杂，实则很好理解：我们用 $[\tau_{i,j}(t)]^\alpha \cdot [\eta_{i,j}(t)]^\beta$ 表示位于城市 $i$ 的蚂蚁 $k$ 选择城市 $j$ 作为目的地的权值，而分母就表示蚂蚁 $k$ 从城市 $i$ 出发的所有路径的权值之和，因此上式就表示城市间转移的概率。</p><p>确定各个城市的转移概率后，我们就可以使用<strong>轮盘赌算法</strong>来依照概率选择一个城市作为目的地。</p><p>上述式子中 $\alpha$ 和 $\beta$ 之间的竞争关系很值得一番品味，如果 $\alpha$（信息素重要程度）过分大，启发值几乎不起作用，并且一开始所有路径信息素初值一致，该算法就相当于蚂蚁随机走动。如果 $\beta$ 值（启发值重要程度）过分大，则蚂蚁的每次选择几乎根据路径长度决定，该算法就相当于贪心策略，很难搜索到全局最优解。通常我们将 $\alpha$ 设置为 $1$ 而将 $\beta$ 设置成 $6$</p><h2 id="信息素更新"><a href="#信息素更新" class="headerlink" title="信息素更新"></a>信息素更新</h2><p>在第 $g$ 次迭代中，信息素的更新公式如下：</p><script type="math/tex; mode=display">\tau_{i,j}(g + 1) = (1 - \rho)\cdot \tau_{i,j}(g) + \sum_{t = 1}^n\Delta\tau_{i,j}(t)\tag{4}</script><p>式子左边部分中，$(1 - \rho)\tau_{i,j}(g)$ 描述的是路径上信息素随时间的衰减，$\rho\in (0,1)$。而 $\Delta \tau_{i,j}(t)$ 则描述在时刻 $t$ 时城市 $i$ 到 $j$ 路径上的信息素因蚂蚁们的经过而增加：</p><script type="math/tex; mode=display">\Delta \tau_{i,j}(t) = \sum_{k = 1}^m \Delta\tau_{i,j}^k(t)\tag{5}</script><p>其中 $\Delta\tau_{i,j}^k(t)$ 表示第 $k$ 只蚂蚁在时刻 $t$ 时在城市 $i,j$ 的路径上留下的信息素，如果第 $k$ 只蚂蚁在时刻 $t$ 并不经过这条路径，则将它引发的信息素增加记为 $0$，否则，它引发的信息素增加和它已经走过的路径成反比，我们用如下公式描述这一逻辑：</p><script type="math/tex; mode=display">\Delta\tau_{i,j}^k(t) = \left\{    \begin{aligned}        &\frac{Q}{L_k},\;\;\; if\;ant\;k\;travels\;from\;i\;to\;j\;in\;time\;t\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{6}</script><p>$Q$ 是信息素常数，而 $L_k$ 则表示第 $k$ 只蚂蚁本次迭代中走过的路径总长度，将 $d_k(s)$ 记为第 $k$ 只蚂蚁在时刻 $s$ 时选择的路径长度，则上式可以改写为：</p><script type="math/tex; mode=display">\Delta\tau_{i,j}^k(t) = \left\{    \begin{aligned}        &\frac{Q}{\sum_{s = 0}^{n} d_k(s)},\;\;\; if\;ant\;k\;travels\;from\;i\;to\;j\;in\;time\;t\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{7}</script><blockquote><p>上述式子中 $\frac{Q}{\sum_{s = 0}^{n} d_k(s)}$ 表示蚂蚁完成整个周游走过的路径长度，可能此处会令人费解，因为在 $t$ 时刻尚未完成整个周游，蚂蚁怎么得知自己周游花费的路径？</p><p>事实上这是一个纯粹数学的设定，由于信息素的更新并不是即刻的，而是滞后到所有蚂蚁完成一趟周游后才执行的——</p></blockquote><p><strong>重点：需要注意的是，并不是在每次蚂蚁转移后都立即对路径上的信息素进行更新，而是在所有蚂蚁都完成一遍对所有城市的访问后，才统一更新各路径信息素的浓度。</strong></p><p>这也契合刚刚对于信息素更新公式的定义：</p><script type="math/tex; mode=display">\tau_{i,j}(g + 1) = (1 - \rho)\cdot \tau_{i,j}(g) + \sum_{t = 1}^n\Delta\tau_{i,j}(t)\tag{4}</script><p>各路径上的信息素可以被记录在一个矩阵中，一些文献也称之为信息素表，而每只蚂蚁在单次迭代中已经去过的城市也可以用矩阵记录，被称为禁忌表</p><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>蚁群算法的完整算法流程如下图所示</p><center><img src = https://s2.loli.net/2023/02/08/jnS7lcINfK9Vsi8.png width></center><p>对于上述介绍的一些超参数，也应该在算法初始时给出</p><p>蚁群数量最好为目标城市数量的 $1.5$ 倍，信息素挥发因子 $\rho$ 一般设置在 $[0.2,0.5]$，迭代次数一般设置在 $[100,500]$，在 <code>scikit-opt</code> 库中，信息素常量 $Q$ 的值被默认为 $1$</p><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><p>综观上述流程，可以发现蚁群算法中的核心要点在于：</p><ul><li>启发值和信息素值的竞争，前者用贪心方式作最初指引，后者引导蚁群探索最优解</li><li>得出转移概率后的轮盘赌机制，这一机制引入了随机性，同时在数量较大时能确保走当前较优路线的蚂蚁较多，又留有一部分蚂蚁去寻找当前非最优但可能具有潜力的路径，这种随机性赋予了算法全局搜索的能力</li><li>尽管该系统的蚁群并没有遗传之类的概念，但信息素却可以视为蚂蚁前辈对后辈的指引，信息素存在的意义就是保留历代蚂蚁探索的结果，某种程度上就是“<strong>基因</strong>”</li></ul><p>蚁群算法也存在不足：</p><p>蚁群算法中信息素初值相同，开始时选择下一个节点时倾向于随机选择，只有信息素累加到一定值时才能发挥正反馈作用。虽然这样有机会探寻更大的解空间，却将延长收敛时间。而正反馈的机制如果发挥作用过强，又很容易造成局部收敛问题。</p><p>收敛速度和全局搜索能力是蚁群算法的一对不可调和的矛盾，在其它启发式算法中也有体现。</p><p>另外，蚁群算法十分依赖调参，超参数的取值很可能影响算法的最终效果，因此在后续内容我们将探究如何克服这些问题。</p><h1 id="（叁）蚁群算法代码构建"><a href="#（叁）蚁群算法代码构建" class="headerlink" title="（叁）蚁群算法代码构建"></a>（叁）蚁群算法代码构建</h1><p>下面是通过调用 <code>sciopt-kit</code> 库的 <code>ACA_TSP</code> 类实现对蚁群算法的构建：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sko.ACA <span class="keyword">import</span> ACA_TSP</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">num_points = <span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用随机数生成 num_points 个点</span></span><br><span class="line">points_coordinate = np.random.rand(num_points, <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 调用 scipy 自动计算点与点之间的欧拉距离，生成距离矩阵</span></span><br><span class="line">distance_matrix = spatial.distance.cdist(</span><br><span class="line">    points_coordinate, points_coordinate, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal_total_distance</span>(<span class="params">routine</span>):</span><br><span class="line">    num_points, = routine.shape</span><br><span class="line">    <span class="comment"># 计算距离和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>([distance_matrix[routine[i % num_points], routine[(i + <span class="number">1</span>) % num_points]] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num_points)])</span><br><span class="line"></span><br><span class="line">aca = ACA_TSP(func=cal_total_distance, n_dim=num_points,</span><br><span class="line">              size_pop=<span class="number">450</span>, max_iter=<span class="number">1000</span>,</span><br><span class="line">              distance_matrix=distance_matrix)</span><br><span class="line"></span><br><span class="line">best_x, best_y = aca.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best_x: \n&#x27;</span>, best_x, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;best_y: &#x27;</span>, best_y)</span><br><span class="line"></span><br><span class="line">fig, ax = plt.subplots(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">best_circuit = np.concatenate([best_x, [best_x[<span class="number">0</span>]]])</span><br><span class="line">best_points_coordinate = points_coordinate[best_circuit, :]</span><br><span class="line">ax[<span class="number">0</span>].plot(best_points_coordinate[:, <span class="number">0</span>], best_points_coordinate[:, <span class="number">1</span>], <span class="string">&#x27;o-r&#x27;</span>, markersize=<span class="number">3</span>)</span><br><span class="line">pd.DataFrame(aca.y_best_history).cummin().plot(ax=ax[<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>该函数的输入和输出如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input</span></span><br><span class="line">func                <span class="comment"># 目标函数，用一个参数 routine 来跟踪蚂蚁走过的路径    </span></span><br><span class="line">n_dim               <span class="comment"># 城市个数，也是 routine 参数的最终长度</span></span><br><span class="line">size_pop            <span class="comment"># 蚁群的规模</span></span><br><span class="line">max_iter            <span class="comment"># 最大迭代次数</span></span><br><span class="line">distance_matrix     <span class="comment"># 城市之间的距离矩阵，尽管 func 中已经根据这个矩阵求解路径距离总和，</span></span><br><span class="line">                    <span class="comment"># 仍然需要提供一个距离矩阵参数给算法以便计算信息素的挥发</span></span><br><span class="line">alpha               <span class="comment"># 信息素的重要程度，默认为 1</span></span><br><span class="line">beta                <span class="comment"># 启发值的重要程度，默认为 2</span></span><br><span class="line">rho                 <span class="comment"># 信息素的挥发速度，默认为 0.1，即信息素每次以 1-rho 的倍率衰减</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># output</span></span><br><span class="line">best_x              <span class="comment"># 一个列表，记录最优的路径上的点的依序索引</span></span><br><span class="line">best_y              <span class="comment"># 一个值，记录最优路径的长度</span></span><br><span class="line">y_best_history      <span class="comment"># 一个表格，记录每次迭代求出的最优路径的值</span></span><br><span class="line">                    <span class="comment"># 横坐标是迭代次数索引，纵坐标最优路径值</span></span><br></pre></td></tr></table></figure><p>另外，需要注意的一些细节是，当我们给出矩阵的坐标后，可以使用如下代码快捷地计算欧拉距离矩阵：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distance_matrix = spatial.distance.cdist(points_coordinate, points_coordinate, metric=<span class="string">&#x27;euclidean&#x27;</span>)</span><br></pre></td></tr></table></figure><p>绘图时需要将所有坐标首位连接组成环路，因此这里将 <code>best_x</code> 列表的第一个点添加到列表最后，并调用 <code>np.concatenate</code> 方法将这个列表转为 <code>np.ndarray</code> 类型 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best_circuit = np.concatenate([best_x, [best_x[<span class="number">0</span>]]])</span><br></pre></td></tr></table></figure><p>使用切片的方法可以根据 <code>best_circuit</code> 的点序导出新的坐标列表，然后就可以利用 <code>matplotlib</code> 根据 <code>points_coordinate</code> 绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best_points_coordinate = points_coordinate[best_circuit, :]</span><br></pre></td></tr></table></figure><p>在一些情形下，我们需要泛化 $TSP$ 以适应不同场景时，就需要修改矩阵中坐标的涵义，或者距离的计算方式，这只要结合具体情形进行计算即可，大体框架不变。</p><p>这个示例要跑很久，结果非常壮观，如下图所示：</p><center><img src = https://s2.loli.net/2023/02/08/6KfXHasjSBTLJyr.png width = 80%></center><h1 id="（肆）高级蚁群算法"><a href="#（肆）高级蚁群算法" class="headerlink" title="（肆）高级蚁群算法"></a>（肆）高级蚁群算法</h1><h2 id="精英策略蚁群算法"><a href="#精英策略蚁群算法" class="headerlink" title="精英策略蚁群算法"></a>精英策略蚁群算法</h2><p>精英保留策略的核心思路是强化对那些信息素遗留较多的路径的选择倾向，从而加快蚁群算法的收敛速度。当然，这样的操作势必会削弱部分全局搜索能力，但其程度被我们视为合理的水平。</p><p>算法的原理是如果一只蚂蚁走过的是当前发现的已知最优路径，作为“上帝”的我们对它进行激励，让它这段路径上分泌的信息素增多，从而加快算法收敛速度</p><p>我们将算法当前发现的最优路径记为 $BSF$（$best\;so\;far$），在原始的 $\Delta\tau_{i,j}^k(t)$ 公式基础上设置一个额外的正反馈值，这个正反馈源于我们对蚂蚁走上最优路径的激励：</p><script type="math/tex; mode=display">stimulate = \left\{    \begin{aligned}        &\frac{e}{L_{bsf}},\;\;\;(i,j)\in BSF\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{8}</script><p>其中 $L_{bsf}$ 表示当前已知的最优路径的长度，$e$ 则是一个调整激励值权重的超参数</p><p>将 $simulate$ 引入计算路径 $(i,j)$ 的信息素增量 $\Delta \tau_{i,j}(t)$ 的公式 (5) 中，得到：</p><script type="math/tex; mode=display">\Delta \tau_{i,j}(t) = \sum_{k = 1}^m \Delta\tau_{i,j}^k(t) + stimulate\tag{9}</script><p>精英保留策略的蚁群算法即依赖上式实现信息素更新机制。</p><h2 id="最大最小蚁群算法"><a href="#最大最小蚁群算法" class="headerlink" title="最大最小蚁群算法"></a>最大最小蚁群算法</h2><p>最大最小蚁群算法以另一种方式引入了变相的精英策略，同时引入了规避精英策略产生的局部收敛问题。</p><p>最大最小蚁群算法同样在信息素更新机制上作文章，它规定只有单次迭代中路径最短的蚂蚁才有更新路径信息素的权力。这实际上是一种变相的精英策略。据此，公式 (5) 和 (6) 可以被更新如下</p><script type="math/tex; mode=display">\Delta \tau_{i,j}(t) =\Delta\tau_{i,j}^{best}(t)\tag{10}</script><script type="math/tex; mode=display">\Delta\tau_{i,j}^{best}(t) = \left\{    \begin{aligned}        &\frac{Q}{L_{best}},\;\;\; if\;best\;ant\;travels\;from\;i\;to\;j\;in\;time\;t\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{11}</script><p>$\Delta\tau_{i,j}^{best}(t)$ 表示单次迭代最优蚂蚁在时刻 $t$ 从城市 $i$ 前往城市 $j$ 的过程中释放的信息素</p><blockquote><p>一些文献中对于 $best\;ant$ 的选择采用的是历史迭代中达到最优路径的蚂蚁，两种实现方式均可，选用单次迭代通常全局搜索性能稍强而收敛速度稍慢。</p></blockquote><p>另外，最大最小蚁群算法为了规避不同路径上的信息素浓度出现极高或极低的情形，还设置了路径信息素浓度的最大值和最小值，即信息素必须限制在 $[\tau_{min},\tau_{max}]$ 区间内，这样避免极端情况导致的过早局部收敛。</p><h2 id="基于排序的蚁群算法"><a href="#基于排序的蚁群算法" class="headerlink" title="基于排序的蚁群算法"></a>基于排序的蚁群算法</h2><p>基于排序的蚁群算法本质上是最大最小蚁群算法的演化，它规定只有排名位于前 $w-1$ 位的精英蚂蚁有权利释放信息素，并且排名第一的精英蚂蚁被视为“国王”蚂蚁，它在信息素的释放上甚至有额外的特权。基于这种思路，我们将公式 (5) 改写如下：</p><script type="math/tex; mode=display">\Delta \tau_{i,j}(t) = \sum_{r= 1}^{w - 1} (w - r)\Delta\tau_{i,j}^r(t) + w\Delta\tau_{i,j}^{best}(t)\tag{12}</script><p>其中 $\Delta\tau_{i,j}^r(t)$ 表示排名为 $r$ 的蚂蚁在时刻 $t$ 在路径 $(i,j)$ 释放的信息素，$(w-r)$ 是为了给排名更高的蚂蚁赋予更大的权重。$\Delta\tau_{i,j}^{best}(t)$ 是“国王蚂蚁”的释放特权。</p><blockquote><p>当取 $w = 1$ 时，基于排序的蚁群算法退化为最大最小蚁群算法。</p></blockquote><h1 id="（伍）基于进化算法的蚁群算法优化"><a href="#（伍）基于进化算法的蚁群算法优化" class="headerlink" title="（伍）基于进化算法的蚁群算法优化"></a>（伍）基于进化算法的蚁群算法优化</h1><p>上述介绍的各种蚁群算法中含有各种超参数，一般这些超参数都有经验取值，可以通过查阅资料得到，但是针对不同问题难免经验取值会出现一定偏差。此时，比较好的做法就是在经验取值的附近求取超参数的最优解。</p><p>比如基于排序的蚁群算法有下面一组超参数：</p><ul><li>蚁群规模：<code>size_pop</code></li><li>信息素的重要程度：<code>alpha</code>               </li><li>启发值的重要程度：<code>beta</code>                </li><li>信息素挥发速率：<code>rho</code></li><li>精英蚂蚁的数量：<code>omiga</code> </li></ul><p>一种基于进化算法的蚁群算法（Evolvable Ant Colony Algorithm，EACA）构建流程如下：</p><ul><li>确定超参数的范围，不宜过大，可以查阅相关资料</li><li>从进化算法接口处申请若干个待优化参数作为蚁群算法的超参数。</li><li>将蚁群算法步骤嵌入进化算法的目标优化问题中。</li><li>调用进化算法，进化算法将反复调用蚁群算法，并求出最优超参数。</li></ul><p>实现代码如下：</p><blockquote><p>TODO：后续补充</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从模拟退火到退火进化算法（原理、实现）</title>
      <link href="/2023/02/07/c%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/07/c%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）简介与概述"><a href="#（壹）简介与概述" class="headerlink" title="（壹）简介与概述"></a>（壹）简介与概述</h1><p>模拟退火（Simulated Annealing，简称 SA）算法是一种启发式优化算法。</p><p>其核心思路在于模仿金属退火的过程，在算法初期，温度较高时，算法对于一些劣解仍抱有较为宽容的“热情”态度，欢迎各种解状态的出现，以便增强该算法的全局搜索能力；在算法后期，这一态度将变得越来越冷漠，并最终达到收敛。</p><p>它和其它启发式算法核心思想上很相似，在趋向最优的同时保持一定“游走”能力，避免陷入局部最优的境地。</p><p>综合而言，模拟退火算法具有描述简单、使用灵活、运用广泛、运行效率高和较少受到初始条件约束而具有较强鲁棒性等优点；而它的缺点在于解的质量受到初始温度和链长（迭代次数）的影响，迭代越充分，更容易搜索到全局最优解，但相应的搜索时间也会变长。</p><hr><h1 id="（贰）模拟退火算法流程"><a href="#（贰）模拟退火算法流程" class="headerlink" title="（贰）模拟退火算法流程"></a>（贰）模拟退火算法流程</h1><p>模拟退火算法流程相对简单，可以用如下流程图进行表示。</p><center><img src = https://s2.loli.net/2023/02/07/Z1jPYHwRkgXfi9n.png></center><p>流程图中，$S_0$ 代表初始的解状态，$S_i$ 表示经过第 $i$ 次迭代后当前系统的解状态，$S_{new}$ 表示对当前系统状态 $S_i$ 进行随机扰动后得到的新状态，随机扰动的方法一般就是在原有解 $S_i$ 的邻域产生一个新的解</p><p>函数 $f$ 实际上就是问题的等价函数形式，它根据一组解的值来判别这组解在目标问题上的表现如何。</p><blockquote><p>这里的默认设置是函数的值越小代表在相关问题上表现得越好，根据具体问题得情形可以进行修改</p></blockquote><p>$T_0$ 表示退火系统的初始温度，$T_i$ 表示迭代 $i$ 次以后系统的温度，$T_{i+1}$ 则表示迭代 $i+1$ 次以后系统的温度，在退火算法的设定中，系统温度会随着迭代次数的递增而下降，比如指数式下降：$T_{i+1} = kT_i$，其中 $k$ 取值一般在 $0.8$ 到 $0.99$ 之间</p><blockquote><p>还有更加复杂的温度调整方式，比如自适应温度调节，根据当前解的情况调节退火速率。它们核心思想与原理大同小异，不再赘述。</p></blockquote><p>而上述流程图中的 $Metropolis$ 判别原则是退火算法的核心，和温度密切相关。当我们发现一组扰动后产生的新解 $S_{new}$ 并不比原始解 $S_{i}$ 更优时，$Metropolis$ 判别原则仍然为新解的保留了一线生机：</p><ul><li>当 $rand(0,1) \le e ^ {-\frac{f(S_{new}) - f(S_i)}{T}}$ 时，接受解 $S_{new}$，将它作为新解</li><li>当 $rand(0,1) &gt; e ^ {-\frac{f(S_{new}) - f(S_i)}{T}}$ 时，不接受解 $S_{new}$</li></ul><p>可以将<strong>整个判别解是否接受的流程</strong>统一成一个概率表达式：</p><script type="math/tex; mode=display">P_{accept} = \left\{    \begin{aligned}        &1,\;\;\;if\; f(S_{new}) \le f(S_i)\\        &e ^ {-\frac{f(S_{new}) - f(S_i)}{T}},\;\;\; else    \end{aligned}\right.</script><p>显然，随着温度 $T$ 的降低，新解被接受的概率随之下降。在算法初期，系统总是比较愿意接纳新解，会接纳几乎所有新解，随着温度降低，这一态度逐渐变得冷漠。</p><hr><h1 id="（叁）模拟退火代码构建"><a href="#（叁）模拟退火代码构建" class="headerlink" title="（叁）模拟退火代码构建"></a>（叁）模拟退火代码构建</h1><h2 id="参数与输出说明"><a href="#参数与输出说明" class="headerlink" title="参数与输出说明"></a>参数与输出说明</h2><p>模拟退火算法利用 <code>scikit-opt</code> 库构建代码的流程和此前遗传算法代码构建流程基本一致，如果还不了解遗传算法代码构建流程，可以参照这篇<a href="https://www.lixinbook.cn/2023/02/03/c%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/">笔记</a></p><p>退火算法构造器的入参如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sa = SA(func=problem, x0=[<span class="number">100</span>, <span class="number">100</span>], T_max=<span class="number">100</span>, T_min=<span class="number">1e-7</span>,</span><br><span class="line">        L=<span class="number">800</span>, max_stay_counter=<span class="number">400</span>, lb=[-<span class="number">100</span>, -<span class="number">100</span>], ub=[<span class="number">300</span>, <span class="number">300</span>])</span><br></pre></td></tr></table></figure><ul><li><code>func</code> 就是目标优化函数，要求带有一个参数作为“参数转载器”</li><li><code>x0</code> 就是初始系统解状态 $S_0$，它的维度就是解空间的维度，也是 <code>func</code> 转载的参数个数</li><li><code>T_max</code> 最大温度，T_min 最小温度</li><li><code>L</code> 链长，就是迭代的次数，默认为 300</li><li><code>max_stay_counter</code> 冷却耗时，就是温度 $T$ 下降过程持续的迭代次数，默认为 150</li><li><code>lb</code> 和 <code>ub</code> 分别代表下界和上界</li></ul><p>输出值为 <code>best_x</code> 和 <code>best_y</code>，同样，可以调用 <code>best_y_history</code> 来查看历史记录</p><h2 id="代码实现与结果演示"><a href="#代码实现与结果演示" class="headerlink" title="代码实现与结果演示"></a>代码实现与结果演示</h2><p>以下是完整调用退火模拟算法并可视化结果的一个实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.SA <span class="keyword">import</span> SA</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义问题函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">problem</span>(<span class="params">parameter</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    This function has plenty of local minimum, with strong shocks</span></span><br><span class="line"><span class="string">    global minimum at (0,0) with value 0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x1, x2 = parameter</span><br><span class="line">    x = np.square(x1) + np.square(x2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> + (np.square(np.sin(x)) - <span class="number">0.5</span>) / np.square(<span class="number">1</span> + <span class="number">0.001</span> * x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模拟退火算法实例</span></span><br><span class="line">sa = SA(func=problem, x0=[<span class="number">100</span>, <span class="number">100</span>], T_max=<span class="number">10000</span>, T_min=<span class="number">1e-7</span>,</span><br><span class="line">        L=<span class="number">1000</span>, max_stay_counter=<span class="number">600</span>, lb=[-<span class="number">100</span>, -<span class="number">100</span>], ub=[<span class="number">300</span>, <span class="number">300</span>])</span><br><span class="line">best_x, best_y = sa.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best_x: &#x27;</span>, best_x, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;best_y: &#x27;</span>, best_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">Y_history = pd.DataFrame(sa.best_y_history)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(Y_history.index, Y_history.values, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">Y_history.<span class="built_in">min</span>(axis=<span class="number">1</span>).cummin().plot(kind=<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><center><img src = https://s2.loli.net/2023/02/07/5uDSkesLIcQFl3U.png width = 50%></center><p>其中纵坐标代表函数的值，横坐标代表迭代的次数。</p><h2 id="退火模拟策略选择"><a href="#退火模拟策略选择" class="headerlink" title="退火模拟策略选择"></a>退火模拟策略选择</h2><p><code>scikit-opt</code> 提供了其它三种不同形式的模拟退火算法：具体可见<a href="https://scikit-opt.github.io/scikit-opt/#/zh/more_sa?id=_3-types-of-simulated-annealing">官方文档</a></p><p>使用方法就是分别导入 <code>SAFAST</code>、<code>SABoltzmann</code> 或 <code>SACauchy</code>，然后用它们实例化类，以实现不同的模拟退火策略。</p><hr><h1 id="（肆）基于模拟退火改进的进化算法：退火进化法"><a href="#（肆）基于模拟退火改进的进化算法：退火进化法" class="headerlink" title="（肆）基于模拟退火改进的进化算法：退火进化法"></a>（肆）基于模拟退火改进的进化算法：退火进化法</h1><h2 id="改进思路"><a href="#改进思路" class="headerlink" title="改进思路"></a>改进思路</h2><p>此处主要讨论差分进化算法借助模拟退火思路的改进策略，如果还不了解差分进化算法，可以参照这篇<a href="https://www.lixinbook.cn/2023/02/06/c%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/">笔记</a>。</p><p>差分进化算法的选择算子定义如下：</p><p>设 $f(X)$ 是自适应度函数，其中参数 $X$ 表示一个个体，$f$ 通过定量衡量个体 $X$ 各属性的值来确定一个个体<strong>在解空间中的“竞争力”</strong></p><p>假设 $V_i(g)$ 是通过上述第 $g$ 代种群通过交叉操作得到的第 $i$ 个个体，它的第 $j$ 维属性就是上述的 $v_{i,j}(g)$，不同于交叉操作保留一定的概率因素，<strong>选择操作执行完全确定性竞争的机制</strong>，并在严酷的优胜劣汰后得到新一代种群：</p><script type="math/tex; mode=display">X_{i}(g + 1) = \left\{    \begin{aligned}        V_{i}(g),\;\;\;&if\; f(V_i(g)) < f(X_i(g))\\        X_{i}(g),\;\;\;&else    \end{aligned}\right.</script><p>差分进化算法采用这种绝对的优胜劣汰制，实际上可以用退火模拟算法优化：</p><p>同样设置初始温度，温度衰减机制，以及受温度影响的解接受概率式，这很容易实现，只要添加一个规则：</p><p>即使出现 $f(V_i(g)) \ge f(X_i(g))$，我们也依然采用 $Metropolis$ 判别原则为较弱势的个体保留一线生机，期待它的存在能引入更加理想的全局最优解。整体流程被改进如下</p><center><img src = https://s2.loli.net/2023/02/07/QW1LX2u6p4wPqMT.png></center><p>改进后的算法被称为退火进化算法（annealing evolution algorithm, AEA）</p><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><p>退火进化算法综合了 $SA$ 和 $GA$ 算法，优势互补</p><p>发挥 $SA$ 局部搜索能力和 $GA$ 全局搜索能力，克服 $SA$ 全局搜索能力差及效率不高的问题和 $GA$ 局部搜索能力差及其早熟现象。</p><p>$AEA$ 把 $SA$ 算法与 $GA$ 结合在一起，通过变异与选择不断改善解群体，并行搜索解空间，从而有可能更迅速地找到全局最优解。由于在选择中采用 $Metropolis$ 准则，因而保留了 $SA$ 算法易跳出某局部极值“陷阱”的优点，易于向全局极小值快速收敛。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>此处通过覆写 <code>scikit-opt</code> 库中的 <code>DE</code> 差分进化算法实现了 <code>AEA</code> （退火进化算法）</p><p>具体实现方法是引入类字段 <code>T</code> 和 <code>rate</code> ，覆写 <code>run</code> 函数，并在新的 <code>run</code> 函数中的每一次迭代对 <code>T</code> 值作一次衰减，然后覆写 <code>selection</code> 函数，在选择时额外导入 $Metropolis$ 原则进行判别</p><p>整体实现和测试代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.DE <span class="keyword">import</span> DE</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">problem</span>(<span class="params">parameter</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    This function has plenty of local minimum, with strong shocks</span></span><br><span class="line"><span class="string">    global minimum at (0,0) with value 0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x1, x2 = parameter</span><br><span class="line">    <span class="comment"># print(&quot;x1 is &quot;, x1, &quot;and x2 is &quot;, x2, &#x27;\n&#x27;)</span></span><br><span class="line">    x = np.square(x1) + np.square(x2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> + (np.square(np.sin(x)) - <span class="number">0.5</span>) / np.square(<span class="number">1</span> + <span class="number">0.001</span> * x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AEA</span>(<span class="title class_ inherited__">DE</span>):</span><br><span class="line">    T = <span class="number">1000</span></span><br><span class="line">    rate = <span class="number">0.93</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selection</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        rewrite selection function</span></span><br><span class="line"><span class="string">        add Metropolis rule to </span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        X = self.X.copy()</span><br><span class="line">        f_X = self.x2y().copy()</span><br><span class="line">        self.X = U = self.U</span><br><span class="line">        f_U = self.x2y()</span><br><span class="line"></span><br><span class="line">        metro_var = np.exp(-(f_U - f_X) / self.T)  <span class="comment"># 判别值</span></span><br><span class="line">        metro_condition = (metro_var &lt; np.random.random(metro_var.size)).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        self.X = np.where(np.logical_and((f_X &lt; f_U).reshape(-<span class="number">1</span>, <span class="number">1</span>), metro_condition), X, U)</span><br><span class="line">        <span class="keyword">return</span> self.X</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, max_iter=<span class="literal">None</span></span>):</span><br><span class="line">        self.max_iter = max_iter <span class="keyword">or</span> self.max_iter</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.max_iter):</span><br><span class="line">            self.mutation()</span><br><span class="line">            self.crossover()</span><br><span class="line">            self.selection()</span><br><span class="line">            self.T = self.T * self.rate</span><br><span class="line">            <span class="comment"># record the best ones</span></span><br><span class="line">            generation_best_index = self.Y.argmin()</span><br><span class="line">            self.generation_best_X.append(self.X[generation_best_index, :].copy())</span><br><span class="line">            self.generation_best_Y.append(self.Y[generation_best_index])</span><br><span class="line">            self.all_history_Y.append(self.Y)</span><br><span class="line"></span><br><span class="line">        global_best_index = np.array(self.generation_best_Y).argmin()</span><br><span class="line">        self.best_x = self.generation_best_X[global_best_index]</span><br><span class="line">        self.best_y = self.func(np.array([self.best_x]))</span><br><span class="line">        <span class="keyword">return</span> self.best_x, self.best_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">de = AEA(func=problem, n_dim=<span class="number">2</span>, F=<span class="number">0.5</span>, size_pop=<span class="number">50</span>,</span><br><span class="line">         max_iter=<span class="number">800</span>, prob_mut=<span class="number">0.3</span>, lb=[-<span class="number">1</span>, -<span class="number">1</span>], ub=[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">best_x, best_y = de.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best_x: &#x27;</span>, best_x, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;best_y: &#x27;</span>, best_y)</span><br><span class="line"></span><br><span class="line">Y_history = pd.DataFrame(de.all_history_Y)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(Y_history.index, Y_history.values, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">Y_history.<span class="built_in">min</span>(axis=<span class="number">1</span>).cummin().plot(kind=<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分进化算法介绍及代码实现</title>
      <link href="/2023/02/06/c%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/"/>
      <url>/2023/02/06/c%E5%B7%AE%E5%88%86%E8%BF%9B%E5%8C%96%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）简介和概念"><a href="#（壹）简介和概念" class="headerlink" title="（壹）简介和概念"></a>（壹）简介和概念</h1><p>差分进化算法是一种基于群体差异的启发式随机搜索算法，启发式算法指的是：</p><p>启发式算法主要区别于传统优化算法，后者通过目标函数的梯度达到目标函数结果最优化，它是一种确定性的搜索方式。</p><p>而启发式算法的特点就在于随机搜索并且通过这一特性获取更高的全局最优可能性。由于和函数梯度的利用无关，所以启发式算法并不要求目标函数具有连续可微的条件，为一些无法通过梯度下降优化的目标函数提供了优化的可能性。</p><p>差分进化算法作为一种启发式算法，其源于更早提出的遗传算法（<code>GA</code>），如果还不了解遗传算法，可以参照<a href="https://www.lixinbook.cn/2022/09/03/c%E5%9F%BA%E6%9C%AC%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">上一篇文章</a></p><p>可以认为，<strong>差分进化算法实际上是遗传进化算法的一种变形，它采用实数编码的方式，更加简单而直接的变异和竞争机制，使得它在保留较强全局搜索能力的情况下同时具有高效的性能</strong></p><hr><h1 id="（贰）差分进化算法过程"><a href="#（贰）差分进化算法过程" class="headerlink" title="（贰）差分进化算法过程"></a>（贰）差分进化算法过程</h1><h2 id="种群初始化"><a href="#种群初始化" class="headerlink" title="种群初始化"></a>种群初始化</h2><p>第一步是在维度为 $n$ 的解空间中<strong>随机均匀</strong>地产生 $M$ 个个体，我们用 $X_i(0)$ 表示第 $0$ 代种群的第 $i$ 个个体，用 $x_{i,k}(0)$ 表示第 $0$ 代种群的第 $i$ 个个体的第 $k$ 个属性，初始种群中的第 $i$ 个个体就可以如下表示（$i = 1,2,3,\cdots, M$）：</p><script type="math/tex; mode=display">X_i(0) = (x_{i,1}(0), x_{i,2}(0), x_{i,3}(0), \cdots,x_{i,n}(0))</script><p>第 $i$ 个个体的第 $j$ 维通过以下方式随机取值</p><script type="math/tex; mode=display">x_{i,j}(0) = min(L_j) + rand(0,1) \times (max(L_j) - min(L_j))</script><p>其中 $min(L_j)$ 表示第 $j$ 维属性取值的最小值，$max(L_j)$ 同理</p><p>其中种群规模建议取值在维度 $n$ 的 $5$ 倍到 $10$ 倍之间</p><h2 id="变异操作"><a href="#变异操作" class="headerlink" title="变异操作"></a>变异操作</h2><p>在第 $g$ 次迭代中，我们总是从种群中随机选择 $3$ 个不同个体进行变异操作，假设这三个个体为 $X_1(g),X_2(g),X_3(g)$，假设产生的变异变量为 $H(g)$，由于差分进化算法采用实数编码，因此有如下向量等式成立：</p><script type="math/tex; mode=display">H(g) = X_1(g) + F\cdot (X_2(g) - X_3(g))</script><p>$F$ 表示缩放因子，一些时候取作 $[0.4,1]$ 之间的定值，通常为 $0.5$ 左右，过小的 $F$ 容易早熟，相反则容易陷入局部最优解中</p><blockquote><p>一些变异策略将上述式子变形为更复杂的形式（比如根据个体适应度来自适应调整 $F$），但本质一样，此处不赘述。</p></blockquote><h2 id="交叉操作"><a href="#交叉操作" class="headerlink" title="交叉操作"></a>交叉操作</h2><p>交叉操作可以看作是将变异以后的一段染色体和原始染色体进行互相配补：</p><p>设 $h_{i,j}(g)$ 是第 $g$ 代种群通过变异得到的第 $i$ 个个体的第 $j$ 个属性的取值，$x_{i,j}(g)$ 是第 $g$ 代原始种群中第 $i$ 个个体的第 $j$ 个属性的取值，有：</p><script type="math/tex; mode=display">v_{i,j}(g) = \left\{    \begin{aligned}        h_{i,j}(g),\;\;\;&if\; rand(0,1) \le cr\\        x_{i,j}(g),\;\;\;&else    \end{aligned}\right.</script><p>$v_{i,j}(g)$ 表示第 $g$ 代种群通过交叉操作得到的第 $i$ 个个体的第 $j$ 个属性的乘积</p><p>通俗上理解，就是变异后的染色体和原始染色体逐基因按照一定概率交配的过程。</p><p>另外，$cr$ 是 $[0,1]$ 之间的值，一般取作 $0.1$，过大会导致更多变异被引入，容易加速收敛。</p><blockquote><p>一些选择策略将上述式子变形为更复杂的形式（比如根据个体适应度来自适应调整 $cr$），但本质一样，此处不赘述。</p></blockquote><h2 id="选择操作"><a href="#选择操作" class="headerlink" title="选择操作"></a>选择操作</h2><p>设 $f(X)$ 是自适应度函数，其中参数 $X$ 表示一个个体，$f$ 通过定量衡量个体 $X$ 各属性的值来确定一个个体<strong>在解空间中的“竞争力”</strong></p><p>假设 $V_i(g)$ 是通过上述第 $g$ 代种群通过交叉操作得到的第 $i$ 个个体，它的第 $j$ 维属性就是上述的 $v_{i,j}(g)$，不同于交叉操作保留一定的概率因素，<strong>选择操作执行完全确定性竞争的机制</strong>，并在严酷的优胜劣汰后得到新一代种群：</p><script type="math/tex; mode=display">X_{i}(g + 1) = \left\{    \begin{aligned}        V_{i}(g),\;\;\;&if\; f(V_i(g)) < f(X_i(g))\\        X_{i}(g),\;\;\;&else    \end{aligned}\right.</script><blockquote><p>备注：这里认为适应度函数越小越好，可以根据算法实际进行转变，保持定义上的统一即可。</p></blockquote><h2 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h2><p>完整算法流程如下图所示：</p><center><img src = https://s2.loli.net/2023/02/07/6T1lovG7bPhIHVE.png></center><h2 id="综合评价"><a href="#综合评价" class="headerlink" title="综合评价"></a>综合评价</h2><p>差分算法的核心算子——变异操作，实际上是通过对个体的某个或某段基因进行随机变换，得到新的个体，也就是新的一组解。它的目的是通过生成新的解，来试图找到更优的选择。</p><p>可以发现，差分进化算法的选择操作的竞争双方是交叉后形成的新一代种群和父本种群，这样的设定有利于维护父本的优良基因，并且变异操作仍然保留了一部分随机搜索的能力，使得这个算法仍然保持了较高的全局搜索能力</p><hr><h1 id="（叁）差分进化算法代码构建"><a href="#（叁）差分进化算法代码构建" class="headerlink" title="（叁）差分进化算法代码构建"></a>（叁）差分进化算法代码构建</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>和遗传算法一样，此处仍然采用 <code>scikit-opt</code> 库来构建差分进化算法的代码，如果还不了解遗传算法代码构建流程，可以参照这篇<a href="https://www.lixinbook.cn/2023/02/03/c%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/">笔记</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.DE <span class="keyword">import</span> DE</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">problem</span>(<span class="params">parameter</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    This function has plenty of local minimum, with strong shocks</span></span><br><span class="line"><span class="string">    global minimum at (0,0) with value 0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x1, x2 = parameter</span><br><span class="line">    <span class="comment"># print(&quot;x1 is &quot;, x1, &quot;and x2 is &quot;, x2, &#x27;\n&#x27;)</span></span><br><span class="line">    x = np.square(x1) + np.square(x2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> + (np.square(np.sin(x)) - <span class="number">0.5</span>) / np.square(<span class="number">1</span> + <span class="number">0.001</span> * x)</span><br><span class="line"></span><br><span class="line">de = DE(func=problem, n_dim=<span class="number">2</span>, F=<span class="number">0.5</span>, size_pop=<span class="number">50</span>, </span><br><span class="line">        max_iter=<span class="number">800</span>, prob_mut=<span class="number">0.3</span>, lb=[-<span class="number">1</span>, -<span class="number">1</span>], ub=[<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">best_x, best_y = de.run()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best_x: &#x27;</span>, best_x, <span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;best_y: &#x27;</span>, best_y)</span><br></pre></td></tr></table></figure><p>入参中 <code>prob_mut</code> 表示交叉操作的单点基因变异概率，相当于上文中的 $cr$ 值，<code>F</code> 是变异操作中的变异系数，就是上文中的 $F$ 值。</p><p><code>best_x</code> 和 <code>best_y</code> 是差分进化算法的两个输出，它们是求出的最优解</p><p>代码构建方法和遗传算法基本一致，当然，此前遗传算法代码构建中的 scikit-opt 库特性此处也一律适用。</p><p>此外，差分进化算法也支持通过读取 <code>all_history_Y</code> 属性（数据类型是列表）来导出历史记录并绘图。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y_history = pd.DataFrame(de.all_history_Y)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(Y_history.index, Y_history.values, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">Y_history.<span class="built_in">min</span>(axis=<span class="number">1</span>).cummin().plot(kind=<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>运行上述示例如下，这个示例也在遗传算法的代码示例里跑过，感兴趣的同学可以去看看当时的运行结果。</p><center><img src = https://s2.loli.net/2023/02/07/E3WHuceMwY8JPK9.png width = 50%></center><p>可以看到差分进化算法的收敛速度确实更加迅速，并且得到和遗传算法一样的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法代码构建——基于 SCIKIT-OPT</title>
      <link href="/2023/02/03/c%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/"/>
      <url>/2023/02/03/c%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%81%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）相关库介绍"><a href="#（壹）相关库介绍" class="headerlink" title="（壹）相关库介绍"></a>（壹）相关库介绍</h1><p>建模竞赛中，一般不采用自行完整构建算法的方式实现遗传算法，这样会大大增大编程手的工作量，并且可能引入很难预测的 <code>bug</code> ，影响结果的准确性。</p><p>因此我们采用调取现成库的方式，使用 <code>python</code> 语言调取相关优化算法库。</p><p>一般用于遗传算法的库有 <code>scikit-opt</code> 库、<code>geatpy</code> 库，虽然它们已经实现了大部分的底层代码构建和计算性能优化的工作，但是仍然提供了一些接口供用户自定义优化的具体内容，如何在实现便利的同时保留使用的“灵活性”，是本节主要介绍的内容。</p><p>本节主要介绍的库是前者（<code>scikit-opt</code>），因为它还提供了其它优化算法的接口，花精力去熟悉这个库是比较“合算”的。</p><p><code>scikit-opt</code> 库的安装方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install scikit-opt</span><br></pre></td></tr></table></figure><hr><h1 id="（贰）代码构建流程"><a href="#（贰）代码构建流程" class="headerlink" title="（贰）代码构建流程"></a>（贰）代码构建流程</h1><h2 id="引入依赖库"><a href="#引入依赖库" class="headerlink" title="引入依赖库"></a>引入依赖库</h2><p>一般情况下需要引入的库文件如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sko.GA <span class="keyword">import</span> GA</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure><p><code>GA</code> 就是遗传算法构建的核心函数，我们的代码实现都将围绕这个函数展开</p><h2 id="定义问题函数"><a href="#定义问题函数" class="headerlink" title="定义问题函数"></a>定义问题函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">problem</span>(<span class="params">parameter</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    This function has plenty of local minimum, with strong shocks</span></span><br><span class="line"><span class="string">    global minimum at (0,0) with value 0</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    x1, x2 = parameter</span><br><span class="line">    x = np.square(x1) + np.square(x2)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.5</span> + (np.square(np.sin(x)) - <span class="number">0.5</span>) / np.square(<span class="number">1</span> + <span class="number">0.001</span> * x)</span><br></pre></td></tr></table></figure><p>其中 <code>parameter</code> 是参数转载器，<code>x1, x2 = parameter</code> 能将创建后的参数传递给 <code>x1</code> 和 <code>x2</code> 两个变量，稍后你将会看到，参数转载器中转载的参数个数完全是由我们自由决定的。而 <code>return</code> 的内容就是我们希望优化的目标（取最小）</p><p>上述代码用于求解某个函数的最值，实际运用中，我们往往需要定义更加复杂的逻辑来实现建模竞赛中的问题，因此 <code>problem</code> 函数的内容也可以相应地进行扩展，可以包括子函数，并且只要在求解器初始化时声明参数的个数和各个参数的范围，然后用一个赋值语句从 <code>problem</code> 函数中</p><h2 id="求解器初始化与运行"><a href="#求解器初始化与运行" class="headerlink" title="求解器初始化与运行"></a>求解器初始化与运行</h2><p>求解器初始化的核心代码如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ga = GA(func=schaffer, n_dim=<span class="number">3</span>, size_pop=<span class="number">50</span>, max_iter=<span class="number">800</span>,</span><br><span class="line">        prob_mut=<span class="number">0.001</span>, lb=[-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>], ub=[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], precision=<span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure><p>其中各个参数的涵义如下：</p><ul><li><code>func</code> ：目标函数，要优化的对象，<code>GA</code> 类的初始化函数对 <code>func</code> 的参数格式要求是“必须有一个参数”，用于作为参数转载器。具体地讲，可以观察我们定义的问题函数的第一句代码：<code>x1, x2 = parameter</code></li></ul><blockquote><p>可以理解为我们为目标问题 <code>problem</code> 申请了若干个变量作为 <code>GA</code> 函数的目标优化变量，变量的个数可以在初始化函数中 <code>n_dim</code> 参数中指定。值得一提的是，我们应该尽量减少变量的个数，换言之，所有申请的变量都应该是无关的，以减少遗传算法的时间开销。必要时，还可以通过数据降维的方式来节约变量。</p></blockquote><ul><li><code>n_dim</code> ：变量维度，表示要申请的变量个数</li><li><code>size_pop</code> ：种群规模</li><li><code>max_iter</code> ：最大迭代次数</li><li><code>prob_mut</code> ：变异概率</li><li><code>lb</code> ：一个列表，指定每个变量的最小值</li><li><code>ub</code> ：一个列表，指定每个向量的最大值</li><li><code>constraint_eq</code> ：等式约束，可以不指定</li><li><code>constraint_ueq</code> ：不等式约束，可以不指定</li><li><code>precision</code> ：精准度，<code>int</code>/<code>float</code> 值（统一指定所有变量的精度）或它们组成的列表（分别指定所有变量的精度）</li></ul><h2 id="遗传算法实用调参技巧"><a href="#遗传算法实用调参技巧" class="headerlink" title="遗传算法实用调参技巧"></a>遗传算法实用调参技巧</h2><p><code>scikit-opt</code> 库提供的遗传算法的超参数一共有四个：种群规模、最大迭代次数、变异概率和精准度。</p><p>最大迭代次数和精准度都是“多多益善”，在时间开销允许的情况下，可以增加迭代次数，让种群尽量更加成熟，减少精度也是同样的原理。</p><p>种群规模的设置应该以合适为宜，群体规模太小，很明显会出现近亲交配，产生病态基因。而且造成有效等位基因先天缺失，即使采用较大概率的变异算子，生成具有竞争力高阶模式的可能性仍然核销，况且大概率变异算子对已有模式的破坏作用极大。同时，遗传算子存在随机误差（模式采样误差），妨碍小群体中有效模式的正确传播，使得种群进化不能按照模式定理产生所预期的期望数量。而若群体规模太大，结果难以收敛且浪费资源，稳健性下降。</p><p>变异操作的本质是为了避免由于选择和交叉算子而引起的某些信息永久性丢失，保证了遗传算法作为启发式算法的有效性，即增强它的局部搜索能力，同时使得遗传算法能够保持群体的多样性，防止出现未成熟收敛。但变异概率取值过大将会导致遗传算法退化为随机搜索，结果极难收敛。</p><h2 id="可视化优化过程"><a href="#可视化优化过程" class="headerlink" title="可视化优化过程"></a>可视化优化过程</h2><p>上述代码中，如下语句用于完成优化过程的图像展示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Y_history = pd.DataFrame(ga.all_history_Y)</span><br><span class="line">fig, ax = plt.subplots(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">ax[<span class="number">0</span>].plot(Y_history.index, Y_history.values, <span class="string">&#x27;.&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">Y_history.<span class="built_in">min</span>(axis=<span class="number">1</span>).cummin().plot(kind=<span class="string">&#x27;line&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>此处调用了 <code>matplotlib</code> 库进行可视化，结果如下图所示：</p><center><img src = https://s2.loli.net/2023/02/06/45q9LPKRATMvsxj.png width =  50%></center><p>当然也可以选择其它诸如 <code>seaborn</code> 这样的库进行美化，<code>seaborn</code> 库的使用技巧预计将在另一篇笔记中介绍。</p><p>其中关键在于利用 <code>Y_history = pd.DataFrame(ga.all_history_Y)</code> 语句来调取优化过程中记录的历史信息表格，然后以 <code>Y_history.index</code> 和 <code>Y_history.values</code> （数据类型是列表）分别作为横纵坐标绘图。</p><hr><h1 id="（叁）scikit-opt-库特性"><a href="#（叁）scikit-opt-库特性" class="headerlink" title="（叁）scikit-opt 库特性"></a>（叁）<code>scikit-opt</code> 库特性</h1><h2 id="可重定义算子"><a href="#可重定义算子" class="headerlink" title="可重定义算子"></a>可重定义算子</h2><p>可重定义算子的有两种实现方式：<strong>注册函数</strong>和<strong>继承覆写</strong></p><h3 id="继承覆写"><a href="#继承覆写" class="headerlink" title="继承覆写"></a>继承覆写</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyGA</span>(<span class="title class_ inherited__">GA</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">selection</span>(<span class="params">self, tourn_size=<span class="number">3</span></span>):</span><br><span class="line">        FitV = self.FitV</span><br><span class="line">        sel_index = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size_pop):</span><br><span class="line">            aspirants_index = np.random.choice(<span class="built_in">range</span>(self.size_pop), size=tourn_size)</span><br><span class="line">            sel_index.append(<span class="built_in">max</span>(aspirants_index, key=<span class="keyword">lambda</span> i: FitV[i]))</span><br><span class="line">        self.Chrom = self.Chrom[sel_index, :]  <span class="comment"># next generation</span></span><br><span class="line">        <span class="keyword">return</span> self.Chrom</span><br><span class="line"></span><br><span class="line">    ranking = ranking.ranking</span><br></pre></td></tr></table></figure><p>上述代码通过继承 <code>GA</code> 类实现了对 <code>selection</code> 选择算子的覆写，而最终构建对象时应该以继承后的 <code>MyGA</code> 类进行构建。如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_ga = MyGA(func=demo_func, n_dim=<span class="number">3</span>, size_pop=<span class="number">100</span>, max_iter=<span class="number">500</span>, </span><br><span class="line">             lb=[-<span class="number">1</span>, -<span class="number">10</span>, -<span class="number">5</span>], ub=[<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>], precision=[<span class="number">1e-7</span>, <span class="number">1e-7</span>, <span class="number">1</span>])</span><br></pre></td></tr></table></figure><h3 id="算子注册"><a href="#算子注册" class="headerlink" title="算子注册"></a>算子注册</h3><p>除了直接通过继承覆写原有操作算子函数以外，还可以通过“注册”（register）的方式的方式实现 <code>selection</code> 函数的覆写，比如以下四句代码分别对 <code>selection</code>、<code>ranking</code>、<code>crossover</code> 、<code>mutation</code> 四个算子进行了重写 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ga.register(operator_name=<span class="string">&#x27;selection&#x27;</span>, operator=selection_tournament, tourn_size = <span class="number">3</span>)  <span class="comment"># 规模为 3 的锦标赛法</span></span><br><span class="line">ga.register(operator_name=<span class="string">&#x27;ranking&#x27;</span>, operator=ranking.ranking)</span><br><span class="line">ga.register(operator_name=<span class="string">&#x27;crossover&#x27;</span>, operator=ranking.crossover_2point)</span><br><span class="line">ga.register(operator_name=<span class="string">&#x27;mutation&#x27;</span>, operator=ranking.mutation)</span><br></pre></td></tr></table></figure><p>在库文件的文件地址 <code>scikit-opt/sko/operators/</code> 中还有四个文件：<code>selection.py</code>、<code>ranking.py</code>、<code>crossover.py</code> 、<code>mutation.py</code>，这四个文件中定义了十多个算子以供使用和更替，我们总是可以利用注册机制将原始算子更替成满足我们需求的算子，但是注意应该先加上如下一行调库代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sko.operators <span class="keyword">import</span> ranking, selection, crossover, mutation</span><br></pre></td></tr></table></figure><h2 id="断点继续运行"><a href="#断点继续运行" class="headerlink" title="断点继续运行"></a>断点继续运行</h2><p><code>scikit-opt</code> 库还支持迭代一定代数后中断，然后继续运行，这是一个很有用的特性，能帮助我们分析不同代数的迭代效果。</p><p>这得益于 <code>run</code> 函数的重载，指定参数时它将迭代指定代数后停下。</p><p>例如假设 <code>ga</code> 是一个已经实例化的 <code>GA</code> 类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ga.run(<span class="number">100</span>) <span class="comment"># run 100 generations first</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">some codes to analyze the current result (after run 100 generations) </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">ga.run(<span class="number">200</span>) <span class="comment"># then run 200 generations</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第十节：矩估计法和极大似然估计法</title>
      <link href="/2022/11/02/cu%E6%A6%82%E7%BB%9F10/"/>
      <url>/2022/11/02/cu%E6%A6%82%E7%BB%9F10/</url>
      
        <content type="html"><![CDATA[<h1 id="点估计——矩估计法"><a href="#点估计——矩估计法" class="headerlink" title="点估计——矩估计法"></a>点估计——矩估计法</h1><h2 id="点估计问题概述"><a href="#点估计问题概述" class="headerlink" title="点估计问题概述"></a>点估计问题概述</h2><p>点估计是指，我们已经确定了某个总体的分布函数形式，但是不确定这个分布函数形式中的某些参数 $\theta_1,\theta_2,\cdots,\theta_m$ 的具体数值。</p><p>此时，我们从总体 $X$ 抽取 $n$ 个样本，分别记为 $X_1,X_2,\cdots,X_n$</p><p>点估计的目标是，根据这 $n$ 个样本的取值 $x_1,x_2,\cdots,x_n$ 来估计 $\theta_1,\theta_2,\cdots,\theta_m$ 的值</p><h2 id="步骤-1-：求出各阶原点矩理论期望"><a href="#步骤-1-：求出各阶原点矩理论期望" class="headerlink" title="步骤 1 ：求出各阶原点矩理论期望"></a>步骤 1 ：求出各阶原点矩理论期望</h2><p>第一步是求解 $k$ 阶原点矩的数学期望（$k= 1,2,\cdots,m$），其中原点矩的个数 $m$ 取决于参数 $\theta_1,\theta_2,\cdots,\theta_m$ 的个数。这是因为求解 $m$ 个变量至少需要 $m$ 个方程</p><blockquote><p>稍后你将会看到，这些 $k$ 阶原点矩的数学期望将组成关于参数值的方程组</p></blockquote><p>对于离散型，假设 $\mu_k$ 是 $k$ 阶原点矩的数学期望，则有：</p><script type="math/tex; mode=display">\mu_k = \sum_{i} p_ix_i^k</script><p>其中，$p_i$ 是含有未知参数 $\theta_1,\theta_2,\cdots,\theta_m$ 的概率值</p><p>对于连续性，假设 $\mu_k$ 是 $k$ 阶原点矩的数学期望，则有：</p><script type="math/tex; mode=display">\mu_k = \int_{-\infty}^\infty x^k f(x)dx</script><p>其中 $f(x)$ 是含有未知参数 $\theta_1,\theta_2,\cdots,\theta_m$ 的概率密度函数</p><p>可以看出，不论是离散型还是连续型，$\mu_k$ 都是可以看作含有未知值 $\theta_1,\theta_2,\cdots,\theta_m$ 的函数</p><blockquote><p>尽管 $\theta_1,\theta_2,\cdots,\theta_m$ 实际上在分布模型中是定值，但是由于它们是未知的，并且是我们的估计对象，因此我们将它们视为变量。</p></blockquote><p>因此，我们将 $\mu_k$ 记作：</p><script type="math/tex; mode=display">\mu_k(\theta_1,\theta_2,\cdots,\theta_m)</script><h2 id="步骤-2-：求出样本各阶原点矩均值"><a href="#步骤-2-：求出样本各阶原点矩均值" class="headerlink" title="步骤 2 ：求出样本各阶原点矩均值"></a>步骤 2 ：求出样本各阶原点矩均值</h2><p>根据已有的样本 $A_1,A_2,\cdots,A_n$ ，我们可以求出样本的均值：</p><script type="math/tex; mode=display">A_k = \sum_{i = 1}^n X_i^k</script><p>稍后会看到样本各阶原点矩均值也将作为方程等式的一部分</p><h2 id="步骤-3-：列出方程"><a href="#步骤-3-：列出方程" class="headerlink" title="步骤 3 ：列出方程"></a>步骤 3 ：列出方程</h2><p>列出方程等式的核心就是：$\mu_k = A_k$，就是我们直接使用样本均值来估计数学期望，可以列出如下方程：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\mu_1(\theta_1,\theta_2,\cdots,\theta_m) = A_1 = \sum_{i = 1}^n X_i \\\mu_2(\theta_1,\theta_2,\cdots,\theta_m) = A_2 = \sum_{i = 1}^n X_i^2 \\\mu_3(\theta_1,\theta_2,\cdots,\theta_m) = A_3 = \sum_{i = 1}^n X_i^3 \\\cdots\\\mu_m(\theta_1,\theta_2,\cdots,\theta_m) = A_m = \sum_{i = 1}^n X_i^m \\\end{matrix}\right.</script><p>根据上述 $m$ 个方程就能解出 $m$ 个未知值 $\theta_1,\theta_2,\cdots,\theta_m$，求解出的实际上是它们的估计值，记为：</p><script type="math/tex; mode=display">\hat{\theta_1},\hat{\theta_2},\cdots,\hat{\theta_m}</script><h1 id="点估计——最大似然估计法"><a href="#点估计——最大似然估计法" class="headerlink" title="点估计——最大似然估计法"></a>点估计——最大似然估计法</h1><p>假设我们拥有服从总体分布 $F(x)$ 的一组样本 $X_1,X_2,\cdots,X_n$，它们的观测值为 $x_1,x_2,\cdots,x_n$，并且这些样本之间相互独立。</p><p>最大似然估计法的核心思想在于我们可以根据乘法定理计算出情形 $x_1,x_2,\cdots,x_n$ 的出现概率 $p(x_1,x_2,\cdots,x_n)$，由于我们并不确定总体分布中的参数 $\theta_1,\theta_2,\cdots,\theta_m$ 的具体取值，因此概率 $p$ 还是关于 $\theta_1,\theta_2,\cdots,\theta_m$ 的函数，记作 $p(\mathbf{x};\theta_1,\theta_2,\cdots,\theta_m)$，我们希望求出一组 $\mathbf{\theta}$，使之让观测值出现的概率最大</p><h2 id="步骤-1-：列出单样本出现概率"><a href="#步骤-1-：列出单样本出现概率" class="headerlink" title="步骤 1 ：列出单样本出现概率"></a>步骤 1 ：列出单样本出现概率</h2><p>对于单个样本 $X_k$，它取值为 $x_k$ 概率是容易列出的：</p><script type="math/tex; mode=display">P\{X_k = x_k\} = p(x_k;\theta_1,\theta_2,\cdots,\theta_m)</script><h2 id="步骤-2-：整合成整体概率"><a href="#步骤-2-：整合成整体概率" class="headerlink" title="步骤 2 ：整合成整体概率"></a>步骤 2 ：整合成整体概率</h2><p>由于各个样本之间相互独立，因此整体概率可以视为各样本概率的简单乘积：</p><script type="math/tex; mode=display">P(x_1,x_2,\cdots,x_n;\theta_1,\theta_2,\cdots,\theta_m) = \prod_{k=1}^n P\{X_k = x_k\} = \prod_{k=1}^n p(x_k;\theta_1,\theta_2,\cdots,\theta_m)</script><p>上述公式中，$x_1,x_2,\cdots,x_n$ 就是我们获取的样本的取值，是已知值，实际求解时未知值只有 $\theta_1,\theta_2,\cdots,\theta_m$，因此我们定义最大似然函数如下：</p><script type="math/tex; mode=display">L(\theta_1,\theta_2,\cdots,\theta_m) = \prod_{k=1}^n p(x_k;\theta_1,\theta_2,\cdots,\theta_m)</script><p>连乘的形式并不被大多数人熟悉，我们可以对极大似然函数取对数，得到：</p><script type="math/tex; mode=display">ln[L(\theta_1,\theta_2,\cdots,\theta_m)] = \sum_{k=1}^nln[p(x_k;\theta_1,\theta_2,\cdots,\theta_m)]</script><h2 id="步骤-3-：求解使整体概率最大的参数"><a href="#步骤-3-：求解使整体概率最大的参数" class="headerlink" title="步骤 3 ：求解使整体概率最大的参数"></a>步骤 3 ：求解使整体概率最大的参数</h2><p>事实上，我们要求解的估计值 $\hat{\theta_1},\hat{\theta_2},\cdots,\hat{\theta_m}$ 就是使得似然估计函数最大的一组参数值，即：</p><script type="math/tex; mode=display">\hat{\theta_1},\hat{\theta_2},\cdots,\hat{\theta_m} = arg\ max\{ln[L(\theta_1,\theta_2,\cdots,\theta_m)]\}</script><p>求解方法就是求偏导数，令偏导数为 $0$ 得到相应解：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\frac{\partial\{ln[L(\theta_1,\theta_2,\cdots,\theta_m)]\}}{\partial\theta_1} = 0 \\\frac{\partial\{ln[L(\theta_1,\theta_2,\cdots,\theta_m)]\}}{\partial\theta_2} = 0 \\\frac{\partial\{ln[L(\theta_1,\theta_2,\cdots,\theta_m)]\}}{\partial\theta_3} = 0 \\\cdots\\\frac{\partial\{ln[L(\theta_1,\theta_2,\cdots,\theta_m)]\}}{\partial\theta_m} = 0 \\\end{matrix}\right.</script><p>一般情况下，在没有指明应该使用哪种估计方法时，我们往往认为最大似然估计法优先使用于矩估计法。</p><h2 id="最大似然估计的性质"><a href="#最大似然估计的性质" class="headerlink" title="最大似然估计的性质"></a>最大似然估计的性质</h2><p>最大似然估计满足以下性质：</p><p>设 $\theta$ 的函数 $\boldsymbol{u}=\boldsymbol{u}(\theta), \theta \in \Theta$ 具有单值反函数 $\theta = \theta(u)$。又设 $\hat{\theta}$ 是 $X$ 的概率密度函数 $f(x ; \theta)$ ( $f$ 形式已知) 中的参数 $\theta$ 的最大似然估计, 则 $\hat{\boldsymbol{u}}=u(\hat{\theta})$ 是 $u(\theta)$ 的最大似然估计.</p><p>就是说如果当 $\theta$ 的函数 $u(\theta)$ 满足一定性质时，$u(\theta)$ 的最大似然估计可以由 $\theta$ 的最大似然估计直接得到。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第九节：随机样本与重要抽样分布</title>
      <link href="/2022/10/28/cu%E6%A6%82%E7%BB%9F9/"/>
      <url>/2022/10/28/cu%E6%A6%82%E7%BB%9F9/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）总体与样本"><a href="#（壹）总体与样本" class="headerlink" title="（壹）总体与样本"></a>（壹）总体与样本</h1><h2 id="总体与样本的概念"><a href="#总体与样本的概念" class="headerlink" title="总体与样本的概念"></a>总体与样本的概念</h2><p>总体在数理统计中被定义为试验的全部可能观测值，这个定义可能晦涩，简单理解就是统计对象的全体集合，比如统计我校的身高，全校学生的身高值可以认为是总体，相应地，某个学生的身高就是个体。</p><p>样本是从总体中抽取出来的子集，总体往往是数量巨大的有限总体或无限总体，因此通过遍历总体来度量总体的属性显得不太可能，因此往往从中抽取样本，通过研究<strong>样本的属性</strong>，以及<strong>样本属性和总体属性之间的关系</strong>，来间接地推断总体的属性。</p><p>这些属性，可以是我们经常使用的统计量，比如均值，方差，$k$ 阶原点矩，$k$ 阶中心距，当然也可以是其它属性。</p><h2 id="概念纠偏：样本均值，样本方差"><a href="#概念纠偏：样本均值，样本方差" class="headerlink" title="概念纠偏：样本均值，样本方差"></a>概念纠偏：样本均值，样本方差</h2><p>在此之前，我们曾经研究过数学期望和方差的概念，它们采用纯粹数学的方式定义，直接根据分布函数得出，期望记为 $E(X)$ 或 $\mu$，方差记为 $D(X)$ 或 $\sigma^2$</p><p>我们可以认为总体的均值就是数学期望 $E(X)$，总体的方差就是方差 $D(X)$，然而遗憾的是，就像上面所说，总体的均值和方差往往是无法直接估量的值。</p><p>假设样本中一个有 $n$ 个随机变量（每个个体都是一个随机变量），它们都服从总体的分布 $F(x)$，记为 $X_1,X_2,\cdots,X_n$，并且样本中的每个随机变量都是相互独立的。我们用它们的值的<strong>算术平均</strong>作为样本的均值，并记为 $\overline{X}$：</p><script type="math/tex; mode=display">\overline{X} = \frac{X_1 + X_2 + \cdots + X_n}{n}\tag{1}</script><p>同样，样本方差（记为 $S^2$）的定义如下：</p><script type="math/tex; mode=display">S^2 = \frac{(X_1 - \overline{X})^2 + (X_2 - \overline{X})+ \cdots + (X_n - \overline{X})^2}{n}\tag{2}</script><p>样本均值往往并不等同于总体均值，样本方差也往往并不等于总体方差：</p><script type="math/tex; mode=display">\overline{X} \ne \mu,\;\;\; S^2 \ne \sigma^2</script><h2 id="用样本估计总体：经验分布函数"><a href="#用样本估计总体：经验分布函数" class="headerlink" title="用样本估计总体：经验分布函数"></a>用样本估计总体：经验分布函数</h2><p>设 $X_1,X_2,\cdots,X_n$ 是总体分布函数 $F(x)$ 的一个样本，用 $S(x)$ 表示 $X_1,X_2,\cdots,X_n$ 中不大于 $x$ 的随机变量的个数，用 $S(x)$ 除以 $n$ 就能得到不大于 $x$ 的随机变量占总样本的比例，记作 $F_n(x)$：</p><script type="math/tex; mode=display">F_n(x) = \frac{S(x)}{n}\tag{3}</script><p>格里汶科定理表明，当 $n$ 足够大时，用 $F_n(x)$ 来估量实际的分布函数 $F(x)$ 是合理而有效的。下面是这个定理的数学表述：</p><p>对于任一实数 $x$, 当 $n \rightarrow \infty$ 时, $F_n(x)$ 以概率 $1$ 一致收敛于分布函数 $F(x)$, 即</p><script type="math/tex; mode=display">P\left\{\lim _{n \rightarrow \infty} \sup _{-\infty<x<+\infty}\left|F_n(x)-F(x)\right|=0\right\}=1 .</script><p>不必过于纠结定理的形式，只要理解它的上述涵义即可。</p><h1 id="（贰）三大常见分布"><a href="#（贰）三大常见分布" class="headerlink" title="（贰）三大常见分布"></a>（贰）三大常见分布</h1><h2 id="卡方分布"><a href="#卡方分布" class="headerlink" title="卡方分布"></a>卡方分布</h2><h3 id="卡方分布基本定义"><a href="#卡方分布基本定义" class="headerlink" title="卡方分布基本定义"></a>卡方分布基本定义</h3><p>设随机变量 $X_1,X_2,\cdots,X_n$ 是来自总体分布 $N(0,1)$ 的样本，则定义 $\chi^2 = X_1^2 + X_2^2 + X_3^2 + \cdots + X_n^2$，$\chi^2$ 服从自由度为 $n$ 的卡方分布，记为：</p><script type="math/tex; mode=display">\sum_{k = 1}^nX_k^2 = \chi^2 \sim \chi^2(n)\tag{4}</script><p>即若干正态随机变量的平方和服从卡方分布。</p><div class="note info flat"><p>此处并不列出卡方分布的概率密度，因为它只会徒增读者的困惑并造成视觉上的不适，下文中的学生分布和 $F$ 分布同理</p></div><h3 id="卡方分布性质"><a href="#卡方分布性质" class="headerlink" title="卡方分布性质"></a>卡方分布性质</h3><h4 id="数学期望和方差"><a href="#数学期望和方差" class="headerlink" title="数学期望和方差"></a>数学期望和方差</h4><p>卡方分布 $\chi^2(n)$ 的数学期望为自由度 $n$，方差为 $2n$</p><h4 id="可加性"><a href="#可加性" class="headerlink" title="可加性"></a>可加性</h4><p>卡方分布的加和还是卡方分布，并且新的卡方分布的自由度是原来卡方分布的自由度的加和，即 $\chi_1^2 \sim \chi^2(n_1),\chi_2^2 \sim \chi^2(n_2)$，则有：</p><script type="math/tex; mode=display">\chi_{12}^2 = \chi_1^2 + \chi_2^2 \sim \chi^2(n_1 + n_2)\tag{5}</script><h4 id="费舍尔定理"><a href="#费舍尔定理" class="headerlink" title="费舍尔定理"></a>费舍尔定理</h4><p>将卡方分布 $\chi^2(n)$ 的上 $\alpha$ 分位数记为 $\chi^2_\alpha(n)$（这是一个具体的数），费舍尔证明，卡方分布的上 $\alpha$ 分位数可以由标准正态分布的相应分位数和自身自由度估计：</p><script type="math/tex; mode=display">\chi^2_\alpha(n) = \frac{1}{2}(z_\alpha + \sqrt{2n-1})^2\tag{6}</script><p>利用这个公式可以在不知道卡方分布上 $\alpha$ 分位数的情况进行估算。</p><h2 id="学生分布"><a href="#学生分布" class="headerlink" title="学生分布"></a>学生分布</h2><h3 id="学生分布基本定义"><a href="#学生分布基本定义" class="headerlink" title="学生分布基本定义"></a>学生分布基本定义</h3><p>学生分布又称为 $t$ 分布，组成学生分布的两个随机变量分别来自标准正态分布和自由度为 $n$ 的卡方分布 $\chi^2(n)$：</p><p>设随机变量 $X\sim N(0,1),Y\sim \chi^2(n)$，并且 $X,Y$ 相互独立，则称随机变量 $\frac{X}{\sqrt{Y/n}}$ 服从自由度为 $n$ 的 $t$ 分布，即：</p><script type="math/tex; mode=display">\frac{X}{\sqrt{Y/n}} \sim t(n)\tag{7}</script><h3 id="学生分布性质"><a href="#学生分布性质" class="headerlink" title="学生分布性质"></a>学生分布性质</h3><h4 id="均值和方差"><a href="#均值和方差" class="headerlink" title="均值和方差"></a>均值和方差</h4><ul><li>$E(t) = 0$</li><li>$D(t) = \frac{n}{n-2}$</li></ul><h4 id="逼近正态分布"><a href="#逼近正态分布" class="headerlink" title="逼近正态分布"></a>逼近正态分布</h4><p>随着 $n$ 的增大，$t$ 分布将越来越趋近于标准正态分布 $\Phi(x) = N(0,1)$</p><p>这意味着当 $n$ 足够大时，我们可以近似地在 $t$ 分布中使用正态分布的属性。</p><h4 id="对称性"><a href="#对称性" class="headerlink" title="对称性"></a>对称性</h4><p>学生分布的概率密度函数图像是关于 $y$ 轴对称的，所以，将 $t$ 分布的上 $\alpha$ 分位数记为 $t_\alpha(n)$，会有：</p><script type="math/tex; mode=display">t_\alpha(n) = -t_{1-\alpha}(n)\tag{8}</script><h2 id="F-分布"><a href="#F-分布" class="headerlink" title="$F$ 分布"></a>$F$ 分布</h2><h3 id="F-分布定义"><a href="#F-分布定义" class="headerlink" title="$F$ 分布定义"></a>$F$ 分布定义</h3><p>$F$ 分布的定义由两个卡方分布和它们的自由度组成，设 $U\sim \chi^2(n_1), V\sim \chi^2(n_2)$，则我们对 $F$ 分布的定义如下：</p><script type="math/tex; mode=display">\frac{U/n_1}{V/n_2} \sim F(n_1,n_2)\tag{9}</script><p>称为自由度为 $n_1,n_2$ 的 $F$ 分布</p><h3 id="F-分布性质"><a href="#F-分布性质" class="headerlink" title="$F$ 分布性质"></a>$F$ 分布性质</h3><h4 id="倒数性质"><a href="#倒数性质" class="headerlink" title="倒数性质"></a>倒数性质</h4><p>根据对于 $F$ 分布的定义过程可以很显然地得到：</p><script type="math/tex; mode=display">F(n_2,n_1) = \frac{V/n_2}{U/n_1} = \frac{1}{F(n_1,n_2)} \tag{10}</script><h4 id="分位性质"><a href="#分位性质" class="headerlink" title="分位性质"></a>分位性质</h4><p>根据倒数性质，很容易也能推导出上 $\alpha$ 分位数满足的性质，设 $F_{\alpha}(n_1,n_2)$ 是 $F(n_1,n_2)$ 的上 $\alpha$ 分位数，则有：</p><script type="math/tex; mode=display">\alpha =   P\{X \le F_\alpha(n_1,n_2)\}</script><script type="math/tex; mode=display">1 - \alpha = P\{X \ge F_\alpha(n_1,n_2)\} = P\{\frac{1}{X} \le \frac{1}{F_\alpha(n_1,n_2)}\}</script><p>由于 $\frac{1}{X}\sim F(n_2,n_1)$，故有:</p><script type="math/tex; mode=display">F_{1-\alpha}(n_2,n_1) = F_\alpha(n_1,n_2)\tag{11}</script><h1 id="（叁）正态总体的样本均值和样本方差的分布"><a href="#（叁）正态总体的样本均值和样本方差的分布" class="headerlink" title="（叁）正态总体的样本均值和样本方差的分布"></a>（叁）正态总体的样本均值和样本方差的分布</h1><h2 id="定理-1：含-sigma-的样本均值的分布"><a href="#定理-1：含-sigma-的样本均值的分布" class="headerlink" title="定理 1：含 $\sigma$ 的样本均值的分布"></a>定理 1：含 $\sigma$ 的样本均值的分布</h2><p>设随机变量 $X_1,X_2,\cdots,X_n$ 服从正态分布，即 $X_k\sim N(\mu,\sigma^2)$，它们是正态总体的一个样本</p><p>设它们的均值为 $\overline{X} = (\sum_{k=1}^n X_k)/n$，则 $\overline{X}$ 也满足正态分布，相较 $X_k$，它的均值不变，但方差缩小为原来的 $n$ 分之一：$\overline{X} \sim N(\mu, \sigma^2/n)$</p><p>这一现象是可以直观理解的：</p><script type="math/tex; mode=display">E(\frac{1}{n}{\sum_{k=1}^n X_k}) = \frac{1}{n}\sum_{k=1}^n E(X_k) = \frac{1}{n}\cdot n\mu = \mu</script><script type="math/tex; mode=display">D(\frac{1}{n}{\sum_{k=1}^n X_k}) = \frac{1}{n^2}\sum_{k=1}^n D(X_k) = \frac{1}{n^2}\cdot n\sigma^2 = \frac{\sigma^2}{n}</script><p>将 $\overline{X}$ 进行标准化，可以得到以下式子：</p><script type="math/tex; mode=display">\frac{\overline{X} - \mu}{\sigma / \sqrt{n}}\sim N(0,1)\tag{12}</script><h2 id="定理-2：-S-2-和-sigma-2-的关系"><a href="#定理-2：-S-2-和-sigma-2-的关系" class="headerlink" title="定理 2：$S^2$ 和 $\sigma^2$ 的关系"></a>定理 2：$S^2$ 和 $\sigma^2$ 的关系</h2><p>设随机变量 $X_1,X_2,\cdots,X_n$ 服从正态分布，即 $X_k\sim N(\mu,\sigma^2)$，它们是正态总体的一个样本</p><p>设 $\overline{X},S^2$ 分别是样本均值和样本方差，则有：</p><script type="math/tex; mode=display">\frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)\tag{13}</script><blockquote><p>$\overline{X}$ 与 $S^2$ 相互独立。</p></blockquote><h2 id="定理-3：不含-sigma-的样本均值的分布"><a href="#定理-3：不含-sigma-的样本均值的分布" class="headerlink" title="定理 3：不含 $\sigma$ 的样本均值的分布"></a>定理 3：不含 $\sigma$ 的样本均值的分布</h2><p>设随机变量 $X_1,X_2,\cdots,X_n$ 服从正态分布，即 $X_k\sim N(\mu,\sigma^2)$，它们是正态总体的一个样本，</p><p>设它们的均值为 $\overline{X} = (\sum_{k=1}^n X_k)/n$，则 $\overline{X}$ 也满足正态分布，而此处，其满足的正态分布写作：</p><script type="math/tex; mode=display">\frac{\overline{X}-\mu}{S/\sqrt{n}} \sim t(n-1)\tag{14}</script><p>证明方法如下：</p><script type="math/tex; mode=display">\frac{(n-1)S^2}{\sigma^2}\sim \chi^2(n-1)</script><script type="math/tex; mode=display">\frac{\frac{\overline{X} - \mu}{\sigma / \sqrt{n}}}{\sqrt{\chi^2(n-1)/(n-1)}} = \frac{\frac{\overline{X} - \mu}{\sigma / \sqrt{n}}}{\sqrt{\frac{(n-1)S^2}{\sigma^2}/(n-1)}} = \frac{\overline{X} - \mu}{\sigma / \sqrt{n}} \sim t(n-1)</script><h2 id="定理-4：样本方差比值和总体方差比值的关系"><a href="#定理-4：样本方差比值和总体方差比值的关系" class="headerlink" title="定理 4：样本方差比值和总体方差比值的关系"></a>定理 4：样本方差比值和总体方差比值的关系</h2><p>设 $X_1,X_2,\cdots,X_{n_1}$ 和 $Y_1,Y_2,\cdots,Y_{n_2}$ 分别是两个正态总体 $N(\mu_1,\sigma_1^2),N(\mu_2,\sigma_2^2)$，且这两个样本相互独立，设 $\overline{X}$ 和 $\overline{Y}$ 分别为两个样本的均值，$S_1^2,S_2^2$ 分别是两个样本的方差，则有：</p><script type="math/tex; mode=display">\frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} = \frac{S_1^2 /S_2^2}{\sigma_1^2/\sigma_2^2} \sim F(n_1 - 1,n_2 - 1)\tag{15}</script><p>证明方法如下：</p><script type="math/tex; mode=display">\frac{(n_1-1)S_1^2}{\sigma_1^2} \sim \chi_1^2(n_1-1)</script><script type="math/tex; mode=display">\frac{(n_2-1)S_2^2}{\sigma_2^2} \sim \chi_2^2(n_2-1)</script><p>将上述两式进行相除，并且根据 $F$ 分布的定义有：</p><script type="math/tex; mode=display">\frac{\chi_1^2(n_1-1)/(n_1-1)}{\chi_2^2(n_2-1)/(n_2- 1)} = \frac{S_1^2/\sigma_1^2}{S_2^2/\sigma_2^2} \sim F(n_1 - 1, n_2 - 1)</script><h2 id="定理-5："><a href="#定理-5：" class="headerlink" title="定理 5："></a>定理 5：</h2><p>设 $X_1,X_2,\cdots,X_{n_1}$ 和 $Y_1,Y_2,\cdots,Y_{n_2}$ 是两个方差一致的正态总体 $N(\mu_1,\sigma^2),N(\mu_2,\sigma^2)$</p><p>可以写出两个样本的均值为 $\overline{X}$ 和 $\overline{Y}$，并且有：</p><script type="math/tex; mode=display">\overline{X} \sim N(\mu_1, \frac{\sigma^2}{n_1}),\;\;\;\overline{Y}\sim N(\mu_2, \frac{\sigma^2}{n_2})</script><p>根据正态分布的可加性，将它们相减得到一个新的正态分布：</p><script type="math/tex; mode=display">\overline{X} - \overline{Y} \sim N(\mu_1 - \mu_2, \frac{\sigma^2}{n_1} + \frac{\sigma^2}{n_2})</script><p>将正态随机变量 $\overline{X} - \overline{Y}$ 进行归一化，使之服从标准正态分布，记为 $U$：</p><script type="math/tex; mode=display">U = \frac{\overline{X} - \overline{Y} - (\mu_1 - \mu_2)}{\sigma\sqrt{\frac{1}{n_1} + \frac{1}{n_2}}}</script><p>另外，我们还有根据公式 $(13)$ 得到的结论：$\frac{(n-1)S^2}{\sigma^2} \sim \chi^2(n-1)$，因此有：</p><script type="math/tex; mode=display">\frac{(n_1 -1)S_1^2}{\sigma^2} \sim \chi^2(n_1 - 1),\;\;\;\frac{(n_2 -1)S_2^2}{\sigma^2} \sim \chi^2(n_2 - 1)</script><p>根据卡方分布的可加性，我们将这两个卡方分布相加得到新的卡方分布，记作 $V$：</p><script type="math/tex; mode=display">V = \frac{(n_1 - 1)S_1^2 + (n_2 - 1)S_2^2}{\sigma^2} \sim \chi^2(n_1 + n_2 - 2)</script><p>可知 $U$ 是一个正态分布，$V$ 是一个自由度为 $n_1 + n_2 -2$ 卡方分布，很容易想到将它们组成一个 $t$ 分布：</p><script type="math/tex; mode=display">\frac{U}{V/(n_1 + n_2 - 2)}\sim t(n_1 + n_2 - 2)\tag{16}</script><p>上述公式往往还表述为：当 $\sigma_1^2=\sigma_2^2=\sigma^2$ 时,</p><script type="math/tex; mode=display">\frac{(\bar{X}-\bar{Y})-\left(\mu_1-\mu_2\right)}{S_w \sqrt{\frac{1}{n_1}+\frac{1}{n_2}}} \sim t\left(n_1+n_2-2\right)\tag{17}</script><p>其中 $S_w^2=\frac{\left(n_1-1\right) S_1^2+\left(n_2-1\right) S_2^2}{n_1+n_2-2}, \quad S_w=\sqrt{S_w^2}$.</p><p>但是由于记忆难度太大，笔者总是会在使用时自行推算一遍。</p><div class="note info flat"><p>在区间估计和假设检验中将会看到，上述五个定理将发挥巨大的作用</p></div>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第八节：大数定律和中心极限定理</title>
      <link href="/2022/10/16/cu%E6%A6%82%E7%BB%9F8/"/>
      <url>/2022/10/16/cu%E6%A6%82%E7%BB%9F8/</url>
      
        <content type="html"><![CDATA[<h1 id="大数定律"><a href="#大数定律" class="headerlink" title="大数定律"></a>大数定律</h1><h2 id="大数定律概述"><a href="#大数定律概述" class="headerlink" title="大数定律概述"></a>大数定律概述</h2><p>大数定律是概率统计学中的核心定律，大数定律的成立意味着随着样本数量的叠加，样本的相关性质将逐渐逼近</p><h2 id="定理-1：切比雪夫定理的特殊情况"><a href="#定理-1：切比雪夫定理的特殊情况" class="headerlink" title="定理 1：切比雪夫定理的特殊情况"></a>定理 1：切比雪夫定理的特殊情况</h2><h3 id="定理内容理解与证明"><a href="#定理内容理解与证明" class="headerlink" title="定理内容理解与证明"></a>定理内容理解与证明</h3><h4 id="定理理解"><a href="#定理理解" class="headerlink" title="定理理解"></a>定理理解</h4><p>设随机变量 $X_1,X_2,\cdots,X_n,\cdots$ <strong>相互独立</strong>，并且具有<strong>相同的数学期望和方差</strong>：</p><script type="math/tex; mode=display">E(X_1)= E(X_2) = E(X_3) = \cdots = E(X_k) = \cdots = \mu</script><script type="math/tex; mode=display">D(X_1) = D(X_2) = D(X_3) = \cdots=  D(X_k) = \cdots = \sigma^2</script><p>作为<strong>前 $n$ 个随机变量的算术平均</strong> $\overline{X} = \frac{1}{n}\sum_{k=1}^n X_k$，则对于任何正数 $\epsilon$ 有：</p><script type="math/tex; mode=display">\lim\limits_{n\rightarrow \infty}\{|\overline{X}-\mu| <\epsilon\} = \lim\limits_{n\rightarrow \infty}P\Big\{\big|\frac{1}{n}\sum_{k=1}^nX_k - \mu\big| < \epsilon\Big\} = 1\tag{1}</script><p>对于这个定理的理解，可以将每个随机变量视为一个事件（尽管不太严谨），将 $X_k$ 视为第 $k$ 次做这个事件（可以不是同一个事件，但是要确保均值和方差一致），当事件的执行次数达到一个足够大的数量时，它们的算术平均结果将会接近于均值</p><p>另外，很重要的一点是要将 $\frac{1}{n}\sum_{k=1}^nX_k$ 和单个事件的数学期望 $E(X_k)$ 区分开，前者是 $n$ 个事件结果的算术平均，后者则是通过概率计算得到的，是基于分布律得到的定义。</p><p>对于定理 1 的另一种叙述是采用“依概率收敛”的术语：</p><p>设随机变量 $X_1,X_2,\cdots,X_n,\cdots$ 相互独立，且具有相同的数学期望和方差：</p><script type="math/tex; mode=display">E(X_1)= E(X_2) = E(X_3) = \cdots = E(X_k) = \cdots = \mu</script><script type="math/tex; mode=display">D(X_1) = D(X_2) = D(X_3) = \cdots=  D(X_k) = \cdots = \sigma^2</script><p>则认为序列 $\overline{X} = \frac{1}{n}\sum_{k=1}^n X_k$ 依概念收敛于 $\mu$，即有：</p><script type="math/tex; mode=display">\overline{X}\stackrel{P}{\longrightarrow} \mu\tag{2}</script><h4 id="定理证明"><a href="#定理证明" class="headerlink" title="定理证明"></a>定理证明</h4><p>这个定理的证明需要使用切比雪夫不等式，即：</p><script type="math/tex; mode=display">P\{|X-\mu|\ge \epsilon\}\le \frac{\sigma^2}{\epsilon^2}\tag{3}</script><p>证明方法如下：</p><div class="note info flat"><p>todo：待填</p></div><h3 id="推广性质"><a href="#推广性质" class="headerlink" title="推广性质"></a>推广性质</h3><p>设 $\overline{X_n} \stackrel{P}{\longrightarrow} a,\overline{Y_n} \stackrel{P}{\longrightarrow} b$，又设函数 $g(x,y)$ 在点 $(a,b)$ 连续，则：</p><script type="math/tex; mode=display">g(X_n,Y_n) \stackrel{P}{\longrightarrow} g(a,b)\tag{4}</script><p>证明方法如下：</p><h2 id="定理-2：伯努利大数定理"><a href="#定理-2：伯努利大数定理" class="headerlink" title="定理 2：伯努利大数定理"></a>定理 2：伯努利大数定理</h2><h3 id="定理内容理解与证明-1"><a href="#定理内容理解与证明-1" class="headerlink" title="定理内容理解与证明"></a>定理内容理解与证明</h3><p>设 $n_A$ 是 $n$ 次<strong>独立重复试验</strong>中事件 $A$ 发生的次数，$p$ 是事件 $A$ 在每次试验中发生的概率，则对于任意正数 $\epsilon &gt; 0$，有</p><script type="math/tex; mode=display">\lim\limits_{n\rightarrow \infty} P\Big\{\big|\frac{n_A}{n} - p\big| < \epsilon\Big\} = 1\tag{5}</script><p>这个定理表明，当一个事件的重复次数达到一个足够大的数量时，它的发生频率几乎就等于它的发生概率。这个现象似乎很好理解且习以为常，它表现了频率的稳定性，即重复次数足够多时它将稳定在概率的附近。</p><h2 id="定理-3：辛钦定理"><a href="#定理-3：辛钦定理" class="headerlink" title="定理 3：辛钦定理"></a>定理 3：辛钦定理</h2><h3 id="定理内容理解与证明-2"><a href="#定理内容理解与证明-2" class="headerlink" title="定理内容理解与证明"></a>定理内容理解与证明</h3><p>设随机变量 $X_1,X_2,\cdots,X_k,\cdots$ 互相独立，且服从同一分布，且具有数学期望 $E(X_k)=\mu,\;(k=1,2,\cdots)$，则对于任意正数 $\epsilon$，有：</p><script type="math/tex; mode=display">\lim\limits_{n\rightarrow\infty} P\Big\{\big| \frac{1}{n}\sum_{k=1}^n X_k - \mu \big|<\epsilon\Big\} = 1\tag{6}</script><p>相较于切比雪夫大数定律，<strong>辛钦定理并不要求方差的存在</strong>，但是却要求所有随机变量都满足同一分布。</p><p>伯努利定理是辛钦定理的特殊情况，伯努利大数定理成立，意味着各个事件的发生概率都逼近于发生频率，那么事件结果的均值也会逼近于它们的数学期望，也就是辛钦定理的结论。</p><h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><h2 id="中心极限定理概述"><a href="#中心极限定理概述" class="headerlink" title="中心极限定理概述"></a>中心极限定理概述</h2><p>中心极限定理是指随着随机变量的个数 $n$ 的增大，随机变量 $X_1,X_2,\cdots,X_n$ 的和 $\sum_{k = 1}^n X_k$ 的分布将越来越逼近正态分布。</p><h2 id="定理-1：独立同分布的中心极限定理"><a href="#定理-1：独立同分布的中心极限定理" class="headerlink" title="定理 1：独立同分布的中心极限定理"></a>定理 1：独立同分布的中心极限定理</h2><p>令 $S_n = \sum_{k=1}^n X_k$，我们将 $S_n$ 的标准化向量 $Y_n$ 定义如下：</p><script type="math/tex; mode=display">Y_n = \frac{S_n  - E(S_n)}{\sqrt{D(S_n)}}</script><p>由于 $E(S_n) = E(\sum_{k=1}^n X_k) = \sum_{k=1}^n E(X_k) = \sum_{k=1}^n \mu = n\mu$</p><p>以及 $D(S_n) = D(\sum_{k=1}^n X_k) = \sum_{k=1}^nD(X_k) = \sum_{k=1}^n \sigma^2 = n\sigma^2$</p><p>因此 $Y_n$ 还能写作：</p><script type="math/tex; mode=display">Y_n = \frac{\sum_{k=1}^n X_k - n\mu}{\sqrt{n} \cdot \sigma}\tag{7}</script><p>这个标准化向量 $Y_n$ 服从标准正态分布，即 $Y_n\sim N(0,1)$，即有：</p><script type="math/tex; mode=display">F_{Y_n}(x) =  P(Y_n \le x) = \int_{-\infty}^x \frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt\tag{8}</script><h2 id="定理-2：德莫佛－拉普拉斯定理"><a href="#定理-2：德莫佛－拉普拉斯定理" class="headerlink" title="定理 2：德莫佛－拉普拉斯定理"></a>定理 2：德莫佛－拉普拉斯定理</h2><p>德莫佛－拉普拉斯定理实际上是独立同分布的中心极限定理一组 0-1 分布上的特例，我们同样令 $Y_n$ 作为服从 0-1 分布的随机变量 $X_k\;(k=1,2,\cdots)$ 的 $n$ 项加和 $S_n$ 的标准化向量，即：</p><script type="math/tex; mode=display">Y_n = \frac{S_n  - E(S_n)}{\sqrt{D(S_n)}} = \frac{\sum_{k=1}^n X_k - n\mu}{\sqrt{n} \cdot \sigma}\tag{9}</script><p>根据 0-1 分布的结论 $\mu = p$，$\sigma^2 = (1-p)p$，并且 $\sum_{k=1}^n X_k$ 实际上符合二项分布，即：</p><script type="math/tex; mode=display">\sum_{k=1}^n X_k = \eta_n \sim B(n,p)\tag{10}</script><p>根据上述结论对公式 $(9)$ 进行变换，可得：</p><script type="math/tex; mode=display">Y_n = \frac{\eta_n - np}{\sqrt{n(1-p)p}}\tag{11}</script><p>根据独立同分布的中心极限定理，立知当 $n$ 无限趋近于正无穷时， $Y_n$ 的分布函数无限趋近于正态分布，即：</p><script type="math/tex; mode=display">\lim\limits_{n\rightarrow \infty} Y_n \sim N(0,1)</script><script type="math/tex; mode=display">\lim _{n \rightarrow \infty} P\left\{\frac{\eta_n-n p}{\sqrt{n p(1-p)}} \leq x\right\}=\int_{-\infty}^x \frac{1}{\sqrt{2 \pi}} \mathrm{e}^{-\frac{t^2}{2}} \mathrm{~d} t=\Phi(x)\tag{12}</script><p><strong>这个定理的意义在于使我们可以方便地使用标准正态分布表来规避巨大的二项分布计算。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第七节：随机变量的数学期望和方差</title>
      <link href="/2022/10/02/cu%E6%A6%82%E7%BB%9F7/"/>
      <url>/2022/10/02/cu%E6%A6%82%E7%BB%9F7/</url>
      
        <content type="html"><![CDATA[<h1 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h1><h2 id="数学期望的概念"><a href="#数学期望的概念" class="headerlink" title="数学期望的概念"></a>数学期望的概念</h2><h3 id="离散型随机变量的数学期望"><a href="#离散型随机变量的数学期望" class="headerlink" title="离散型随机变量的数学期望"></a>离散型随机变量的数学期望</h3><p>设离散型随机变量 $X$ 的分布律为</p><script type="math/tex; mode=display">P\{X = x_k\} = p_k,\;\;\; k = 1,2,\cdots</script><p>若级数 $\sum_{k=1}^\infty x_kp_k$ 绝对收敛，则称级数 $\sum_{k=1}^\infty x_kp_k$ 为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即有 </p><script type="math/tex; mode=display">E(X) = \sum_{k = 1}^\infty x_kp_k</script><blockquote><p>随机变量的计算方式和一般变量的算术平均不同，一些人尽管认识到了这点，但是在问题变形后又会陷入误区。</p><p>代表数学期望的级数应该是绝对收敛的，级数的绝对收敛性保证了级数的和不随各项次序的改变而改变。</p></blockquote><h3 id="连续型随机变量的数学期望"><a href="#连续型随机变量的数学期望" class="headerlink" title="连续型随机变量的数学期望"></a>连续型随机变量的数学期望</h3><p>设连续型随机变量 $X$ 的概率密度为 $f(x)$，若积分 $\int_{-\infty}^\infty xf(x)dx$ 的值为随机变量 $X$ 的数学期望，记为 $E(X)$ ，即有 </p><script type="math/tex; mode=display">E(X) = \int_{-\infty}^\infty xf(x)dx</script><div class="note info flat"><p>作者非常建议用离散型随机变量的观点去看待连续型随机变量的问题，对于公式 $\int_{-\infty}^\infty xf(x)dx$ 可以把 $x$ 视为单独的一个点，将 $f(x)$ 视为 $x$ 的概率，并且，单个点的概率 $f(x)$ 应该被视为 $0$，只有它们的积分才具有意义。</p><p>尽管这种方式并不科学，但却很好地帮助读者理解这个公式。</p></div><h2 id="数学期望的性质"><a href="#数学期望的性质" class="headerlink" title="数学期望的性质"></a>数学期望的性质</h2><h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 1"></a>性质 1</h3><p>设 $C$ 是常数，则有 $E(C) = C$</p><h3 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 2"></a>性质 2</h3><p>设 $X$ 是一个随机变量，$C$ 是常数，则有：</p><script type="math/tex; mode=display">E(CX) = CE(X)</script><p>离散型证明方法如下：</p><script type="math/tex; mode=display">E(CX) = \sum_{k}Cx_kp_k = C\sum_{k}x_kc_k = CE(X)</script><p>连续型证明方法如下：</p><script type="math/tex; mode=display">E(CX) = \int_{-\infty}^\infty Cxf(x) = C\int_{-\infty}^\infty xf(x)</script><h3 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 3"></a>性质 3</h3><p>设 $X,Y$ 是两个随机变量，则有：</p><script type="math/tex; mode=display">E(X+Y) = E(X) + E(Y)\tag{1}</script><p>离散型证明方法如下：</p><script type="math/tex; mode=display">\sum_{i}\sum_{j} \big[(x_i + y_j)P\{X = x_i, Y = y_j\}\big]</script><script type="math/tex; mode=display">= \sum_{i}\sum_{j} \big[x_i\cdot P\{X = x_i, Y = y_j\} + y_j\cdot P\{X = x_i, Y = y_j\}\big]</script><script type="math/tex; mode=display">= \sum_{i}\sum_{j} \big[x_i\cdot P\{X = x_i, Y = y_j\}\big] + \sum_{i}\sum_{j} \big[ y_j\cdot P\{X = x_i, Y = y_j\}\big]</script><script type="math/tex; mode=display">= \sum_{i}x_i\sum_{j} P\{X = x_i, Y= y_j\}+\sum_{j}y_j\sum_{i}P\{X = x_i, Y=y_j\}</script><script type="math/tex; mode=display">= \sum_{i}x_iP(x_i) + \sum_{j}y_jP(y_j) = E(x) + E(Y)</script><p>连续型证明方法如下：</p><script type="math/tex; mode=display">E(X + Y) = \int_{-\infty}^\infty\int_{-\infty}^\infty (x+y)f(x,y)dxdy</script><script type="math/tex; mode=display">= \int_{-\infty}^\infty\int_{-\infty}^\infty xf(x,y)dxdy + \int_{-\infty}^\infty\int_{-\infty}^\infty yf(x,y)dxdy</script><script type="math/tex; mode=display">= \int_{-\infty}^\infty xdx\int_{-\infty}^\infty f(x,y)dy + \int_{-\infty}^\infty ydy\int_{-\infty}^\infty f(x,y)dx</script><script type="math/tex; mode=display">= \int_{-\infty}^\infty xf(x)dx + \int_{-\infty}^\infty yf(y)dy = E(X) + E(Y)</script><div class="note info flat"><p>根据性质 2 和性质 3，可以采用数学归纳法推出数学期望的线性组合的性质：</p><script type="math/tex; mode=display">E(\alpha_1 x_1 + \alpha_2 x_2 + \cdots + \alpha_n x_3) = \alpha_1E(x_1) + \alpha_2 E(x_2) + \cdots + \alpha_n E(x_n)</script></div><h3 id="性质-4"><a href="#性质-4" class="headerlink" title="性质 4"></a>性质 4</h3><p>设 $X,Y$ 是两个相互独立的随机变量，则有：</p><script type="math/tex; mode=display">E(XY) = E(X)E(Y) \tag{2}</script><p>离散型证明方法如下：</p><script type="math/tex; mode=display">E(XY) = \sum_{i}\sum_{j}x_iy_j\cdot P\{X = x_i, Y = y_j\}</script><p>由于 $X$ 和 $Y$ 相互独立，因此有：$P\{X = x_i, Y = y_j\} =  P(X = x_i)P(Y = y_j)$</p><script type="math/tex; mode=display">= \sum_{i}\sum_{j}x_iy_j\cdot P(X = x_i)P(Y = y_j)</script><script type="math/tex; mode=display">= \sum_{i}x_iP(X = x_i)\cdot\sum_{j}y_jP(X = y_j) = E(X)E(Y)</script><p>连续型证明方法如下：</p><script type="math/tex; mode=display">E(XY) = \int_{-\infty}^\infty\int_{-\infty}^\infty xy\cdot f(x,y)dxdy</script><p>由于 $X$ 和 $Y$ 相互独立，因此有：$f(x,y) = f_X(x)f_Y(y)$</p><script type="math/tex; mode=display">E(XY) = \int_{-\infty}^\infty xf_X(x)dx\int_{-\infty}^\infty y\cdot f_Y(y)dy = E(X)E(Y)</script><div class="note warning flat"><p>尽管 $X$ 和 $Y$ 相互独立可以推出 $E(XY) = E(X)E(Y)$，但是 $E(XY) = E(X)E(Y)$ 却不能推出 $X$ 和 $Y$ 相互独立</p></div><h2 id="随机变量函数的数学期望"><a href="#随机变量函数的数学期望" class="headerlink" title="随机变量函数的数学期望"></a>随机变量函数的数学期望</h2><h3 id="一维离散型随机变量的数学期望"><a href="#一维离散型随机变量的数学期望" class="headerlink" title="一维离散型随机变量的数学期望"></a>一维离散型随机变量的数学期望</h3><p>设随机变量 $X$ 的分布律为 $P\{X = x_k\} = p_k$，若 $Y = g(X)$ ，则离散型随机变量函数 $Y$ 的数学期望为：</p><script type="math/tex; mode=display">E(g(X)) = \sum_{k=1}^\infty g(X_k)p_k,\;\;\; k =1,2,3,\cdots</script><h3 id="一维连续性随机变量的数学期望"><a href="#一维连续性随机变量的数学期望" class="headerlink" title="一维连续性随机变量的数学期望"></a>一维连续性随机变量的数学期望</h3><p>设 $X$ 是连续性随机变量，它的概率密度函数为 $f(x)$，则有：</p><script type="math/tex; mode=display">E(g(X)) = \int_{-\infty}^\infty g(x)f(x)dx</script><h3 id="二维离散型随机变量的数学期望"><a href="#二维离散型随机变量的数学期望" class="headerlink" title="二维离散型随机变量的数学期望"></a>二维离散型随机变量的数学期望</h3><p>设 $X,Y$ 为离散型随机变量，$g(x,y)$ 为二元函数，则有：</p><script type="math/tex; mode=display">E[g(X,Y)] = \sum_{i}\sum_j g(x_i,y_j)p_{ij}</script><p>其中 $(X,Y)$ 的联合概率分布为 $p_{ij}$。</p><h3 id="二维连续型随机变量的数学期望"><a href="#二维连续型随机变量的数学期望" class="headerlink" title="二维连续型随机变量的数学期望"></a>二维连续型随机变量的数学期望</h3><p>设 $X,Y$ 为连续型随机变量，设 $g(x,y)$ 为二元函数，则有：</p><script type="math/tex; mode=display">E[g(X,Y)] = \int_{-\infty}^\infty \int_{-\infty}^\infty g(x,y)f(x,y)dxdy</script><div class="note info flat"><p>事实上，理解上述公式的捷径同样是将 $p_{ij}$ 或 $f(x,y)$ 视为单个点的概率，然后进行累加/积分</p></div><h1 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h1><h2 id="方差的概念"><a href="#方差的概念" class="headerlink" title="方差的概念"></a>方差的概念</h2><p>设 $X$ 是一个随机变量，若 $E\{\big[X - E(X)\big]^2\}$ 存在，则称 $E\{\big[X - E(X)\big]^2\}$ 为随机变量 $X$ 的方差，记为 $D(X)$ 或 $Var(X)$，即有：</p><script type="math/tex; mode=display">D(X) = Var(X) = E\{\big[X - E(X)\big]^2\}</script><p>由于 $E(X)$ 可以表示离散型和连续型的均值，因此上述形式可以同时表示离散型和连续型函数的方差。也许你已经注意到了，<strong>方差不过也只是均值的一个函数</strong>，因此它可以写作如下形式：</p><p>对于离散型变量的方差：</p><script type="math/tex; mode=display">D(X) = E\{\big[X - E(X)\big]^2\} = \sum_{k}\big[x_k - E(X)\big]^2p_k\tag{3}</script><p>对于连续型变量的方差：</p><script type="math/tex; mode=display">D(X) = E\{\big[X - E(X)\big]^2\} = \int_{-\infty}^\infty \big[x - E(X)\big]^2 f(x)dx\tag{4}</script><p>方差是一个常用来体现随机变量 $X$ 取值分散程度的量。如果 $D(X)$ 值大，表示 $X$ 取值分散程度大，$E(X)$ 的代表性差。而如果 $D(X)$ 值小，则表示 $X$ 的取值比较集中，以 $E(X)$ 作为随机变量的代表性好。</p><h2 id="方差的性质"><a href="#方差的性质" class="headerlink" title="方差的性质"></a>方差的性质</h2><h3 id="性质-1-1"><a href="#性质-1-1" class="headerlink" title="性质 1"></a>性质 1</h3><p>对于随机变量 $X$ 的方差 $D(X)$ 和均值 $E(X)$，总有下述公式成立：</p><script type="math/tex; mode=display">D(X) = E(X^2) - \big[E(X)\big]^2\tag{5}</script><p>证明方法如下：</p><script type="math/tex; mode=display">D(X) = E\{\big[X - E(X)\big]^2\} = E\{X^2 - 2XE(X) + E(X)^2\}</script><p>不妨将 $X^2$ 、$XE(X)$ 和 $E(X)^2$ 视为三个单元，根据 $E(X + Y) = E(X) + E(Y)$ 有：</p><script type="math/tex; mode=display">E\{X^2 - 2XE(X) + E(X)^2\} = E(X^2) - E(2XE(X)) + [E(X)]^2</script><p>对 $E(2XE(X))$ 利用公式 $E(XY) = E(X)E(Y)$ 继续拆解得到：</p><script type="math/tex; mode=display">E(X^2) - 2E(X)E[E(X)] + [E(X)]^2</script><p>由于 $E(X)$ 是一个定值，根据 $E(C) = C$ 可知 $E[E(X)] = E(X)$，上式可以转化为：</p><script type="math/tex; mode=display">E(X^2) - 2[E(X)^2] + [E(X)]^2 = E(X^2) - [E(X)]^2</script><div class="note info flat"><p>尽管需要掌握推导方法，这个公式还是推荐记忆</p></div><h3 id="性质-2-1"><a href="#性质-2-1" class="headerlink" title="性质 2"></a>性质 2</h3><p>如果一个随机变量的取值为常数（或者说随机变量 $X$ 以概率 $1$ 取常数 $C$），则该随机变量的方差为 $0$，即有：$D(C) = 0$，其中 $C$ 为常数。证明方法如下：</p><script type="math/tex; mode=display">D(C) = E(C^2) - [E(C)]^2 = C^2 - C^2 = 0\tag{6}</script><h3 id="性质-3-1"><a href="#性质-3-1" class="headerlink" title="性质 3"></a>性质 3</h3><p>设 $X$ 是一个随机变量，$C$ 是常数，则有：</p><script type="math/tex; mode=display">D(CX) = C^2D(X)\tag{7}</script><p>证明方法如下：</p><script type="math/tex; mode=display">D(CX) = E(C^2X^2) - [E(CX)]^2 = C^2E(X^2) - C^2[E(X)]^2 = C^2D(X)</script><h3 id="性质-4-1"><a href="#性质-4-1" class="headerlink" title="性质 4"></a>性质 4</h3><p>设 $X,Y$ 相互独立，$D(X),D(Y)$ 存在，则有：</p><script type="math/tex; mode=display">D(X \pm Y) = D(X) + D(Y)\tag{8}</script><p>证明方法如下：</p><script type="math/tex; mode=display">D(X \pm Y) = E[(X\pm Y)^2] - [E(X\pm Y)]^2</script><script type="math/tex; mode=display">= E[X^2 \pm 2 XY + Y^2] - [E(X) \pm E(Y)]^2</script><script type="math/tex; mode=display">= E(X^2)\pm 2E(XY) + E(Y^2) - [E(X)]^2 \mp 2E(X)E(Y) - [E(Y)]^2</script><script type="math/tex; mode=display">= E(X^2) - [E(X)]^2 + E(Y^2) - [E(Y)]^2 = D(X) + D(Y)</script><div class="note info flat"><p>推导的关键在于 $\pm E(XY)$ 和 $\mp E(X)E(Y)$ 正好可以消掉，当然，这是基于 $X,Y$ 相互独立的前提下才能成立的，这个结论也希望读者直接记忆。</p></div><p>性质 $4$ 可以使用数学归纳法进一步导出以下推论：</p><p>如果有随机变量 $X_1,X_2,\cdots,X_n$ 之间相互独立，则有：</p><script type="math/tex; mode=display">D(X_1 \pm X_2\pm \cdots \pm X_n) = D(X_1) + D(X_2) + \cdots + D(X_n)\tag{9}</script><h3 id="性质-5：切比雪夫不等式"><a href="#性质-5：切比雪夫不等式" class="headerlink" title="性质 5：切比雪夫不等式"></a>性质 5：切比雪夫不等式</h3><p>定理内容：设随机变量 $X$ 具有数学期望 $E(X) = \mu$，方差 $D(X) = \sigma^2$，则对于任意正数 $\epsilon$ ，以下不等式均成立：</p><script type="math/tex; mode=display">P\{|X - \mu| \ge \epsilon \} \le \frac{\sigma^2}{\epsilon^2}</script><p>连续型证明方法如下：</p><script type="math/tex; mode=display">P\{|X -\mu| \ge \mu\} = \int_{|x-\mu|\ge \epsilon} f(x)dx</script><p>由于在积分区域上有 $|X - \mu| \ge \epsilon$，故而 $\frac{|x-\mu|^2}{\epsilon^2} \le 1$ 因此有如下不等式成立： </p><script type="math/tex; mode=display">\int_{|x-\mu|\ge \epsilon} f(x)dx \le \int_{|x-\mu|\ge \epsilon}\frac{|x-\mu|^2}{\epsilon^2} f(x)dx = \frac{1}{\epsilon^2}\int_{|x-\mu|\ge \epsilon}{|x-\mu|^2} f(x)dx</script><script type="math/tex; mode=display">\frac{1}{\epsilon^2}\int_{|x-\mu|\ge \epsilon}{|x-\mu|^2} f(x)dx \le \frac{1}{\epsilon^2}\int_{-\infty}^\infty{|x-\mu|^2} f(x)dx</script><p>注意到公式 $\frac{1}{\epsilon^2}\int_{-\infty}^\infty{|x-\mu|^2} f(x)dx$ 完全是方差的定义，因此有：</p><script type="math/tex; mode=display">P\{|X-\mu|\ge \epsilon\}\le \frac{\sigma^2}{\epsilon^2}</script><p>上式就是切比雪夫不等式，这个不等式有另一个形式如下：</p><script type="math/tex; mode=display">P\{|X-\mu| < \epsilon\} \ge 1 - \frac{\sigma^2}{\epsilon^2}</script><blockquote><p>切比雪夫不等式成立的条件是随机变量的数学期望和方差存在。</p></blockquote><p>可以这样理解切比雪夫不等式：当方差越大时，<strong>随机变量分布在均值附近区域的最大概率</strong>也越大</p><h1 id="重要概率分布的均值和方差推导"><a href="#重要概率分布的均值和方差推导" class="headerlink" title="重要概率分布的均值和方差推导"></a>重要概率分布的均值和方差推导</h1><h2 id="离散类概率分布"><a href="#离散类概率分布" class="headerlink" title="离散类概率分布"></a>离散类概率分布</h2><h3 id="两点分布"><a href="#两点分布" class="headerlink" title="两点分布"></a>两点分布</h3><h4 id="均值"><a href="#均值" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = 1\cdot p + 0 \cdot (1-p) = p\tag{10}</script><h4 id="方差-1"><a href="#方差-1" class="headerlink" title="方差"></a>方差</h4><script type="math/tex; mode=display">D(X) = E(X^2) - [E(X)]^2 = 1^2\cdot p + 0^2\cdot (1-p) - p^2 = p(1-p)\tag{11}</script><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><p>若随机变量 $X$ 服从参数为 $n,p$ 的二项分布，则有：</p><script type="math/tex; mode=display">P\{X = k\} = \begin{pmatrix}n\\k\end{pmatrix} p^k(1 - p)^{n-k}</script><h4 id="均值-1"><a href="#均值-1" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = \sum_{k=0}^n k\cdot P\{X=k\} = \sum_{k=0}^nk\cdot \begin{pmatrix}n\\k\end{pmatrix} p^k(1 - p)^{n-k}</script><script type="math/tex; mode=display">= \sum_{k=0}^n\frac{k n!}{k!(n-k)!}p^k(1-p)^{n-k} = \sum_{k=0}^n\frac{np(n-1)!}{(k-1)![(n-1)-(k-1)]!} p^{k-1}(1-p)^{(n-1)-(k-1)}</script><p>观察上式，发现将 $np$ 提取出来以后，剩下的式子 $\sum_{k=0}^n\frac{(n-1)!}{(k-1)![(n-1)-(k-1)]!} p^{k-1}(1-p)^{(n-1)-(k-1)}$ 完全是一个新的二项分布 $B(n-1,p)$ 的和，即：</p><script type="math/tex; mode=display">= np\cdot\sum_{k=0}^n\begin{pmatrix}n-1\\k-1\end{pmatrix} p^{k-1}(1-p)^{(n-1)-(k-1)}</script><p>任意二项分布的概率总和都应该为 $1$，因此有 $\sum_{k=0}^n\begin{pmatrix}n-1\\k-1\end{pmatrix} p^{k-1}(1-p)^{(n-1)-(k-1)} = 1$，所以原始的值就是系数 $np$，即有</p><script type="math/tex; mode=display">E(X) = np,\;\;\; X\sim B(n,p) \tag{12}</script><h4 id="方差-2"><a href="#方差-2" class="headerlink" title="方差"></a>方差</h4><p>根据公式 $D(X) = E(X^2) - [E(X)]^2$，二项分布的方差可以分两部分求解，后一部分很明显就是 $n^2p^2$，下面主要求解以下前半部分：</p><script type="math/tex; mode=display">E(X^2) = E[X(X-1) + X] = E[X(X-1)] + E(X)</script><p>你可能已经看出来了，构造出 $E[X(X-1)]+E(X)$ 就是为了构造 $k(k-1)$ 项</p><script type="math/tex; mode=display">= \sum_{k=0}^nk(k-1)\begin{pmatrix}n\\k\end{pmatrix}p^k(1-p)^{n-k} + np</script><script type="math/tex; mode=display">= \sum_{k=0}^n \frac{k(k-1)n!}{k!(n-k)!}p^k(1-p)^{n-k} + np</script><p>对于复杂式子 $\sum_{k=0}^n \frac{k(k-1)n!}{k!(n-k)!}p^k(1-p)^{n-k}$ 仍然采用求均值时的思路，考虑将该式转为一个其它二项分布的概率之和。</p><script type="math/tex; mode=display">= n(n-1)p^2\cdot\sum_{k=0}^n \frac{(n-2)!}{(k-2)![(n-2)-(k-2)]!}p^{k-2}(1-p)^{(n-2)-(k-2)} + np</script><p>很明显 $\sum_{k=0}^n \frac{(n-2)!}{(k-2)![(n-2)-(k-2)]!}p^k(1-p)^{(n-2)-(k-2)}$ 就是一个新的二项分布 $B(n-2,p)$ 的概率之和，该部分显然为 $1$，因此有</p><script type="math/tex; mode=display">= n(n-1)p^2\cdot 1 + np = (n^2-n)p^2+np</script><p>故有原式为：$E(X^2)-[E(X)]^2$，即：</p><script type="math/tex; mode=display">(n^2-n)p^2+np - (np)^2 = np-np^2 = np(1-p)</script><p>得到结论：</p><script type="math/tex; mode=display">D(X) = np(1-p)\tag{13}</script><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><p>若有随机变量 $X$ 满足泊松分布，即 $X\sim \pi(\lambda)$ ，则有分布律为：</p><script type="math/tex; mode=display">P\{X = k\} = \frac{\lambda^k}{k!}e^{-\lambda},\;\;\; k=0,1,2,\cdots,\;\;\;\lambda>0</script><h4 id="均值-2"><a href="#均值-2" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = \sum_{k=0}^\infty k \frac{\lambda^k}{k!}e^{-\lambda} = \lambda \sum_{k=0}^\infty \frac{\lambda^{k-1}}{(k-1)!}e^{-\lambda}</script><p>根据级数的知识，实际上有（下式中等于 1 是因为概率之和为 1）：</p><script type="math/tex; mode=display">\sum_{k=0}^\infty \frac{\lambda^{k-1}}{(k-1)!}e^{-\lambda} = \sum_{k=0}^\infty \frac{\lambda^k}{k!}e^{-\lambda} = 1</script><p>因此有 $E(X)$ 就等于：</p><script type="math/tex; mode=display">E(X) = \lambda \tag{14}</script><h4 id="方差-3"><a href="#方差-3" class="headerlink" title="方差"></a>方差</h4><script type="math/tex; mode=display">D(X) = E(X^2) - [E(X)]^2</script><p>显然有后者等于 $\lambda^2$，下面推导 $E(X^2)$ 的求解方法：</p><script type="math/tex; mode=display">E(X^2) = E[X(X-1)] + E(X)</script><p>这里裂项的思路和之前是一样的，就是为了构造 $k(k-1)$ 项</p><script type="math/tex; mode=display">E[X(X-1)] = \lambda^2\sum_{k=0}^\infty \frac{\lambda^{k-2}}{(k-2)!}e^{-\lambda}</script><p>根据级数的知识，实际上有（下式中等于 1 是因为概率之和为 1）：</p><script type="math/tex; mode=display">\sum_{k=0}^\infty \frac{\lambda^{k-2}}{(k-2)!}e^{-\lambda} = \sum_{k=0}^\infty \frac{\lambda^k}{k!}e^{-\lambda} = 1</script><p>所以有：</p><script type="math/tex; mode=display">E(X^2) = E[X(X-1)] + E(X) = \lambda^2 + \lambda</script><p>因此方差 $D(X)$ 等于：</p><script type="math/tex; mode=display">D(X) = \lambda\tag{15}</script><div class="note info flat"><p>是的，泊松分布的均值和方差都等于 $\lambda$</p></div><h2 id="连续类概率分布"><a href="#连续类概率分布" class="headerlink" title="连续类概率分布"></a>连续类概率分布</h2><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>设有 $X\sim U(a,b)$，其概率密度为：</p><script type="math/tex; mode=display">f(x) =  \left\{\begin{matrix}&\frac{1}{b-a},\;\;\; a<x<b \\& 0, \;\;\;otherwise \end{matrix}\right.</script><h4 id="均值-3"><a href="#均值-3" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = \int_{-\infty}^\infty xf(x)dx = \int_{a}^b \frac{1}{b-a}xdx = \frac{a+b}{2}\tag{16}</script><h4 id="方差-4"><a href="#方差-4" class="headerlink" title="方差"></a>方差</h4><script type="math/tex; mode=display">D(X) = E(X^2) - [E(X)]^2 = \int_{a}^bx^2\frac{1}{b-a}dx - (\frac{a+b}{2})^2 = \frac{(b-a)^2}{12}\tag{17}</script><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><p>设随机变量 $X$ 服从指数分布，其概率密度为：</p><script type="math/tex; mode=display">f(x) = \left\{\begin{matrix}&\frac{1}{\theta}e^{-x/\theta},\;\;\; a<x<b \\& 0, \;\;\;otherwise \end{matrix}\right.</script><h4 id="均值-4"><a href="#均值-4" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = \int_{-\infty}^\infty xf(x)dx = \int_{0}^\infty \frac{x}{\theta}e^{-x/\theta}dx</script><p>根据分部积分原理 $\int udv = uv - \int vdu$ 有：</p><script type="math/tex; mode=display">= \int_{0}^\infty \frac{x}{\theta}e^{-x/\theta}dx = -\frac{1}{\theta}\int_{0}^\infty xde^{-x/\theta} = -\frac{1}{\theta}(xe^{-x/\theta}\Big|_{0}^\infty - \int_{0}^\infty e^{-x/\theta}dx) = \theta</script><p>因此有指数分布的均值为：</p><script type="math/tex; mode=display">E(X) = \theta\tag{18}</script><h4 id="方差-5"><a href="#方差-5" class="headerlink" title="方差"></a>方差</h4><p>易得 $[E(X)]^2 = \theta^2$，则下面侧重求解 $E(X^2)$，同样采用分部积分的思路完成：</p><script type="math/tex; mode=display">E(X^2) = \int_{0}^\infty \frac{x^2}{\theta}e^{-x/\theta}dx = -\int_{0}^\infty x^2de^{-x/\theta}</script><script type="math/tex; mode=display">-\int_{0}^\infty x^2de^{-x/\theta} = -(x^2e^{-x/\theta}\Big|_0^{\infty} - 2\int_0^\infty xe^{-x/\theta}dx)</script><p>根据对指数分布均值的求解过程可知 $\int_0^\infty xe^{-x/\theta}dx = \theta^2$，代入上式中有：</p><script type="math/tex; mode=display">= -(0 - 2\theta^2) = 2\theta^2</script><script type="math/tex; mode=display">D(X) = E(X^2) - [E(X)]^2 = \theta^2</script><p>即有指数分布的方差为</p><script type="math/tex; mode=display">D(X) = \theta^2\tag{19}</script><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><p>设随机变量 $X\sim N(\mu, \sigma^2)$ ，即有 $X$ 的概率密度为：</p><script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}dx</script><h4 id="均值-5"><a href="#均值-5" class="headerlink" title="均值"></a>均值</h4><script type="math/tex; mode=display">E(X) = \int_{-\infty}^\infty xf(x)dx = \int_{0}^\infty x\cdot \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}dx</script><p>我们尽可能地将一般形式的正态分布转化到标准正态分布，于是令 $\frac{x-\mu}{\sigma} = t$，可以得到：</p><script type="math/tex; mode=display">= \frac{1}{\sqrt{2\pi}}\int_{-\infty}^\infty (\mu + \sigma t)e^{-\frac{t^2}{2}}dt</script><script type="math/tex; mode=display">= \mu \frac{1}{\sqrt{2\pi}}\int_{-\infty}^\infty e^{-\frac{t^2}{2}}dt + \frac{\sigma}{\sqrt{2\pi}}\int_{-\infty}^\infty te^{-\frac{t^2}{2}}dt</script><p>上式中，$\frac{1}{\sqrt{2\pi}}\int_{-\infty}^\infty e^{-\frac{t^2}{2}}dt$ 就是标准正态分布的概率密度积分，显然等于 $1$，而 $\frac{\sigma}{\sqrt{2\pi}}\int_{-\infty}^\infty te^{-\frac{t^2}{2}}dt$ 是一个关于原点中心对称的函数的积分，因此等于 $0$。</p><p>所以可以得到正态分布的均值为 $\mu$ ，即：</p><script type="math/tex; mode=display">E(X) = \mu\tag{20}</script><h4 id="方差-6"><a href="#方差-6" class="headerlink" title="方差"></a>方差</h4><script type="math/tex; mode=display">D(X) = \int_{-\infty}^\infty (x-\mu)^2f(x)dx = \int_{-\infty}^\infty (x-\mu)^2 \frac{1}{\sqrt{2\pi}\sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}dx</script><p>采用同样的思路尽量向标准正态分布靠拢，令 $\frac{x-\mu}{\sigma} = t$，得到：</p><script type="math/tex; mode=display">D(X) = \frac{\sigma^2}{\sqrt{2\pi}}\int_{-\infty}^\infty t^2 e^{-\frac{t^2}{2}}dt = \frac{\sigma^2}{\sqrt{2\pi}}\Big( -te^{-\frac{t^2}{2}}\Big|_{-\infty}^\infty + \int_{-\infty}^\infty e^{-\frac{t^2}{2}}dt \Big)</script><script type="math/tex; mode=display">= 0 + \frac{\sigma^2}{\sqrt{2\pi}} \sqrt{2\pi} = \sigma^2</script><div class="note info flat"><p>正态分布的均值和方差推导比较复杂，好在最终形式比较简单，笔者是推荐直接记忆的</p></div>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第六节：随机变量的函数的分布</title>
      <link href="/2022/09/25/cu%E6%A6%82%E7%BB%9F6/"/>
      <url>/2022/09/25/cu%E6%A6%82%E7%BB%9F6/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）一维离散型随机变量函数的分布"><a href="#（壹）一维离散型随机变量函数的分布" class="headerlink" title="（壹）一维离散型随机变量函数的分布"></a>（壹）一维离散型随机变量函数的分布</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>设 $g(x)$ 是定义在随机变量 $X$ 的一切可能值的 $x$ 的集合上的函数，若随机变量 $Y$ 随着 $X$ 取值 $x$ 的值而取 $y = g(x)$ 的值，则称随机变量 $Y$ 为变量 $X$ 的函数，记作 $Y = g(X)$</p><p>以上是对一维离散型随机变量函数的分布的标准定义，换言之，就是对于任何一个 $x$ 都有一个唯一的随机变量 $y$ 与之对应。这种对应是根据一个函数规则 $g$ 来指定的。</p><h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>对于离散型随机变量的函数的分布，求解方法非常简单，分为两步：</p><h3 id="第一步：依表转换"><a href="#第一步：依表转换" class="headerlink" title="第一步：依表转换"></a>第一步：依表转换</h3><p>假设原变量 $X$ 的分布律如下：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$x_1$</th><th>$x_2$</th><th>$\cdots$</th><th>$x_k$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$P$</td><td>$p_1$</td><td>$p_2$</td><td>$\cdots$</td><td>$p_k$</td><td>$\cdots$</td></tr></tbody></table></div><p>则可以列出 $Y = g(X)$ 的分布律为：</p><div class="table-container"><table><thead><tr><th>$Y$</th><th>$g(x_1)$</th><th>$g(x_2)$</th><th>$\cdots$</th><th>$g(x_k)$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$P$</td><td>$p_1$</td><td>$p_2$</td><td>$\cdots$</td><td>$p_k$</td><td>$\cdots$</td></tr></tbody></table></div><h3 id="第二步：同项合并"><a href="#第二步：同项合并" class="headerlink" title="第二步：同项合并"></a>第二步：同项合并</h3><p>对于表格中如果出现 $g(x_i) = g(x_j)$ 且 $i\ne j$ 的情形，应该将相同情况的概率累加合并，得到化简以后的分布律。 </p><div class="note info flat"><p>由于过分简单，此处甚至无需例题补充</p></div><h1 id="（贰）一维连续型随机变量函数的分布"><a href="#（贰）一维连续型随机变量函数的分布" class="headerlink" title="（贰）一维连续型随机变量函数的分布"></a>（贰）一维连续型随机变量函数的分布</h1><p>一维连续型随机变量函数的分布和一维离散型随机变量函数的分布的<strong>定义几乎一致</strong>，此处就不再赘述。</p><p>这部分的重点在于问题的求解技巧上。而<strong>常见的问题就是如何求解因变量的概率密度函数，下面讨论这一问题</strong></p><h2 id="Tip-1-先求分布函数再微分得到概率密度函数"><a href="#Tip-1-先求分布函数再微分得到概率密度函数" class="headerlink" title="$Tip\;1$ : 先求分布函数再微分得到概率密度函数"></a>$Tip\;1$ : 先求分布函数再微分得到概率密度函数</h2><h3 id="步骤分解"><a href="#步骤分解" class="headerlink" title="步骤分解"></a>步骤分解</h3><p>第一个技巧分为三步完成：</p><p><strong>第一步是先对原随机变量 $X$ 进行积分，得到原随机变量 $X$ 的分布函数</strong>：</p><script type="math/tex; mode=display">P\{X \le x\} = F_X(x) = \int_{-\infty}^x f(t) dt\tag{1}</script><p>其中 $f_X(t)$ 表示 $X$ 的概率密度函数，$F_X(x)$ 表示 $X$ 的分布函数，下标 $X$ 用于指明函数所属变量，防止和 $f_Y(y)$ 以及 $F_Y(y)$ 混淆</p><p><strong>第二步是根据函数 $Y = g(X)$ 进行变量替换，求出 $Y$ 的分布函数</strong></p><script type="math/tex; mode=display">F_Y(y) = P\{Y \le y\} = P\{g(X) \le y\} = P\{X \le h(y)\}\tag{2}</script><p><strong>等式（2）的最后一个等号表示通过移项，不等式恒等变换等操作，让 $g(X) \le y$ 的左边只留下 $X$，因此得到 $P\{X \le h(y)\}$，其中 $h(y)$ 是一个只与 $y$ 有关的函数</strong></p><p>等式（2）已经实际上将 $F_Y(y)$ 和 $P\{X \le h(y)\}$ 建立了等式关系，因此可以进一步得出：</p><script type="math/tex; mode=display">F_Y(y) = P\{X \le h(y)\} = \int_{-\infty}^{h(y)} f_X(t)dt = F_X(h(y)) - 0\tag{3}</script><p><strong>第三步就是对因变量 $Y$ 的分布函数 $F_Y(y)$ 进行求导操作，得到因变量的概率密度函数 $f_Y(\beta)$</strong>：</p><script type="math/tex; mode=display">f_Y(y) = (F_Y(y))' = f_X(h(y))\cdot h'(y)\tag{4}</script><div class="note info flat"><p>如果你觉得上述推导过程过于麻烦，可以直接记忆等式（4），但是非常不推荐这样做！你应该理解上述方法的核心思维，因为上述公式只是理想化的推导，并不是种种情况都按照我们假设的情况发展，比如下面的 <a href="#例题-2">例题 $2$（点击跳转）</a></p></div><h3 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 1"></a>例题 1</h3><p>设随机变量 $X$ 的概率密度为 </p><script type="math/tex; mode=display">f_X(x)= \begin{cases}0, & x<0 \\ x^3 \mathbf{e}^{-x^2}, & x \geq 0\end{cases}</script><p>求随机变量 $Y = 2X + 3$ 的概率密度。</p><p>解：当 $Y=2 X+3$ 时，有</p><script type="math/tex; mode=display">y=2 x + 3 \Rightarrow x=\frac{y-3}{2}</script><script type="math/tex; mode=display">f_Y(y)=(F_Y(y))^{\prime}=\left[\int_{-\infty}^{\frac{y-3}{2}} f_X(x) \mathrm{d} x\right]^{\prime}</script><script type="math/tex; mode=display">= \left\{    \begin{aligned}        &(\frac{y - 3}{2})^3\mathbf{e}^{-(\frac{y-3}{2})^2}(\frac{y-3}{2})',\;\;\; y \ge 3\\        &0,\;\;\; y < 3    \end{aligned}\right.</script><h3 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 2"></a>例题 2</h3><p>设随机变量 $X$ 的概率密度如例题 1，求随机变量 $Y = X^2$ 的概率密度</p><p>解：当 $Y = X^2$ 时，有</p><script type="math/tex; mode=display">F_Y(y) = P\{Y\le y\} = P\{X^2 \le y\}</script><script type="math/tex; mode=display">= P\{-\sqrt{y}\le X \le \sqrt{y}\} = F_X(\sqrt{y}) - F_X(-\sqrt{y})</script><script type="math/tex; mode=display">=  \int_{-\infty}^{\sqrt{y}} f_X(x)dx - \int_{-\infty}^{-\sqrt{y}} f_X(x)dx</script><script type="math/tex; mode=display">f_Y(y) =  (F_Y(y))' = f_X(\sqrt{y})(\sqrt{y})' - f_X(-\sqrt{y})(-\sqrt{y})'</script><script type="math/tex; mode=display">= \left\{    \begin{aligned}        &\frac{ye^{-y}}{2},\;\;\;y > 0\\        &0,\;\;\; y\le 0    \end{aligned}\right.</script><h3 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h3><p>研究两道例题，可以发现对于增减性单调的函数有以下定理：</p><p>设随机变量 $X$ 的具有概率密度 $f_X(x)$，其中 $x\in(-\infty,+\infty)$，又设函数 $g(x)$ 处处可导且恒有 $g’(x) &gt; 0$（或恒有 $g’(x) &lt; 0$），则称 $Y = g(X)$ 是连续型随机变量，其概率密度为：</p><script type="math/tex; mode=display">f_Y(y) = \left\{    \begin{aligned}        &f_X[h(y)]|h'(y)|,\;\;\;\alpha<y<\beta\\        &0,\;\;\; otherwise    \end{aligned}\right.\tag{5}</script><p>其中 $h(y)$ 是一个关于 $y$ 的函数：$X = h(y)$，而 $\alpha$ 和 $\beta$ 分别是 $X$ 趋于正负无穷时得到的下界/上界，即：</p><script type="math/tex; mode=display">\alpha = min\{g(-\infty),g(+\infty)\},\;\;\;\beta = max\{g(-\infty),g(+\infty)\}</script><h1 id="（叁）二维离散型随机变量的函数的分布"><a href="#（叁）二维离散型随机变量的函数的分布" class="headerlink" title="（叁）二维离散型随机变量的函数的分布"></a>（叁）二维离散型随机变量的函数的分布</h1><h2 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h2><p>设 $g(x，y)$ 是定义在二维随机变量 $(X,Y)$ 的一切可能值的 $(x,y)$ 的集合上的函数，若随机变量 $Z$ 随着 $(X,Y)$ 取值 $(x,y)$ 的值而取 $z = g(x,y)$ 的值，则称随机变量 $Z$ 为二维随机变量 $(X,Y)$ 的函数，记作 $Z = g(X,Y)$</p><p>以上是对一维离散型随机变量函数的分布的标准定义，换言之，就是对于任何一个 $(x,y)$ 都有一个唯一的随机变量 $z$ 与之对应。这种对应是根据一个函数规则 $g$ 来指定的。</p><h2 id="求解方法-1"><a href="#求解方法-1" class="headerlink" title="求解方法"></a>求解方法</h2><p>对于离散型二维随机变量的函数的分布，求解方法非常简单，分为两步：</p><h3 id="第一步：依表转换-1"><a href="#第一步：依表转换-1" class="headerlink" title="第一步：依表转换"></a>第一步：依表转换</h3><p>假设原变量 $X$ 的分布律如下：</p><div class="table-container"><table><thead><tr><th>$Y \&amp; X$</th><th>$x_1$</th><th>$x_2$</th><th>$\cdots$</th><th>$x_k$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$y_1$</td><td>$p_{11}$</td><td>$p_{21}$</td><td>$\cdots$</td><td>$p_{k1}$</td><td>$\cdots$</td></tr><tr><td>$y_2$</td><td>$p_{12}$</td><td>$p_{22}$</td><td>$\cdots$</td><td>$p_{k2}$</td><td>$\cdots$</td></tr><tr><td>$\vdots$</td><td>$\vdots$</td><td>$\vdots$</td><td>$\ddots$</td><td>$\vdots$</td><td>$\vdots$</td></tr><tr><td>$y_k$</td><td>$p_{k1}$</td><td>$p_{k2}$</td><td>$\cdots$</td><td>$p_{kk}$</td><td>$\cdots$</td></tr><tr><td>$\vdots$</td><td>$\vdots$</td><td>$\vdots$</td><td>$\ddots$</td><td>$\vdots$</td><td>$\vdots$</td></tr></tbody></table></div><p>则可以列出 $Z = g(X,Y)$ 的分布律为：</p><div class="table-container"><table><thead><tr><th>$Z$</th><th>$g(x_1,y_1)$</th><th>$g(x_1,y_2)$</th><th>$\cdots$</th><th>$g(x_i,x_j)$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$P$</td><td>$p_{11}$</td><td>$p_{12}$</td><td>$\cdots$</td><td>$p_{ij}$</td><td>$\cdots$</td></tr></tbody></table></div><h3 id="第二步：同项合并-1"><a href="#第二步：同项合并-1" class="headerlink" title="第二步：同项合并"></a>第二步：同项合并</h3><p>对于表格中如果出现 $g(x_i,y_j) = g(x_t,y_s)$ 且 $i =  t$ 和 $j = s$ 并不同时成立的情形，应该将相同情况的概率累加合并，得到化简以后的分布律。 </p><div class="note info flat"><p>由于过分简单，此处甚至无需例题补充</p></div><h1 id="（肆）二维连续型随机变量的函数的分布"><a href="#（肆）二维连续型随机变量的函数的分布" class="headerlink" title="（肆）二维连续型随机变量的函数的分布"></a>（肆）二维连续型随机变量的函数的分布</h1><p>二维连续型随机变量函数的分布和二维离散型随机变量函数的分布的<strong>定义几乎一致</strong>，此处就不再赘述。</p><p>这部分的重点在于问题的求解技巧上。而<strong>常见的问题就是如何求解因变量的概率密度函数，下面讨论这一问题</strong></p><h2 id="Z-X-Y-的分布"><a href="#Z-X-Y-的分布" class="headerlink" title="$Z = X + Y$ 的分布"></a>$Z = X + Y$ 的分布</h2><p>设二维连续型随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$，则 $Z = X + Y$ 的分布函数为？</p><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><h4 id="普通情况"><a href="#普通情况" class="headerlink" title="普通情况"></a>普通情况</h4><p>随机变量 $Z$ 的分布函数 $F_Z(\gamma)$ 有：</p><script type="math/tex; mode=display">F_Z(\gamma) = \int_{-\infty}^\gamma f_Z(z)dz = P\{Z \le \gamma\}   \tag{6}</script><p>这相当于是对 $(x,y)$ 在某个区域 $x + y \le \gamma$ 内的积分，因此：</p><p>就如下图所示，下图演示的是一个伸缩后的二维正态分布图像，红色平面就是 $\gamma= x+y$ 代表的平面，在这个平面以下的和二维正态分布函数的公共区域都可以视为 $Z$ 的概率密度部分。这个平面以下部分的体积当然也随着 $\gamma$ 的改变而改变。这就是一个关于 $\gamma$ 的函数。对于随机变量 $Z$ 的概率密度的具体形式证明如下：</p><center><img src = https://s2.loli.net/2023/02/14/J54XMueT3hLardS.png width = 50%></center><script type="math/tex; mode=display">P\{Z \le \gamma\} = \underset{x + y\le \gamma}{\iint}f(x,y)dxdy = \int_{-\infty}^\infty\Big[ \int_{-\infty}^{\gamma - y} f(x,y)dx \Big]dy \tag{7}</script><div class="note info flat"><p>对于公式（7）的一个至关重要的理解要点是：应该将公式（7）的积分式中的 $\gamma$ 视为一个“定值”，因为我们是先选定一个 $\gamma$ 然后求解 $\int_{-\infty}^\infty\Big[ \int_{-\infty}^{\gamma - y} f(x,y)dx \Big]dy$，因此在积分过程中应该将 $\gamma$ 视为定值处理。</p></div><p>对于上述式子，由于内层是对 $x$ 的积分，因此在内层积分时可以把 $y$ 视为定值，引入一个新的变量 $z$ ，令 $x = z-y$，可以得到如下变换后的公式。注意内层积分的上限由于换元而改变为 $\gamma$</p><blockquote><p>在我们的证明中，$z$ 是到这步才引入的符号</p></blockquote><script type="math/tex; mode=display">\int_{-\infty}^\infty\Big[ \int_{-\infty}^{\gamma - y} f(x,y)dx \Big]dy = \int_{-\infty}^{\infty}\Big[\int_{-\infty}^\gamma f(z - y,y)dz \Big]dy</script><p>该积分对应的区域边界是 $z &lt; \gamma$ 而 $y$ 不受任何限制，很明显可以无需任何改动地将积分顺序调换，即先积 $y$ 后积 $z$：</p><script type="math/tex; mode=display">\int_{-\infty}^{\infty}\Big[\int_{-\infty}^\gamma f(z - y,y)dz \Big]dy = \int_{-\infty}^\gamma\Big[\int_{-\infty}^{\infty}f(z - y,y)dy \Big]dz\tag{8}</script><p>观察公式（6）（8），比对 $\int_{-\infty}^\gamma f_Z(z)dz$ 和 $\int_{-\infty}^\gamma\Big[\int_{-\infty}^{\infty}f(z - y,y)dy \Big]dz$，很显然，可以得到：</p><script type="math/tex; mode=display">f_Z(z) = \int_{-\infty}^{\infty}f(z - y,y)dy\tag{9}</script><p>由于随机变量 $X$ 与 $Y$ 对称，上述证明过程中我们只要改令 $y = z - x$，立即可得：</p><script type="math/tex; mode=display">f_Z(z) = \int_{-\infty}^{\infty}f(x,z- x)dx\tag{10}</script><h4 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>当随机变量 $X$ 和随机变量 $Y$ 相互独立时，根据 $f(x,y) = f_X(x)f_Y(y)$，式（9）（10）可以写作：</p><script type="math/tex; mode=display">f_Z(z) = \int_{-\infty}^{\infty}f_X(z - y)\cdot f_Y(y)dy\tag{11}</script><script type="math/tex; mode=display">f_Z(z) = \int_{-\infty}^{\infty}f_X(x)\cdot f_Y(z- x)dx\tag{12}</script><div class="note info flat"><p>上式中 $f_X$ 就是随机变量 $X$ 的概率密度，$f_Y$ 就是随机变量 $Y$ 的概率密度</p><p>$f_X(z - y)$ 就是将 $f_X(x)$ 中的 $x$ 整体地换成 $z-y$，$f_Y(z-x)$ 同理</p></div><p>公式（11）和（12）就是著名的卷积公式。</p><h2 id="例题-1-1"><a href="#例题-1-1" class="headerlink" title="例题 1"></a>例题 1</h2><blockquote><p>题目：设两个独立的随机变量 $X$ 和 $Y$ 都服从标准正态分布，求 $Z = X + Y$</p></blockquote><p>已知有正态分布 $X$ 和 $Y$ 的概率密度分别为：$f_X(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}$ 和 $f_Y(y) = \frac{1}{\sqrt{2\pi}}e^{-\frac{y^2}{2}}$</p><p>根据公式（12）立即得到：</p><script type="math/tex; mode=display">f_Z(z) = \int_{-\infty}^\infty f_X(x)\cdot f_Y(z - x)dx = \frac{1}{2\pi}\int_{-\infty}^\infty e^{-\frac{x^2}{2}}e^{-\frac{(z - x)^2}{2}}dx</script><script type="math/tex; mode=display">= \frac{1}{2\pi}e^{-\frac{z^2}{4}}\int_{-\infty}^\infty e^{-(x-\frac{z}{2})^2}dx</script><p>令 $t = x - \frac{z}{2}$，代入上式中换元，得到：</p><script type="math/tex; mode=display">\frac{1}{2\pi} e^{-\frac{z^2}{4}} \int_{-\infty}^\infty e^{-t^2}dt = \frac{1}{2\sqrt{\pi}}e^{-\frac{z^2}{4}}</script><p>所以 $Z$ 服从 $N(0,2)$ 分布。</p><div class="note info flat"><p>本题可以导出更深刻的结论：<strong>有限个相互独立的正态随机变量的线性组合仍然服从正态分布</strong>——</p><p>一般地，对于相互独立的 $X,Y$，若服从 $X\sim N(\mu_1,\sigma_1^2),Y\sim N(\mu_2,\sigma_2^2)$，则 $Z = X + Y$ 仍然服从正态分布，且有：</p><script type="math/tex; mode=display">Z\sim N(\mu_1+\mu_2,\sigma_1^2 + \sigma_2^2)</script></div><h2 id="例题-2-1"><a href="#例题-2-1" class="headerlink" title="例题 2"></a>例题 2</h2><blockquote><p>题目：设 $X_1$ 和 $X_2$ 相互独立且分别仿佛从参数为 $\alpha_1,\beta$ 和 $\alpha_2,\beta$ 的 $\Gamma$ 分布，试证明 $X_1+X_2$ 服从参数为 $\alpha_1+\alpha_2,\beta$ 的 $\Gamma$ 分布</p></blockquote><h2 id="Z-frac-X-Y-的分布"><a href="#Z-frac-X-Y-的分布" class="headerlink" title="$Z = \frac{X}{Y}$ 的分布"></a>$Z = \frac{X}{Y}$ 的分布</h2><h3 id="公式推导-1"><a href="#公式推导-1" class="headerlink" title="公式推导"></a>公式推导</h3><h4 id="普通情况-1"><a href="#普通情况-1" class="headerlink" title="普通情况"></a>普通情况</h4><p>设 $(X,Y)$ 的概率密度为 $f(x,y)$ ，则 $Z = \frac{X}{Y}$ 的分布函数可以写作：</p><script type="math/tex; mode=display">F_{Z}(\gamma) = P\{Z \le \gamma\} = P\{\frac{X}{Y} \le \gamma\}</script><p>对于 $\frac{X}{Y} \le \gamma$ 可以将积分区域视为两个部分：当 $Y \ge 0$ 时积分区域在直线 $x=\gamma y$ 的左侧和 $y = 0$ 的上侧，当 $Y &lt; 0$ 时积分区域在 $x=\gamma y$ 的右侧和 $y = 0$ 的下侧，将两个区域分别命名为 $G_1$ 和 $G_2$</p><center><img src = https://s2.loli.net/2023/02/14/qZ4Y73ojtJP16sy.png width = 40%></center><script type="math/tex; mode=display">F_Z(\gamma) = \iint_{G_1}f(x,y)dxdy + \iint_{G_2}f(x,y)dxdy\tag{13}</script><script type="math/tex; mode=display">= \int_{0}^{\infty}\Big[\int_{-\infty}^{\gamma y}f(x,y)dx\Big]dy + \int_{-\infty}^{0}\Big[\int_{\gamma y}^{\infty}f(x,y)dx\Big]dy\tag{14}</script><p>对于内层积分而言，$y$ 可以视为一个定值，不妨引入一个新变量 $z$ 并令 $x = yz$，代入上式中</p><script type="math/tex; mode=display">\int_{0}^{\infty}\Big[\int_{-\infty}^{\gamma}yf(yz,y)dz\Big]dy + \int_{-\infty}^{0}\Big[\int_{\gamma}^{-\infty}yf(yz,y)dz\Big]dy\tag{15}</script><p>其中积分上限/下限由 $\gamma y$ 变成 $y$ 的原因是积分变量的改变，内层积分多出一个 $y$ 的原因是 $d(yz) = ydz$ （在内层 $y$ 被视为定值），右边的表达式中由于 $y &lt; 0$，因此需要额外将积分上限置为 $-\infty$</p><p>式（15）的积分对应的区域边界是 $z &lt; \gamma$ 而 $y$ 不受任何限制，很明显可以无需任何改动地将积分顺序调换，即先积 $y$ 后积 $z$：</p><script type="math/tex; mode=display">\int_{-\infty}^{\gamma}\int_{0}^{\infty}yf(yz,y)dydz - \int_{-\infty}^{\gamma}\int_{-\infty}^{0}yf(yz,y)dydz\tag{15}</script><script type="math/tex; mode=display">\int_{-\infty}^{\gamma} \Big[\int_{0}^{\infty}yf(yz,y)dy - \int_{-\infty}^{0}yf(yz,y)dy \Big]dz \tag{16}</script><p>根据对于概率密度的定义，比对 $F_Z(\gamma)$ 的定义式和上式，立得：</p><script type="math/tex; mode=display">f(z) = \int_{0}^{\infty}yf(yz,y)dy - \int_{-\infty}^{0}yf(yz,y)dy</script><p>由于在 $(-\infty,0)$ 上 $y&lt;0$，上式可以进一步简写作：</p><script type="math/tex; mode=display">f(z) = \int_{-\infty}^\infty |y|f(yz,y)dy\tag{17}</script><p>对称地，上述概率密度还可以写作：</p><script type="math/tex; mode=display">f(z) = \int_{-\infty}^\infty |x|f(x,xz)dx\tag{18}</script><h4 id="特殊情况-1"><a href="#特殊情况-1" class="headerlink" title="特殊情况"></a>特殊情况</h4><p>当随机变量 $X$ 和随机变量 $Y$ 相互独立时，根据 $f(x,y) = f_X(x)f_Y(y)$，式（17）（18）可以写作：</p><script type="math/tex; mode=display">f(z) = \int_{-\infty}^\infty |y|f_X(yz)f_Y(y)dy =  \int_{-\infty}^\infty |x|f_X(x)f_Y(xz)dx</script><h2 id="Z-XY-的分布"><a href="#Z-XY-的分布" class="headerlink" title="$Z = XY$ 的分布"></a>$Z = XY$ 的分布</h2><h2 id="Z-min-X-Y-和-Z-max-X-Y-的分布"><a href="#Z-min-X-Y-和-Z-max-X-Y-的分布" class="headerlink" title="$Z = min\{X,Y\}$ 和 $Z = max\{X,Y\}$的分布"></a>$Z = min\{X,Y\}$ 和 $Z = max\{X,Y\}$的分布</h2>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第五节：二维随机变量</title>
      <link href="/2022/09/20/cu%E6%A6%82%E7%BB%9F5/"/>
      <url>/2022/09/20/cu%E6%A6%82%E7%BB%9F5/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）二维随机变量及其分布函数"><a href="#（壹）二维随机变量及其分布函数" class="headerlink" title="（壹）二维随机变量及其分布函数"></a>（壹）二维随机变量及其分布函数</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><h3 id="二维随机变量"><a href="#二维随机变量" class="headerlink" title="二维随机变量"></a>二维随机变量</h3><p>设 $E$ 是一个随机试验，它的样本空间是 $S = \{e\}$，设 $X = X(e)$ 和 $Y = Y(e)$ 是定义在 $S$ 上的随机变量，由它们构成的一个向量 $(X,Y)$，叫做二维随机向量或二维随机变量</p><p>换言之，二维随机向量就是将两个不同的事件映射得到的值组合在一起。</p><h3 id="二维随机变量分布函数"><a href="#二维随机变量分布函数" class="headerlink" title="二维随机变量分布函数"></a>二维随机变量分布函数</h3><h4 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h4><p>设 $(X,Y)$ 是二维随机变量，对于任意实数 $x,y$ 二元函数，有：</p><script type="math/tex; mode=display">F(x,y) = P\{(X \le x) \cap (Y \le y)\} = P\{X \le x, Y \le y\}</script><p>则称 $F(x,y)$ 为二维随机变量 $(X,Y)$ 的分布函数，或称为随机变量 $X$ 和 $Y$ 的联合分布函数。</p><p>我们也可以用图像描述二维随机变量分布函数，它的函数值就是随机点落在如图所示区域的概率：</p><center><img src = https://s2.loli.net/2023/02/10/2KJySg1WnDVArXO.png width = 40%></center><p>下面描述两条二维随机变量分布函数的性质，两条性质都可以通过图像理解。</p><h2 id="二维随机变量分布函数的性质"><a href="#二维随机变量分布函数的性质" class="headerlink" title="二维随机变量分布函数的性质"></a>二维随机变量分布函数的性质</h2><h3 id="性质-1：不减性"><a href="#性质-1：不减性" class="headerlink" title="性质 1：不减性"></a>性质 1：不减性</h3><p>若 $F(x,y)$ 是变量 $x$ 和 $y$ 的不减函数，即：</p><ul><li>对于任意固定的 $y$，当 $x_2 &gt; x_1$ 时有 $F(x_2,y) \ge F(x_1,y)$</li><li>对于任意固定的 $x$，当 $y_2 &gt; y_1$ 时有 $F(x, y_2) \ge F(x,y_1)$</li></ul><p>显然从图形中可以看出 $F(x,y)$ 伴随 $x$ 或 $y$ 的增大其概率区域增大，概率区域的增大不一定带来概率的增加（因为 $X$ 和 $Y$ 的取值可能是离散的），但必然不会带来概率的减少。</p><h3 id="性质-2：趋零性"><a href="#性质-2：趋零性" class="headerlink" title="性质 2：趋零性"></a>性质 2：趋零性</h3><p>对于任意的 $x,y$，应该满足：</p><ul><li>$0 \le F(x,y) \le 1$</li><li>$F(-\infty, y) = \lim\limits_{x\rightarrow-\infty} F(x,y) = 0$</li><li>$F(x, -\infty) = \lim\limits_{y\rightarrow -\infty} F(x,y) = 0$</li><li>$F(-\infty, -\infty) = 0$</li><li>$F(\infty, \infty) = 1$</li></ul><p>从图像中理解就是当区域趋近于平面空间的负边界时，其代表的概率值趋于 $0$ ；当区域大小趋近于整个平面空间的大小时，其代表的概率趋于 $1$</p><hr><h1 id="（贰）离散型和连续型二维随机变量"><a href="#（贰）离散型和连续型二维随机变量" class="headerlink" title="（贰）离散型和连续型二维随机变量"></a>（贰）离散型和连续型二维随机变量</h1><h2 id="二维离散型随机变量"><a href="#二维离散型随机变量" class="headerlink" title="二维离散型随机变量"></a>二维离散型随机变量</h2><p>若二维随机变量 $(X,Y)$ 所取得可能值时有限对或无限可列多对，则称 $(X,Y)$ 为二维离散型随机变量</p><p>将 $(X,Y)$ 得所有可能取值记为 $(x_i, y_i)$，记 $P\{X = x_i,Y = y_i\} = p_{ij}$ </p><p>则称此为二维离散型随机变量 $(X,Y)$ 的分布律，或随机变量 $X$ 和 $Y$ 的联合分布律，它们满足：</p><ul><li>$p_{ij} \ge 0$</li><li>$\sum_{i = 1}^{\infty}\sum_{j = 1}^\infty p_{ij} = 1$</li></ul><p>二维离散型随机变量的分布函数归纳为：</p><script type="math/tex; mode=display">F(x,y) = \sum_{x_i \le x}\sum_{y_j \le y}p_{ij}</script><h2 id="二维连续型随机变量"><a href="#二维连续型随机变量" class="headerlink" title="二维连续型随机变量"></a>二维连续型随机变量</h2><h3 id="二维连续型随机变量定义"><a href="#二维连续型随机变量定义" class="headerlink" title="二维连续型随机变量定义"></a>二维连续型随机变量定义</h3><p>对于二维随机变量 $(X,Y)$ 的分布函数 $F(X,Y)$，如果存在非负的函数 $f(x,y)$ 使对于任意 $x,y$ 均有：</p><script type="math/tex; mode=display">F(\alpha,\beta) = \int_{-\infty}^\beta\int_{-\infty}^\alpha f(x,y)dxdy</script><p>则称 $(X,Y)$ 是连续的二维随机变量，函数 $f(x,y)$ 称为二维随机变量 $(X,Y)$ 的概率密度，或者称为随机变量 $X$ 和 $Y$ 的联合概率密度。</p><p>同样，连续型二维随机变量是二维随机变量概率密度中伴生的概念，二者密不可分。</p><div class="note info flat"><p>在很多教科书中上述公式是这么写的：</p><script type="math/tex; mode=display">F(x,y) = \int_{-\infty}^y\int_{-\infty}^x f(x,y)dxdy</script><p>如果你有某些严谨性上的“洁癖”的话，你会发现上面的公式简直漏洞百出，变量上限、函数 $f(x,y)$ 和积分变量都出现了 $x$，但大家习惯并接受了这样的表达</p><p>本系列笔记决定采用新的符号习惯，来规避传统写带来的种种混淆和误区，同时又避免和传统差别过大：</p><ul><li>对于一元函数的积分，积分变量写作 $dt$，积分上限仍使用 $x$</li><li>对于二元函数的积分，积分变量仍使用 $dx$ 和 $dy$，而将积分上限修改为 $\alpha$ 和 $\beta$</li><li><strong>在不作积分时</strong>，一元函数概率密度和分布函数仍分别写作 $f(x)$ 和 $F(x)$，二元函数概率密度和分布函数仍分别写作 $f(x,y)$ 和 $F(x,y)$</li></ul></div><h3 id="二维连续型随机变量概率密度的性质"><a href="#二维连续型随机变量概率密度的性质" class="headerlink" title="二维连续型随机变量概率密度的性质"></a>二维连续型随机变量概率密度的性质</h3><h4 id="性质-1：非负性"><a href="#性质-1：非负性" class="headerlink" title="性质 1：非负性"></a>性质 1：非负性</h4><script type="math/tex; mode=display">f(x,y) \ge 0</script><h4 id="性质-2：归一性"><a href="#性质-2：归一性" class="headerlink" title="性质 2：归一性"></a>性质 2：归一性</h4><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty} f(x,y)dxdy = F(\infty, \infty) = 1</script><h4 id="性质-3：几何意义"><a href="#性质-3：几何意义" class="headerlink" title="性质 3：几何意义"></a>性质 3：几何意义</h4><p>设 $G$ 是 $xoy$ 平面上的一个区域，则点 $(X,Y)$ 落在区域内的概率为</p><script type="math/tex; mode=display">P\{(X,Y)\in G\} = \underset{G}{\iint} f(x,y) dxdy = F(X,Y)</script><p>事实上，$f(X,Y)$ 对应于三维空间的一个曲面，这个曲面正下方的体积之和应该为 $1$：</p><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f(x,y)dxdy = 1</script><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><p>设 $D$ 是平面上的有界区域，其面积为 $S$，若二维随机变量 $(X,Y)$ 具有概率密度：</p><script type="math/tex; mode=display">f(x,y) = \left\{    \begin{aligned}        &\frac{1}{S},\;\;\; (x,y) \in D\\        &0,\;\;\; otherwise    \end{aligned}\right.</script><p>则称 $(u,v)$ 在 $D$ 上服从均匀分布。</p><h3 id="二维正态分布"><a href="#二维正态分布" class="headerlink" title="二维正态分布"></a>二维正态分布</h3><p>若二维随机变量 $(X,Y)$ 具有概率密度：</p><script type="math/tex; mode=display">f(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1 - \rho^2}}e^{\frac{-1}{2(1-\rho^2)}\big[ \frac{(x-\mu_1)^2}{\sigma_1^2} - \frac{2\rho(x - \mu_1)(y - \mu_2)}{\sigma_1\sigma_2}+\frac{(y - \mu_2)^2}{\sigma_2^2} \big]}</script><p>其中 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 均为常数，且 $\sigma_1,\sigma_2 &gt; 0,\;\rho \in (-1,1)$，则称二维随机变量 $(X,Y)$ 服从参数为 $\mu_1,\mu_2,\sigma_1,\sigma_2,\rho$ 的二维正态分布，记作：</p><script type="math/tex; mode=display">(X,Y) \sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)</script><p>二维随机变量的函数图像如下所示：</p><center><img src = https://s2.loli.net/2023/02/10/X5v6uEwIZF9AcJD.png width = 45%></center><div class="note info flat"><p>为了不致整体结构过于丑陋，二维正态分布的概率密度也往往如下表示：</p><script type="math/tex; mode=display">f(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1 - \rho^2}}\cdot exp\{\frac{-1}{2(1-\rho^2)}\big[ \frac{(x-\mu_1)^2}{\sigma_1^2} - \frac{2\rho(x - \mu_1)(y - \mu_2)}{\sigma_1\sigma_2}+\frac{(y - \mu_2)^2}{\sigma_2^2} \big]\}</script></div><hr><h1 id="（叁）二维随机变量的边缘分布"><a href="#（叁）二维随机变量的边缘分布" class="headerlink" title="（叁）二维随机变量的边缘分布"></a>（叁）二维随机变量的边缘分布</h1><h2 id="基本定义-2"><a href="#基本定义-2" class="headerlink" title="基本定义"></a>基本定义</h2><p>设 $F(x,y)$ 为随机变量 $(X,Y)$ 的分布函数，则 $F(x,y) = F\{X \le x, Y \le y\}$，令 $y \rightarrow \infty$，有：</p><script type="math/tex; mode=display">F(x,\infty) = P\{X \le x\} = P\{X \le x, Y < \infty\}</script><p>我们将 $F(x,\infty)$ 记为 $F_X(x)$ ，并称为随机变量 $(X,Y)$ 关于 $X$ 的边缘分布函数。同理，对于随机变量 $(X,Y)$ 关于 $Y$ 的边缘分布函数有：</p><script type="math/tex; mode=display">F_Y(y) = F(\infty, y) = P\{X < \infty, y\le y\} = P\{Y \le y\}</script><h2 id="离散型随机变量的边缘分布律"><a href="#离散型随机变量的边缘分布律" class="headerlink" title="离散型随机变量的边缘分布律"></a>离散型随机变量的边缘分布律</h2><p>离散型随机变量的边缘分布律实际上就是固定一个维度的变量，将另一个维度的变量全部累加，定义如下：</p><p>设二维离散型随机变量 $(X,Y)$ 的联合分布律为：$P(X = x_i, Y = y_i) = p_{ij},\;\;\; i,j =1,2,\cdots$，定义 $p_{i\cdot}$ 和 $p_{\cdot j}$ 如下：</p><script type="math/tex; mode=display">\; p_{i\cdot} = \sum_{j = 1}^\infty p_{ij} = P\{X = x_i\},\;\;\;p_{\cdot j} = \sum_{j =1}^\infty p_{ij} = P\{Y = y_i\}</script><p>分别称 $p_{i\cdot}$ 和 $p_{\cdot j}$ 为离散型随机变量 $(X,Y)$ 关于 $X$ 和关于 $Y$ 的边缘分布律</p><p>实际上 $p_{i\cdot}$ 和 $p_{\cdot j}$ 也是一些离散的变量，因此，离散型随机变量的边缘分布函数可以定义如下：</p><script type="math/tex; mode=display">F_X(x) = F(x, \infty) = \sum_{x_i \le x} p_{i\cdot} = \sum_{x_i \le x}\sum_{j =1}^\infty p_{ij}</script><script type="math/tex; mode=display">F_Y(y) = F(\infty, y) = \sum_{y_j \le y}p_{\cdot j} = \sum_{y_j \le y}\sum_{i = 1}^\infty p_{ij}</script><p>同时，应该注意到联合分布律和边缘分布律的区别，二维离散型随机变量的联合分布律应该是一个二维的表格，而它的边缘分布律是两个一维的表格。比如下面的上下两图分别表示一个离散型分布的联合分布和边缘分布</p><center><img src = https://s2.loli.net/2023/02/10/iGdhcoU9QKtRrlE.png></center><center><img src = https://s2.loli.net/2023/02/10/cdJBHqwu8oaZMXC.png></center><p><img src="images/4.png" alt=""></p><h2 id="连续型随机变量的边缘分布律"><a href="#连续型随机变量的边缘分布律" class="headerlink" title="连续型随机变量的边缘分布律"></a>连续型随机变量的边缘分布律</h2><h3 id="基本定义-3"><a href="#基本定义-3" class="headerlink" title="基本定义"></a>基本定义</h3><p>对于连续型随机变量 $(X,Y)$，设它的概率密度为 $f(x,y)$，则变量 $X$ 的边缘分布函数 $F_X(x)$ 被定义为：</p><script type="math/tex; mode=display">F_X(\alpha) = F(\alpha,\infty) = \int_{-\infty}^\alpha\big[ \int_{-\infty}^\infty f(x,y)dy\big]dx</script><p>根据先前对连续型随机变量概率密度的定义，可知关于 $X$ 的边缘分布概率密度函数 $f_X(x)$ 有：</p><script type="math/tex; mode=display">F_X(\alpha) = \int_{-\infty}^\alpha f_X(x)dx</script><p>结合以上两式马上可以得出 $X$ 的边缘概率密度为：</p><script type="math/tex; mode=display">f_X(x) = \int_{-\infty}^\infty f(x,y)dy</script><p>同理这套公式对于 $Y$ 的形式如下：</p><script type="math/tex; mode=display">F_Y(\beta) = F(\infty, \beta) = \int_{-\infty}^\beta\big[ \int_{-\infty}^\infty f(x,y)dx \big]dy = \int_{-\infty}^{\beta}f_Y(y)dy</script><p>对于边缘概率密度的理解，事实上可以联系离散型随机变量的联合分布律，当我们将 $x$ 取为某个值 $x_0$ 时，将 $y$ 全部积分起来，就对应于这个 $x_0$ 处的概率，它应该是一个和 $x$ 有关的函数，如果用体积代表概率的话，我们可以把它视为一个切面对应的体积（理论上为 $0$，但是可以通过 $x$ 方向上的积分叠加）</p><h3 id="实例：二维正态分布的边缘概率密度函数"><a href="#实例：二维正态分布的边缘概率密度函数" class="headerlink" title="实例：二维正态分布的边缘概率密度函数"></a>实例：二维正态分布的边缘概率密度函数</h3><script type="math/tex; mode=display">f(x,y) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1 - \rho^2}}\cdot exp\{\frac{-1}{2(1-\rho^2)}\big[ \frac{(x-\mu_1)^2}{\sigma_1^2} - \frac{2\rho(x - \mu_1)(y - \mu_2)}{\sigma_1\sigma_2}+\frac{(y - \mu_2)^2}{\sigma_2^2} \big]\}</script><script type="math/tex; mode=display">f_X(x) = \int_{-\infty}^\infty f(x,y)dy</script><p>观察上式，我们先对 $exp$ 的大括号中的内容进行处理：</p><script type="math/tex; mode=display">\frac{(x-\mu_1)^2}{\sigma_1^2} - \frac{2\rho(x - \mu_1)(y - \mu_2)}{\sigma_1\sigma_2}+\frac{(y - \mu_2)^2}{\sigma_2^2}</script><script type="math/tex; mode=display">= \frac{(1 - \rho^2)(x-\mu_1)^2}{\sigma_1^2} + (\frac{\rho(x - \mu_1)}{\sigma_1} - \frac{y - \mu_2}{\sigma_2})^2</script><p><strong>转化后式子的前一部分和 $dy$ 无关，因此可以直接提取到积分符号外</strong>，如下：</p><script type="math/tex; mode=display">f_X(x) = \frac{1}{2\pi\sigma_1\sigma_2\sqrt{1 - \rho^2}}\cdot e^{-\frac{(x - \mu_1)^2}{2\sigma_1^2}} \int_{-\infty}^\infty exp\{\frac{-1}{2(1-\rho^2)}\cdot(\frac{\rho(x - \mu_1)}{\sigma_1} - \frac{y - \mu_2}{\sigma_2})^2\} dy</script><p>将关注点放在积分符号后的部分，我们用还原法简化公式，不妨设 $t$ 满足：</p><script type="math/tex; mode=display">t = \frac{1}{\sqrt{1 - \rho^2}}(\frac{y - \mu_2}{\sigma_2} - \rho\frac{x - \mu_1}{\sigma_1})</script><script type="math/tex; mode=display">f_X(x) = \frac{1}{2\pi \sigma_1} e^\frac{-(x - \mu_1)^2}{2\sigma_1^2}\int_{-\infty}^\infty e^\frac{-t^2}{2}dt</script><p>其中 $\int_{-\infty}^\infty e^\frac{-t^2}{2}dt$ 实际上就是标准正态分布概率密度函数的 $\sqrt{2\pi}$ 倍，又已知 $\int_{-\infty}^\infty \frac{1}{\sqrt{2\pi}} e^\frac{-t^2}{2}dt = 1$，故有：</p><script type="math/tex; mode=display">f_X(x) = \frac{1}{\sqrt{2\pi}\sigma_1} e^\frac{-(x - \mu_1)^2}{2\sigma_1^2}</script><p>它就是一个一维的正态分布概率密度函数。因此可以下结论：二维概率密度函数的边缘概率密度函数就是一维正态分布概率密度函数。从几何的观点看，就是说二维正态分布边缘概率密度曲面的沿 $xoz$ 或 $yoz$ 平面的切面都是正态分布曲线。</p><div class="note warning flat"><p>上述结论的逆命题不一定成立，比如：</p><script type="math/tex; mode=display">f(x,y) = \frac{1}{2\pi}e^{-\frac{x^2 + y^2}{2}}(1 + sinxsiny)</script><p>这个概率密度函数的边缘概率密度函数是标准正态分布，其本身却不是二维正态分布概率密度函数</p></div><hr><h1 id="（肆）二维随机变量的条件分布"><a href="#（肆）二维随机变量的条件分布" class="headerlink" title="（肆）二维随机变量的条件分布"></a>（肆）二维随机变量的条件分布</h1><p>条件分布是基于边缘分布衍生出的概念，边缘分布中我们已经得到了某一维度为定值时另一维度的概率分布情况，条件分布就是以此为基础定义的。</p><h2 id="离散型随机变量的条件分布"><a href="#离散型随机变量的条件分布" class="headerlink" title="离散型随机变量的条件分布"></a>离散型随机变量的条件分布</h2><p>设 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P\{Y = y_i\} &gt; 0$，则称：</p><script type="math/tex; mode=display">P\{X = x_i| Y= y_i\} = \frac{P\{X = x_i, Y=  y_i\}}{P\{Y=  y_i\}} = \frac{p_{ij}}{p_{\cdot j}} = \frac{p_{ij}}{\sum_{i = 1}^n p_{ij}}</script><p>这个式子是 $Y = y_i$ 条件下随机变量 $X$ 的条件分布律，其中 $i,j = 1,2,\cdots, n$</p><p>这一定义的内涵并不难以理解，我们还可以类似地定义 $X = x_i$ 条件下随机变量 $Y$ 的条件分布律：</p><script type="math/tex; mode=display">P\{Y = y_i | X = x_i\} = \frac{P\{X = x_i, Y = y_i\}}{P\{X = x_i\}} = \frac{p_{ij}}{p_{i\cdot}} = \frac{p_{ij}}{\sum_{j = 1}^n p_{ij}}</script><div class="note info flat"><p>两个等式的最后一个表达式都只给出有限的累加形式（上限为 $n$），实际上无限形式也只需要将 $n$ 替换为 $\infty$ 即可，此处不再赘述</p></div><h2 id="连续型随机变量的条件分布"><a href="#连续型随机变量的条件分布" class="headerlink" title="连续型随机变量的条件分布"></a>连续型随机变量的条件分布</h2><h3 id="条件概率密度函数"><a href="#条件概率密度函数" class="headerlink" title="条件概率密度函数"></a>条件概率密度函数</h3><p>设二维连续型随机变量 $(X,Y)$ 的概率密度为 $f(x,y)$，$(X,Y)$ 关于 $Y$ 的边缘概率密度为 $f_Y(y)$ 。若对于固定的 $y$，$f_Y(y) &gt; 0$ ，则称 $\frac{f(x,y)}{f_Y(y)}$ 为在 $Y = y$ 的条件下 $X$ 的条件概率密度，记为： </p><script type="math/tex; mode=display">f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)} = \frac{f(x,y)}{\int_{-\infty}^\infty f(x,y)dx}</script><p>同理我们定义 $X = x$ 的条件下 $Y$ 的条件概率密度（$f_X(x) &gt; 0$），如下：</p><script type="math/tex; mode=display">f_{Y|X}(y|x) = \frac{f(x,y)}{f_X(x)} = \frac{f(x,y)}{\int_{-\infty}^\infty f(x,y)dy}</script><p>对上述第一个定义式进行变换，很容易能够看出它的概率本质：</p><script type="math/tex; mode=display">f_{X|Y}(x|y)dx = \frac{f(x,y)dxdy}{f_Y(y)dy} \approx \frac{P\{x\le X < x + dx, y \le Y \le y+dy\}}{P\{y \le Y \le y+dy\}}</script><script type="math/tex; mode=display">= P \{ x \le X \le x + dx | y \le Y < y+dy \}</script><p>也就是说，对于很小的 $dx$ 和 $dy$，$f_{X|Y}(x|y)dx$ 表示已知 $Y$ 取值于 $y$ 和 $y+dy$ 之间的条件下，$X$ 取值于 $x$ 和 $x+dx$ 之间的概率。</p><p>事实上，联系离散型随机变量条件分布进行理解即可，就是将其中一维累加作为分母视为当另一维是定值时的概率。例如将 $f(x,y)$ 对 $x$ 累加就视为 $y$ 为定值时的概率 $f_Y(y)$（当然这个概率随着 $x$ 的取值不同而变化）。然后用 $x$ 为任意值时 $y$ 为定值时的概率 $f(x,y)$ 除以 $f_Y(y)$ 就得到在 $Y = y$ 的情况下，$X = x$ 的概率</p><div class="note info flat"><p>事实上，这里的符号表述中 $\frac{f(x,y)}{f_Y(y)}$ 并无法突出 $y$ 为定值的观点，可以改写为 $\frac{f(x,y_0)}{f_Y(y_0)}$ 以强调这是在 $Y = y_0$ 时 $X = x$ 的概率，但这种写法又无法明确体现 $y_0$ 实际上可以取任意令 $f_Y(y) \ne 0$ 的任意值，因此我们还是选择使用原来的写法。</p></div><h3 id="条件概率分布函数"><a href="#条件概率分布函数" class="headerlink" title="条件概率分布函数"></a>条件概率分布函数</h3><p>根据上述对于条件概率密度函数的定义，我们可以定义在 $Y = y$ 的条件下 $X$ 的条件概率分布函数如下：</p><script type="math/tex; mode=display">F_{X|Y}(\alpha|\beta) = P\{X \le \alpha | Y = \beta\} = \int_{-\infty}^\alpha f_{X|Y}(x|\beta)dx</script><script type="math/tex; mode=display">= \int_{-\infty}^\alpha\frac{f(x,\beta)}{f_Y(\beta)}dx = \int_{-\infty}^\alpha\frac{f(x,\beta)}{\int_{-\infty}^\infty f(x,\beta)dx}dx</script><p>同理可以定义 $X = \alpha$ 的条件下 $Y$ 的条件分布概率如下：</p><script type="math/tex; mode=display">F_{Y|X}(y|x) = P\{Y \le \beta|X = \alpha\} = \int_{-\infty}^\beta f_{Y|X}(y|\alpha)dy</script><script type="math/tex; mode=display">= \int_{-\infty}^\beta\frac{f(x,y)}{f_X(x)}dy = \int_{-\infty}^\beta\frac{f(\alpha,y)}{\int_{-\infty}^\infty f(\alpha,y)dy}dy</script><div class="note info flat"><p>对于上述式子，$\alpha$ 和 $\beta$ 实际上都是变量，但是在求解变上限的定积分时，我们可以将它们理解为常量，因为<strong>它们与积分变量无关</strong>，这是很重要的一点，原有的表示方式（以下式子）往往容易引起误会。</p><script type="math/tex; mode=display">\int_{-\infty}^x\frac{f(x,y)}{f_Y(y)}dx = \int_{-\infty}^x\frac{f(x,y)}{\int_{-\infty}^\infty f(x,y)dx}dx</script><p>我们对条件分布函数的定义是在对条件概率密度函数之后的，因为条件概率分布函数的定义并不能直接由原有条件概率的定义直接推出，否则会出现如下这样理解上的悖论：</p><script type="math/tex; mode=display">F_{Y|X}(y|x) = \frac{P\{Y \le y|X = x\}}{P\{X = x\}}</script><p>上述式子事实上是错误的，因为对于连续型变量而言 $P\{X = x\}$ 为 $0$，分母为 $0$ 是没有意义的。</p><p>所以连续型二位随机变量的条件分布函数采用了积分的方式来定义.</p></div><h3 id="实例：二维正态分布的条件密度"><a href="#实例：二维正态分布的条件密度" class="headerlink" title="实例：二维正态分布的条件密度"></a>实例：二维正态分布的条件密度</h3><p>设 $(X,Y)\sim N(\mu_1,\mu_2,\sigma_1^2,\sigma_2^2,\rho)$，求 $f_{X|Y}(x|y)$ 和 $f_{Y|X}(y|x)$</p><p>在<a href="#实例二维正态分布的边缘概率密度函数">上文</a>中已经求出二维正态分布的边缘概率密度函数 $f_{X}(x)$ 和 $f_{Y}(y)$，并根据二维正态分布的概率密度函数 $f(x,y)$，很容易导出二维正态分布的条件密度公式：</p><script type="math/tex; mode=display">f_{X|Y}(x|y) = \frac{f(x,y)}{f_Y(y)}</script><script type="math/tex; mode=display">= \frac{\frac{1}{2\pi\sigma_1\sigma_2\sqrt{1 - \rho^2}}\cdot exp\{\frac{-1}{2(1-\rho^2)}\big[ \frac{(x-\mu_1)^2}{\sigma_1^2} - \frac{2\rho(x - \mu_1)(y - \mu_2)}{\sigma_1\sigma_2}+\frac{(y - \mu_2)^2}{\sigma_2^2} \big]\}}{\frac{1}{\sqrt{2\pi}\sigma_1} e^\frac{-(x - \mu_1)^2}{2\sigma_1^2}}</script><p>化简后得到：</p><script type="math/tex; mode=display">f_{X|Y}(x|y)\sim N\Big(\mu_1 + \sigma_1\rho\frac{y - \mu_2}{\sigma_2}, \sigma_1^2(1-  \rho^2)\Big)</script><p>同理可以解出 $f_{Y|X}(y|x)$ 的公式形式：</p><script type="math/tex; mode=display">f_{Y|X}(y|x)\sim N\Big(\mu_2 + \sigma_2\rho\frac{x - \mu_1}{\sigma_1}, \sigma_2^2(1-  \rho^2)\Big)</script><p>特殊的，对于二维正态分布 $N(0,0,1,1,\rho)$，有：</p><script type="math/tex; mode=display">\left\{    \begin{aligned}        &\Phi_{X|Y} \sim N(\rho y, 1 - \rho^2)\\        &\Phi_{Y|X} \sim N(\rho x, 1 - \rho^2)    \end{aligned}\right.</script><hr><h1 id="（伍）相互独立的随机变量"><a href="#（伍）相互独立的随机变量" class="headerlink" title="（伍）相互独立的随机变量"></a>（伍）相互独立的随机变量</h1><h2 id="随机变量的相互独立性"><a href="#随机变量的相互独立性" class="headerlink" title="随机变量的相互独立性"></a>随机变量的相互独立性</h2><h3 id="基本定义-4"><a href="#基本定义-4" class="headerlink" title="基本定义"></a>基本定义</h3><p>设 $F(X,Y)$ 是二维随机变量 $(X,Y)$ 的分布函数，$F_X(x)$ 和 $F_Y(y)$ 是其边缘分布函数。则若对于所有 $x,y$ 均有：</p><script type="math/tex; mode=display">P\{X\le x, Y \le y\} = P\{X \le x\}\cdot P\{Y \le y\}</script><p>或者写作 $F(x,y) = F_X(x)F_Y(y)$，则称随机变量 $X$ 和 $Y$ 是相互独立的。</p><p>上述公式对于离散型随机变量和连续型随机变量都成立。下面分别针对离散型随机变量和连续型随机变量给出上述公式的具化形式。</p><p>对于离散型随机变量：</p><script type="math/tex; mode=display">F(x,y) = F_X(x)F_Y(y) = \sum_{x_i\le x}p_{i\cdot}\times\sum_{y_j\le y}p_{\cdot j} = \sum_{x_i\le x}\sum_{j =1}^np_{ij} \times \sum_{y_j\le y}\sum_{i = 1}^n p_{ij}</script><blockquote><p>同样，上述式子中的 $n$ 可以替换为无穷。</p></blockquote><p>对于连续型随机变量：</p><script type="math/tex; mode=display">F(\alpha,\beta) = \int_{-\infty}^\alpha\int_{-\infty}^\beta f(x,y)dydx = F_X(x)F_Y(y) = \int_{-\infty}^\alpha f_X(x)dx \cdot \int_{-\infty}^\beta f_Y(y) dy</script><script type="math/tex; mode=display">= \int_{-\infty}^x\Big[\int_{-\infty}^\infty f(x,y)dy\Big]dx \cdot \int_{-\infty}^y \Big[\int_{-\infty}^\infty f(x,y)dx\Big]dy</script><blockquote><p>理解这些式子可以参照 <a href="#连续型随机变量的边缘分布律">前面（点击跳转）</a>讲述过的“一片一片的概率”，它虽然不够严谨但是形象直观</p></blockquote><h3 id="相互独立的随机变量的性质"><a href="#相互独立的随机变量的性质" class="headerlink" title="相互独立的随机变量的性质"></a>相互独立的随机变量的性质</h3><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质 1"></a>性质 1</h4><p>离散型随机变量 $(X,Y)$ 的联合分布律为：</p><script type="math/tex; mode=display">P\{X = i,Y = j\} = p_{ij},\;\;\; i,j = 1,2,\cdots</script><p>并且 $X$ 和 $Y$ 相互独立，则有：</p><script type="math/tex; mode=display">P\{X = x_i, Y = y_i\} = p_{ij} = P\{X = x_i\}\cdot P\{Y = y_i\} = p_{i\cdot}\times p_{\cdot j}</script><h4 id="性质-2"><a href="#性质-2" class="headerlink" title="性质 2"></a>性质 2</h4><p>设连续型随机变量 $(X,Y)$ 的联合概率密度为 $f(x,y)$，边缘概率密度分别为 $f_X(x)$ 和 $f_Y(y)$，若 $X$ 与 $Y$ 相互独立，则有：</p><script type="math/tex; mode=display">f(x,y) = f_X(x)f_Y(y)</script><p>事实上，只要对上文中得到的式子再作一步转化就能得到这个结论：</p><script type="math/tex; mode=display">\int_{-\infty}^\alpha f_X(x)dx \cdot \int_{-\infty}^\beta f_Y(y) dy</script><p>其中 $f_X(x)$ 是与 $dy$ 无关的函数，$f_Y(y)$ 是与 $dx$ 无关的函数，因此两个积分号可以整合到一起：</p><script type="math/tex; mode=display">\int_{-\infty}^\alpha\int_\infty^\beta f_X(x)f_Y(y)dydx</script><h4 id="性质-3"><a href="#性质-3" class="headerlink" title="性质 3"></a>性质 3</h4><p>设 $f(X)$ 和 $g(Y)$ 分别是随机变量 $X$ 和 $Y$ 的函数，如果随机变量 $X$ 和 $Y$ 相互独立，那么 $f(X)$ 和 $g(Y)$ 也相互独立。</p><hr><h1 id="（陆）二维随机变量的推广"><a href="#（陆）二维随机变量的推广" class="headerlink" title="（陆）二维随机变量的推广"></a>（陆）二维随机变量的推广</h1><p>二维随机变量事实上还能推广到高维：</p><p>设 $E$ 是一个随机试验，它的样本空间是 $S = \{e\}$，设 $X_1  =X_1(e),X_2  =X_2(e),X_3  =X_3(e), \cdots,X_n  =X_n(e)$ 是定义在 $S$ 上的随机变量，由他们构成的一个 $n$ 维向量 $(X_1, X_2,X_3,\cdots, X_n)$ 叫做 $n$ 维随机向量或 $n$ 维随机变量。</p><h2 id="n-维随机变量的分布函数"><a href="#n-维随机变量的分布函数" class="headerlink" title="$n$ 维随机变量的分布函数"></a>$n$ 维随机变量的分布函数</h2><p>$n$ 维随机变量 $(X_1, X_2,\cdots, X_n)$ 的分布函数定义为：</p><script type="math/tex; mode=display">P\{X_1 \le \alpha_1, X_2\le \alpha_2,\cdots,X_n\le \alpha_n\}</script><p>其中 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 为任意实数。</p><h2 id="n-维随机变量的概率密度函数"><a href="#n-维随机变量的概率密度函数" class="headerlink" title="$n$ 维随机变量的概率密度函数"></a>$n$ 维随机变量的概率密度函数</h2><p>若存在非负函数 $f(x_1, x_2, \cdots, x_n)$ 使得对于任意实数 $x_1, x_2,\cdots,x_n$ 都有：</p><script type="math/tex; mode=display">F(\alpha_1,\alpha_2,\cdots,\alpha_n) = \int_{-\infty}^{\alpha_n}\int_{-\infty}^{\alpha_{n-1}}\cdots\int_{-\infty}^{\alpha_1}f(x_1,x_2,\cdots,x_n)dx_1dx_2\cdots dx_n</script><p>则称 $f(x_1,x_2,\cdots,x_n)$ 为 $n$ 维随机变量 $(X_1, X_2,\cdots, X_n)$ 的概率密度函数</p><h2 id="n-维随机变量的边缘概率密度函数"><a href="#n-维随机变量的边缘概率密度函数" class="headerlink" title="$n$ 维随机变量的边缘概率密度函数"></a>$n$ 维随机变量的边缘概率密度函数</h2><p>若 $f(x_1,x_2,\cdots,x_n)$ 是 $(X_1,X_2,\cdots,X_n)$ 的概率密度，则 $(X_1,X_2,\cdots,X_n)$ 关于 $X_1$ 的边缘概率密度函数 $f_{X_1}(x_1)$ 如下所示：</p><script type="math/tex; mode=display">f_{X_1}(x_1) = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty}f(x_1,x_2,\cdots,x_n)dx_2dx_3\cdots dx_n</script><p>同理，$(X_1,X_2,\cdots,X_n)$ 关于 $X_1,X_2$ 的边缘概率密度函数 $f_{X_1,X_2}(x_1,x_2)$ 定义如下：</p><script type="math/tex; mode=display">f_{X_1,X_2}(x_1,x_2) = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty}f(x_1,x_2,\cdots,x_n)dx_3dx_4\cdots dx_n</script><h2 id="n-维随机变量的边缘分布函数"><a href="#n-维随机变量的边缘分布函数" class="headerlink" title="$n$ 维随机变量的边缘分布函数"></a>$n$ 维随机变量的边缘分布函数</h2><p>$n$ 维随机变量 $(X_1, X_2,\cdots, X_n)$ 关于 $X_1$ 的边缘分布函数定义如下：</p><script type="math/tex; mode=display">F_{X_1}(\alpha_1) = F(\alpha_1,\infty,\infty,\cdots,\infty)</script><p>这个边缘分布函数实际上就是对 $f_{X_1}(x_1)$ 积分后得到的结果：</p><script type="math/tex; mode=display">F_{X_1}(\alpha_1) = \int_{-\infty}^{\alpha_1}f_{X_1}(x_1)dx_1</script><script type="math/tex; mode=display">= \int_{-\infty}^{\alpha_1}\Big[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty}f(x_1,x_2,\cdots,x_n)dx_2dx_3\cdots dx_n\Big]dx_1</script><p>其它情形类似，诸如下面这个式子就表示 $n$ 维随机变量 $(X_1,X_2,\cdots,X_n)$ 关于 $(X_1,X_2)$ 的边缘分布函数。</p><script type="math/tex; mode=display">F_{X_1,X_2}(\alpha_1,\alpha_2) = F(\alpha_1,\alpha_2,\infty,\infty,\cdots,\infty)</script><script type="math/tex; mode=display">= \int_{-\infty}^{\alpha_2}\int_{-\infty}^{\alpha_1}\Big[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\cdots\int_{-\infty}^{\infty}f(x_1,x_2,\cdots,x_n)dx_2dx_3\cdots dx_n\Big]dx_1dx_2</script><h2 id="n-维随机变量的相互独立性"><a href="#n-维随机变量的相互独立性" class="headerlink" title="$n$ 维随机变量的相互独立性"></a>$n$ 维随机变量的相互独立性</h2><p>若对于所有的 $\alpha_1,\alpha_2,\cdots,\alpha_n$，有：</p><script type="math/tex; mode=display">F(\alpha_1,\alpha_2,\cdots,\alpha_n) = F_{X_1}(\alpha_1)F_{X_2}(\alpha_2)\cdots F_{X_n}(x_n)</script><p>则称随机变量 $X_1,X_2,\cdots,X_n$ 是相互独立的。</p><p>设 $F_1$ 是随机变量 $(X_1,X_2,\cdots,X_m)$ 的分布函数，$F_2$ 是随机变量 $(Y_1,Y_2,\cdots,Y_n)$ 的分布函数，$F$ 是随机变量 $(X_1,X_2,\cdots,X_m,Y_1,Y_2,\cdots,Y_n)$ 的分布函数，如果有：</p><script type="math/tex; mode=display">F(\alpha_1,\alpha_2,\cdots,\alpha_m,\beta_1,\beta_2,\cdots,\beta_n) = F_1(\alpha_1,\alpha_2,\cdots,\alpha_m)\cdot F_2(\beta_1,\beta_2,\cdots,\beta_n)</script><p>则称随机变量 $(X_1,X_2,\cdots,X_m)$ 和随机变量 $(Y_1,Y_2,\cdots,Y_n)$ 相互独立</p><div class="note info flat"><p>重要推论：</p><ul><li>如果随机变量 $(X_1,X_2,\cdots,X_m)$ 和随机变量 $(Y_1,Y_2,\cdots,Y_n)$ 相互独立，则 $X_i$ 和 $X_j$ 也相互独立（$i = 1,2,\cdots,m\;;\;j = 1,2,\cdots,n$）</li><li>如果随机变量 $(X_1,X_2,\cdots,X_m)$ 和随机变量 $(Y_1,Y_2,\cdots,Y_n)$ 相互独立，且 $h,g$ 是连续函数，则 $h(X_1,X_2,\cdots,X_m)$ 和 $g(Y_1,Y_2,\cdots,Y_m)$ 也相互独立。</li></ul></div>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第四节：随机变量及其分布</title>
      <link href="/2022/09/15/cu%E6%A6%82%E7%BB%9F4/"/>
      <url>/2022/09/15/cu%E6%A6%82%E7%BB%9F4/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）随机变量初步"><a href="#（壹）随机变量初步" class="headerlink" title="（壹）随机变量初步"></a>（壹）随机变量初步</h1><h2 id="随机变量的定义"><a href="#随机变量的定义" class="headerlink" title="随机变量的定义"></a>随机变量的定义</h2><p>设 $E$ 是随机变量，它的样本空间是 $S = \{e\}$。如果对于每一个 $e\in S$ ，有一个实数 $X(e)$ 与之对应，则得到一个定义在 $S$ 上的<strong>单值实值函数</strong> $X(e)$，我们称 $X(e)$ 为随机变量</p><h2 id="随机变量的分类"><a href="#随机变量的分类" class="headerlink" title="随机变量的分类"></a>随机变量的分类</h2><ul><li>离散型随机变量：随机变量所取的可能值是有限多个或<strong>无限可列个</strong>, 叫做离散型随机变量</li><li>非离散型随机变量<ul><li>连续型随机变量：随机变量所取的可能值<strong>可以连续地充满某个区间</strong>,叫做连续型随机变量。</li><li>其它类型</li></ul></li></ul><blockquote><p>“任意一个随机变量不是离散型就是连续型的”——错误。</p></blockquote><h2 id="随机游动"><a href="#随机游动" class="headerlink" title="随机游动"></a>随机游动</h2><p>直线上的一个质点，每经过一个单位时间，分别以概率 $p,q$ 向右或向左移动一格，该点在时刻 $0$ 从原点出发，而且每次移动是相互独立的。这个模型就是随机游动模型。</p><p>将直线上的每个格子视为一个状态，随机游动模型就可以看作是以一定概率在若干状态间的转移。</p><p>随机游动的典型模型之一就是赌徒输光问题：</p><p>两个赌徒甲和乙就行赌博，每局甲获胜概率为 $p$，乙获胜概率为 $q$，$p+q = 1$，每一局后负者付 $1$ 元给胜者。假设甲有赌资 $a$ 元，乙有赌资 $b$ 元，两个赌徒都赌到输光为止，求甲输光的概率。</p><p>可以用下图表示甲赌资的随机游动：</p><center><img src = https://s2.loli.net/2023/02/10/rVRM1tjNeZx9D2q.png width = 50%></center><p>设 $f_i = P(B_{i})$ 表示甲有本金 $i$ 元时最后赢下所有 $a+b$ 元赌金的概率。</p><p>已知有 $f_0 = 0$ 和 $f_{a+b} =1$，并且有下式成立：</p><script type="math/tex; mode=display">f_i = pf_{i+1} + qf_{i-1},\;\;\;\forall 1\le i \le a + b - 1</script><script type="math/tex; mode=display">(p+q)f_i = pf_{i+1} + qf_{i-1}</script><script type="math/tex; mode=display">q(f_i - f_{i-1}) = p(f_{i+1} - f_i)</script><script type="math/tex; mode=display">f_{i+1} - f_i = (f_1 - f_0)(\frac{q}{p})^{i-1}</script><ul><li><p>如果 $p = q = \frac{1}{2}$，则 $f_{i+1} - f_i = \frac{i}{c}$ </p></li><li><p>如果 $p \ne q$，则 $f_{i + 1} - f_i = \frac{1 - (p/q)^i}{1 - (p/q)^c}$</p></li></ul><p>因此有 $f_i = f_1\sum_{k = 1}^i(\frac{q}{p})^{k-1}$</p><p>可知甲乙输光的概率分别为 $\frac{b}{a + b}$ 和 $\frac{b}{a + b}$，可见初始成本大者更不容易输光。</p><hr><h1 id="（贰）分布律、分布函数与概率密度"><a href="#（贰）分布律、分布函数与概率密度" class="headerlink" title="（贰）分布律、分布函数与概率密度"></a>（贰）分布律、分布函数与概率密度</h1><h2 id="分布律"><a href="#分布律" class="headerlink" title="分布律"></a>分布律</h2><p>分布律一般针对于离散型随机变量而言，设离散型随机变量 $X$ 的所有可能取值为 $x_k$，$k = 1,2,\cdots$，$X$ 取各个可能值的概率，即事件 $\{X=x_k\}$ 的概率，为：</p><script type="math/tex; mode=display">  P\{X=x_k\} = p_k,\;\;\;k=1,2,\cdots</script><p>称为该离散型随机变量 $X$ 的分布律。</p><p>离散型随机变量的分布律也可以表示为：</p><script type="math/tex; mode=display">X\sim\begin{pmatrix}x_1&x_2&\cdots&x_n&\cdots\\p_1&p_2&\cdots&p_n&\cdots\\  \end{pmatrix}</script><p>或者以表格形式表示为：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$x_1$</th><th>$x_2$</th><th>$\cdots$</th><th>$x_n$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$p_k$</td><td>$p_1$</td><td>$p_2$</td><td>$\cdots$</td><td>$p_n$</td><td>$\cdots$</td></tr></tbody></table></div><h2 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设 $X$ 是一个随机变量，$x$ 是任意实数，函数 $F(x) = P\{X\le x\}$ 称为 $X$ 的分布函数</p><p>分布函数 $F(x)$ 是 $x$ 的一个普通实函数</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul><li><p>$0 \le F(x) \le 1$，$x\in (-\infty, \infty)$</p><blockquote><p>$F(X)$ 实际上也是一个概率，概率的取值范围——$[0,1]$</p></blockquote></li><li><p>$F(x_1) \le F(x_2)$，若 $(x_1&lt;x_2)$</p><blockquote><p>又称为 $F(x)$ 的<strong>不减性</strong>，$\{X\le x_1\}\subset \{X\le x_2\}$ </p></blockquote></li><li><p>$F(-\infty) = \lim\limits_{x\rightarrow -\infty}{F(x)} = \lim\limits_{x\rightarrow -\infty}P\{X\le x\} = 0$</p></li><li>$F(+\infty) = \lim\limits_{x\rightarrow +\infty}{F(x)} = \lim\limits_{x\rightarrow +\infty}P\{X\le x\} = 1$</li><li><p>任一分布函数处处右连续：$\lim\limits_{x\rightarrow x_0^+}F(x) = F(x_0)$</p><blockquote><p>分布函数右连续实际上是一种人为的定义，本系列笔记统一采用这个定义</p></blockquote></li></ul><h2 id="概率密度的定义与性质"><a href="#概率密度的定义与性质" class="headerlink" title="概率密度的定义与性质"></a>概率密度的定义与性质</h2><h3 id="概率密度定义"><a href="#概率密度定义" class="headerlink" title="概率密度定义"></a>概率密度定义</h3><p>如果对于随机变量 $X$ 的分布函数 $F(X)$，存在非负函数，使得对于任意实数 $x$ 有：</p><script type="math/tex; mode=display">F(x) = \int_{-\infty}^x f(t)dt</script><p>则称 $X$ 为<strong>连续型随机变量</strong>，其中 $f(x)$ 称为 $X$ 的概率密度函数，简称概率密度。</p><center><img src = https://s2.loli.net/2023/02/08/Mu6tzw3CvkrhZ7j.png width = 40%></center><h3 id="概率密度性质"><a href="#概率密度性质" class="headerlink" title="概率密度性质"></a>概率密度性质</h3><ul><li><p>$f(t) \ge 0$</p></li><li><p>$\int_{-\infty}^\infty f(t)dt = 1$</p></li><li><p>$P\{x_1 &lt; X &lt; x_2\} = F(x_2) - F(x_1) = \int_{-\infty}^{x_2}f(t)dt - \int_{-\infty}^{x_1}f(t)dt = \int_{x_1}^{x_2}f(t)dt$</p></li><li><p>$P(X \le x) = F(x) = \int_{-\infty}^xf(t)dt$</p></li><li><p>$P(X &gt; x) = \int_{x}^\infty f(t)dt$</p></li><li><p>若 $f(t)$ 在点 $x$ 处连续，则有 $F’(x) = f(x)$</p></li></ul><div class="note info flat"><p>对于最后一条性质，说明如下：</p><script type="math/tex; mode=display">F'(x) = \lim\limits_{\Delta x\rightarrow 0}\frac{F(x+\Delta x) - F(x)}{\Delta x} = \lim\limits_{\Delta x\rightarrow 0}\frac{\int_{x}^{x + \Delta x}f(t)dt}{\Delta x} = f(x)</script><p>其中最后一个等号成立的原因是当 $\Delta x$ 极小时，$\int_{x}^{x + \Delta x}f(t)dt$ 可以看作 $f(x)\Delta x$</p></div><h3 id="连续型随机变量注意点"><a href="#连续型随机变量注意点" class="headerlink" title="连续型随机变量注意点"></a>连续型随机变量注意点</h3><p>连续型随机变量是在概率密度的定义中伴生的概念，二者密不可分。</p><p>和离散型随机变量不同的一点是，对于任何可能值 $a$，连续型变量取值为 $a$ 的概率为 $0$，即 $P\{X = a\} = 0$</p><p>因此，对于连续型随机变量，区间的开闭是无关紧要的：</p><script type="math/tex; mode=display">P\{a \le X \le b\} = P\{a < X \le b\} = P\{a \le X < b\} = P\{a < X < b\}</script><p>由此，对于连续型随机变量，若有 $P\{X = a\} = 0$，并不能推断出 $X = a$ 是不可能事件</p><hr><h1 id="（叁）离散型随机变量的分布"><a href="#（叁）离散型随机变量的分布" class="headerlink" title="（叁）离散型随机变量的分布"></a>（叁）离散型随机变量的分布</h1><h2 id="等可能分布"><a href="#等可能分布" class="headerlink" title="等可能分布"></a>等可能分布</h2><p>如果随机变量 $X$ 的分布律为：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$a_1$</th><th>$a_2$</th><th>$\cdots$</th><th>$a_n$</th></tr></thead><tbody><tr><td>$p_k$</td><td>$\frac{1}{n}$</td><td>$\frac{1}{n}$</td><td>$\cdots$</td><td>$\frac{1}{n}$</td></tr></tbody></table></div><h2 id="两点分布与二项分布"><a href="#两点分布与二项分布" class="headerlink" title="两点分布与二项分布"></a>两点分布与二项分布</h2><h3 id="重复独立试验"><a href="#重复独立试验" class="headerlink" title="重复独立试验"></a>重复独立试验</h3><p>将试验 $E$ 重复进行 $n$ 次，如果各次试验的结果互不影响，即每次试验结果出现的概率都不依赖于其它各次试验的结果，则称这 $n$ 次试验是相互独立的，这一过程称为 $n$ 次重复独立试验</p><h3 id="n-重伯努利试验"><a href="#n-重伯努利试验" class="headerlink" title="$n$ 重伯努利试验"></a>$n$ 重伯努利试验</h3><p>若试验 $E$ 仅有两种可能的结果：$A$ 和 $\overline{A}$，则称 $E$ 是伯努利试验</p><p>将 $E$ 独立地重复进行 $n$ 次，这一过程被称为 $n$ 重伯努利试验</p><h3 id="二项概率公式"><a href="#二项概率公式" class="headerlink" title="二项概率公式"></a>二项概率公式</h3><p>若 $X$ 表示 $n$ 重伯努利公式中事件 $A$ 发生的次数，则 $X$ 所有可能的取值包括 $1,2,3,\cdots,n$</p><p>根据高中排列组合的知识可知，$A$ 在 $n$ 次试验中发生 $k$ 次的概率为 </p><script type="math/tex; mode=display">\begin{pmatrix}n\\k\end{pmatrix}p^k(1-p)^{n-k}</script><p>若将 $1-p$ 记为 $q$，上式可记为 $\begin{pmatrix}n\\k\end{pmatrix}p^kq^{n-k}$，可以列出 $X$ 的分布律表格如下：</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$0$</th><th>$1$</th><th>$\cdots$</th><th>$k$</th><th>$\cdots$</th><th>$n$</th></tr></thead><tbody><tr><td>$p_k$</td><td>$\begin{pmatrix}n\\0\end{pmatrix}p^0q^{n}$</td><td>$\begin{pmatrix}n\\1\end{pmatrix}p^1q^{n-1}$</td><td>$\cdots$</td><td>$\begin{pmatrix}n\\k\end{pmatrix}p^kq^{n-k}$</td><td>$\cdots$</td><td>$\begin{pmatrix}n\\n\end{pmatrix}p^nq^{0}$</td></tr></tbody></table></div><p>这样的分布被称为二项分布，我们将 $X$ 服从 $n$ 次概率为 $p$ 的二项分布记作 $X\sim B(n,p)$。当 $n = 1$ 时，这个二项分布就退化为两点分布。</p><h2 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h2><h3 id="泊松分布定义"><a href="#泊松分布定义" class="headerlink" title="泊松分布定义"></a>泊松分布定义</h3><p>设随机变量的所有可能取的值为 $0,1,2,\cdots$，而取各个值得概率为：</p><script type="math/tex; mode=display">P\{X = k\} = \frac{\lambda^ke^{-\lambda}}{k!},\;\;\; k = 0,1,2,\cdots</script><p>其中 $\lambda &gt; 0$ 是一个常数。当随机变量 $X$ 满足上式，则称 $X$ 服从参数为 $\lambda$ 的泊松分布，记为 $X\sim \pi(\lambda)$ </p><h3 id="泊松定理——从二项分布到泊松分布"><a href="#泊松定理——从二项分布到泊松分布" class="headerlink" title="泊松定理——从二项分布到泊松分布"></a>泊松定理——从二项分布到泊松分布</h3><p>泊松定理提供了一个复杂二项分布的近似化简公式</p><h4 id="泊松定理内容"><a href="#泊松定理内容" class="headerlink" title="泊松定理内容"></a>泊松定理内容</h4><p>泊松定理：若随机变量 $X\sim B(n,p)$ ，则当 $n$ 较大，$p$ 较小时，令 $\lambda = np$，则有：</p><script type="math/tex; mode=display">P\{X = k\} = \begin{pmatrix}n\\k\end{pmatrix}p^k(1-p)^{n-k} \approx \frac{\lambda^k}{k!}e^{-\lambda}</script><div class="note info flat"><p>简记：$B(n,p)\sim \pi(np)$</p></div><h4 id="泊松定理证明"><a href="#泊松定理证明" class="headerlink" title="泊松定理证明"></a>泊松定理证明</h4><script type="math/tex; mode=display">令 \lambda = np，则\; \begin{pmatrix}n\\k\end{pmatrix}p^k(1-p)^{n-k}</script><script type="math/tex; mode=display">= \frac{n(n-1)\cdots (n-k+1)}{k!}p^k(1-p)^{n-k} = \frac{n(n-1)\cdots (n-k+1)}{k!}(\frac{\lambda }{n})^k(1-\frac{\lambda }{n})^{n-k}</script><script type="math/tex; mode=display">= \frac{\lambda^k}{k!}(\frac{n}{n}\cdot\frac{n-1}{n}\cdots\frac{n-k+1}{n})(1-\frac{\lambda}{n})^{n-k}</script><script type="math/tex; mode=display">= \frac{\lambda^k}{k!}(1-\frac{1}{n})(1-\frac{2}{n})\cdots(1-\frac{k-1}{n})(1-\frac{\lambda}{n})^{n-k}</script><script type="math/tex; mode=display">当\; n\rightarrow +\infty\; 时，(1-\frac{1}{n})(1-\frac{2}{n})\cdots(1-\frac{k-1}{n})\rightarrow 1，(1-\frac{\lambda}{n})^{n-k}\rightarrow e^{-\lambda}</script><script type="math/tex; mode=display">故原式趋近于 \;\frac{\lambda^k}{k!}e^{-\lambda}</script><h4 id="泊松定理例题"><a href="#泊松定理例题" class="headerlink" title="泊松定理例题"></a>泊松定理例题</h4><p>保险公司在一天内承保了 $5000$ 张相同年龄, 为期一年的寿险保单, 每人一份. 在合同 有效期内若投保人死亡, 则公司需赔付 $3$ 万元. 设在一年内, 该年龄段的死亡率为 $0.0015$, 且 各投保人是否死亡相互独立. 求该公司对于这批投保人的赔付总额不超过 $30$ 万元的概率 (利用泊松定理计算).</p><p>解：</p><p>依题意，设在这一年中，投保者死亡人数为 $x$，有 $x\sim b(5000, 0.0015)$</p><p>题设等价于要求：投保期内死亡人数不超过 $10$，即：</p><script type="math/tex; mode=display">P(x\le10) = \sum_{k=0}^{10}C^{k}_{5000}(0.0015)^k(1-0.0015)^{5000-k}</script><p>由于 $n$ 较大且 $p$ 较小，因此可以利用泊松定理近似计算，得到：</p><script type="math/tex; mode=display">P(x\le10) \approx \sum_{k=0}^{10}\frac{7.5^ke^{-7.5}}{k!} = 0.8622</script><h2 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h2><h3 id="几何分布定义"><a href="#几何分布定义" class="headerlink" title="几何分布定义"></a>几何分布定义</h3><p>如果一个随机变量 $X$ 的分布律为</p><div class="table-container"><table><thead><tr><th>$X$</th><th>$x_1$</th><th>$x_2$</th><th>$\cdots$</th><th>$x_n$</th><th>$\cdots$</th></tr></thead><tbody><tr><td>$p_k$</td><td>$p$</td><td>$pq$</td><td>$\cdots$</td><td>$pq^{n-1}$</td><td>$\cdots$</td></tr></tbody></table></div><p>其中有 $p + q = 1$</p><h3 id="几何分布成立性证明"><a href="#几何分布成立性证明" class="headerlink" title="几何分布成立性证明"></a>几何分布成立性证明</h3><p>几何分布应该满足：$\sum_{k=0}^\infty p_k = 1$，下面证明这一点：</p><script type="math/tex; mode=display">\sum_{k=0}^\infty p_k = \lim\limits_{n\rightarrow \infty}\sum_{k=0}^np_k = \lim\limits_{n\rightarrow \infty}\sum_{k=0}^n pq^k = p \cdot \lim\limits_{n\rightarrow \infty}\frac{1 - q^n}{1 - q}</script><script type="math/tex; mode=display">= \lim\limits_{n\rightarrow \infty}1 - q^n = 1</script><h3 id="几何分布实际涵义"><a href="#几何分布实际涵义" class="headerlink" title="几何分布实际涵义"></a>几何分布实际涵义</h3><p>几何分布的一种现实意义就是<strong>某种试验“首次成功”的概率</strong>，比如：</p><p>设某批产品的次品率为 $p$ , 对该批产品做有放回的抽样检查 , 直到第一次抽到一只次品为止( 在此之前抽到的全是正品 ), 那么所抽到的产品数 $X$ 是一个随机变量</p><p>设 $A_i$ 表示事件：抽到的第 $i$ 个产品为正品，则：</p><script type="math/tex; mode=display">P\{X = k\} = P(A_1A_2\cdots A_{k-1}\overline{A_k}) = P(A_1)P(A_2)\cdots P(A_{k-1})P(\overline{A_k})</script><script type="math/tex; mode=display">= (1-p)^{k-1}p = q^{k-1}p</script><p>所以 $X$ 服从几何分布</p><hr><h1 id="（肆）连续型随机变量的分布"><a href="#（肆）连续型随机变量的分布" class="headerlink" title="（肆）连续型随机变量的分布"></a>（肆）连续型随机变量的分布</h1><h2 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h2><p>设连续型随机变量 $X$ 具有概率密度：</p><script type="math/tex; mode=display">f(x) = \left\{    \begin{aligned}        &\frac{1}{b-a},\;\;\; if\;\;a<x<b\\        &0,\;\;\; otherwise    \end{aligned}\right.</script><p>则称 $X$ 在区间 $(a,b)$ 上服从均匀分布。记为 $X\sim U(a,b)$</p><p>在区间 $(a,b)$ 上服从均匀分布的随机变量 $X$，落在区间 $(a,b)$ 中任意长度的子区间内的可能性是相同的。</p><p>均匀分布的分布函数应该是三段折线，第一段与 $y = 0$ 重合，第二段 $F(X)$ 从 $0$ 线性增长到 $1$，第三段与 $y = 1$ 重合</p><h2 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h2><h3 id="指数分布的定义"><a href="#指数分布的定义" class="headerlink" title="指数分布的定义"></a>指数分布的定义</h3><p>设连续型随机变量 $X$ 的概率密度为</p><script type="math/tex; mode=display">f(x) = \left\{    \begin{aligned}        &\frac{1}{\theta}e^{-x/\theta},\;\;\; if\;\;x>0\\        &0,\;\;\; otherwise    \end{aligned}\right.</script><p>一些其它文献的指数分布概率密度函数也写作：</p><script type="math/tex; mode=display">f(x) = \left\{    \begin{aligned}        &\lambda e^{-\lambda x},\;\;\; if\;\;x>0\\        &0,\;\;\; otherwise    \end{aligned}\right.</script><h3 id="指数分布概率密度函数的积分"><a href="#指数分布概率密度函数的积分" class="headerlink" title="指数分布概率密度函数的积分"></a>指数分布概率密度函数的积分</h3><p>指数分布概率密度函数的积分就是指数函数的分布函数，我们对如上公式进行积分，过程如下：</p><script type="math/tex; mode=display">F(x) = \int_{-\infty}^xf(t)dt = \int_{-\infty}^00dt + \int_{0}^x\frac{1}{\theta}e^{-t/\theta}dt</script><script type="math/tex; mode=display">= \int_{0}^x e^{-t/\theta}d\frac{t}{\theta} = -e^{-t/\theta}\ \big|_0^x = 1 - e^{-x/\theta}</script><h3 id="指数分布图像"><a href="#指数分布图像" class="headerlink" title="指数分布图像"></a>指数分布图像</h3><p>指数分布概率密度的特点有：</p><ul><li>图像仅分布在第一象限</li><li>是随着 $x$ 的增大，概率密度下降速度变缓，且整体无限趋近于 $0$</li></ul><p>指数分布概率密度（左）和分布函数（右）图像如下所示</p><center><img src = https://s2.loli.net/2023/02/10/x8ZDnCiPGqBtEmA.png width = 40%> <img src = https://s2.loli.net/2023/02/10/5toRHkUYiOGfqPz.png width = 40%></center><p><img src="images/4.png" alt=""></p><h3 id="指数分布的性质——无记忆性"><a href="#指数分布的性质——无记忆性" class="headerlink" title="指数分布的性质——无记忆性"></a>指数分布的性质——无记忆性</h3><p>指数分布的一个重要性质是——“无记忆性”，用公式的形式表示如下：</p><script type="math/tex; mode=display">P\{X > s + t \ |\  X > s\} = P\{X > t\}</script><p>我们仍然可以用零件寿命的例子来理解无记忆性这一性质：</p><p>上述式子的左边代表零件已经使用了 $s$ 个小时后能再用 $t$ 个小时的概率，右边表示零件能使用 $t$ 个小时的概率。两个概率值相等表明：寿命满足指数分布的零件接下来能使用多少小时与先前已经使用的时间数无关。</p><p>该式的证明如下：</p><script type="math/tex; mode=display">P\{X > s + t \ |\  X > s\} = \frac{P\{(X > s + t) \cup (X > s)\}}{P\{X > s\}}</script><script type="math/tex; mode=display">= \frac{P\{X > s + t\}}{P\{X > s\}} = \frac{1 - F(s + t)}{1 - F(s)}</script><script type="math/tex; mode=display">= \frac{e^{-(s +t)/\theta}}{e^{s/\theta}}   = e^{-t/\theta} = 1 - F(t) = P\{X > t\}</script><h2 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h2><h3 id="正态分布的定义"><a href="#正态分布的定义" class="headerlink" title="正态分布的定义"></a>正态分布的定义</h3><p>设连续型随机变量 $X$ 的概率密度为：</p><script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi} \sigma}e^{-\frac{(x - \mu)^2}{2\sigma^2}},\;\;\; x\in (-\infty,+\infty)</script><p>其中 $\mu,\sigma$ 为常数，则称随机变量 $X$ 服从参数为 $\mu,\sigma$ 的正态分布或高斯分布，记作 $X \sim N(\mu, \sigma^2)$</p><h3 id="正态分布密度函数的几何解释"><a href="#正态分布密度函数的几何解释" class="headerlink" title="正态分布密度函数的几何解释"></a>正态分布密度函数的几何解释</h3><p>正态分布概率密度函数有如下特点：</p><ul><li>曲线整体关于 $x = \mu$ 对称</li><li>当 $x = \mu$ 时，$f(x)$ 有最大值 $\frac{1}{\sqrt{2\pi}\sigma}$</li><li>当 $x \rightarrow \pm\infty$ 时，都有 $f(x)\rightarrow 0$</li><li>曲线在 $x = \mu \pm \sigma$ 处有两个拐点（二阶导数等于 $0$ 的点）</li><li>曲线以 $x$ 轴为渐近线</li><li>当固定 $\sigma$，只改变 $\mu$ 的大小时，曲线的形状不变，仅沿 $x$ 轴方向平移，换言之，$\mu$ 仅决定曲线的位置。</li><li>当固定 $\mu$，只改变 $\sigma$ 的大小时，曲线的位置不变，但形状发生改变<ul><li>当 $\sigma$ 越小时，曲线越瘦越高</li><li>当 $\sigma$ 越大时，曲线越矮越胖</li></ul></li></ul><center><img src = https://s2.loli.net/2023/02/10/9PZtra7dNwJUyOs.png width = 40%></center><h3 id="标准正态分布概率密度函数"><a href="#标准正态分布概率密度函数" class="headerlink" title="标准正态分布概率密度函数"></a>标准正态分布概率密度函数</h3><p>当正态分布 $N(\mu,\sigma^2)$ 中的 $\mu =0,\sigma = 1$ 时，这样的正态分布称为标准正态分布，记为 $N(0,1)$，其形式为：</p><script type="math/tex; mode=display">\phi(x) = \frac{1}{\sqrt{2\pi}}e^{-\frac{x^2}{2}}</script><h3 id="标准正态分布概率密度函数的积分"><a href="#标准正态分布概率密度函数的积分" class="headerlink" title="标准正态分布概率密度函数的积分"></a>标准正态分布概率密度函数的积分</h3><p>标准正态分布概率密度函数 $e^{-x^2}$ 实际上并非初等函数，它的积分可以采用以下技巧：</p><p>思路就是使用两个自变量（实际上代表同一个公式）构造出二重积分的形式，然后利用平面坐标到极坐标的转化</p><script type="math/tex; mode=display">I = \int_{-\infty}^\infty f(t) = 2\int_{0}^\infty f(t) = 2\int_{0}^\infty \frac{1}{\sqrt{2\pi}}e^{-\frac{t^2}{2}}dt  = 2\int_{0}^\infty\frac{1}{\sqrt{2\pi}}e^{-\frac{s^2}{2}}ds</script><script type="math/tex; mode=display">\frac{I^2}{4} = \int_{0}^\infty\int_{0}^\infty e^{-t^2 - s^2}dtds</script><p>令 $x = rcos\theta, t = rsin\theta$，根据雅可比行列式转换可以得到：</p><script type="math/tex; mode=display">\frac{I^2}{4} = \int_0^\frac{\pi}{2}d\theta \int_{0}^\infty e ^{-r^2}rdr</script><p>化简为上述形式后，这个积分的计算变得简单，很容易得到结果为 $I = 1$，证毕。</p><p>上述积分方法只使用与从 $-\infty$ 到 $\infty$ 的积分，更一般的，如果我们希望求解的是标准正态分布的分布函数 $F(X)$，一般利用 <code>MATLAB</code> 计算或直接查阅标准正态分布表。</p><h3 id="其它概念"><a href="#其它概念" class="headerlink" title="其它概念"></a>其它概念</h3><h4 id="3-sigma-法则"><a href="#3-sigma-法则" class="headerlink" title="$3\ \sigma$ 法则"></a>$3\ \sigma$ 法则</h4><p>正态分布的正态变量取值范围在 $(-\infty,+\infty)$，但是计算表明它的值落在区间 $(\mu - 3\sigma, \mu + 3\sigma)$ 几乎是肯定的是，这就是 $3\ \sigma$ 法则。</p><h4 id="上-alpha-分位"><a href="#上-alpha-分位" class="headerlink" title="上 $\alpha$ 分位"></a>上 $\alpha$ 分位</h4><p>设 $X \sim N(0,1)$，若 $z_\alpha$ 满足条件：</p><script type="math/tex; mode=display">P\{X > z_\alpha\} = \alpha,\;\;\;\alpha\in(0,1)</script><p>则称 $z_\alpha$ 是标准正态分布的上 $\alpha$ 分位。标准正态分布的上 $\alpha$ 分位和上 $1- \alpha$ 分位应该是关于 $y$ 轴对称的。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论第三节：条件概率与事件独立性</title>
      <link href="/2022/09/08/cu%E6%A6%82%E7%BB%9F3/"/>
      <url>/2022/09/08/cu%E6%A6%82%E7%BB%9F3/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）条件概率初步"><a href="#（壹）条件概率初步" class="headerlink" title="（壹）条件概率初步"></a>（壹）条件概率初步</h1><h2 id="条件概率定义"><a href="#条件概率定义" class="headerlink" title="条件概率定义"></a>条件概率定义</h2><p>设 $A,B$ 是两个事件，且 $P(A)&gt;0$ ，称：</p><script type="math/tex; mode=display">    P(B|A) = \frac{P(BA)}{P(A)}</script><p>为在事件 $A$ 发生的条件下事件 $B$ 发生的条件概率。</p><p>从图形化的角度，这个公式事实上很好理解：</p><center><img src = https://s2.loli.net/2023/02/08/OqSXnFdiZkG85Hr.png width = 35%></center><p>$P(B|A)$ 实际上就表示阴影部分的面积和蓝色部分面积的比值</p><h2 id="条件概率性质"><a href="#条件概率性质" class="headerlink" title="条件概率性质"></a>条件概率性质</h2><h3 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h3><ul><li>非负性：$P(B|A)\ge 0$</li><li>规范性：$P(S|B) = 1$，$P(B|S) = P(B)$，$P(\emptyset|B) = 0$（其中 $S$ 表示样本空间）</li><li><strong>可列可加性</strong>：设 $B_1,B_2,\cdots$ 是两两不相容的事件，则有：<script type="math/tex; mode=display">  P(\bigcup^\infty_{i=1}B_i|A) = \sum_{i=1}^\infty P(B_i|A)</script><blockquote><p>条件概率的可列可加性由条件概率的定义和概率的可列可加性即可证明</p></blockquote></li><li><strong>容斥原理</strong>：$P(A\cup B|C) = P(A|C) + P(B|C) - P(AB|C)$ <blockquote><p>条件概率可列可加性的推论</p></blockquote></li><li>减法：$P(A-B|C) = P(A|C) - P(B|C)$ <blockquote><p>条件概率可列可加性的推论</p></blockquote></li><li>补集：$P(A|B) = P(S-\overline{A}|B) = P(S|B) - P(\overline{A}|B) = 1 - P(\overline{A}|B)$</li></ul><h3 id="例题解析"><a href="#例题解析" class="headerlink" title="例题解析"></a>例题解析</h3><div class="note success flat"><p>灵活使用<strong>容斥原理、样本空间的划分、事件的否定</strong>是解题关键之一。</p></div><p>已知 $P(\overline{A}) = 0.3$ ，$P(B) = 0.4$ ，$P(A\overline{B}) = 0.5$ ，求条件概率 $P(B|A\cup \overline{B})$</p><p>解：</p><script type="math/tex; mode=display">P(A\cup \overline{B}) = P(A) + P(\overline{B}) - P(A\overline{B}) = 0.8</script><script type="math/tex; mode=display">P(B|A\cup \overline{B}) = \frac{P(AB)}{P(A\cup \overline{B})} = 0.25</script><blockquote><p>分析：直接利用条件概率的定义列式求解，其中 </p><script type="math/tex; mode=display">P(B|A\cup\overline{B}) = \frac{P(B\cap (A\cup\overline{B}))}{P(A\cup \overline{B})} = \frac{P(AB)}{P(A\cup\overline{B})}</script></blockquote><h1 id="（贰）乘法定理"><a href="#（贰）乘法定理" class="headerlink" title="（贰）乘法定理"></a>（贰）乘法定理</h1><h2 id="乘法定理基本定义"><a href="#乘法定理基本定义" class="headerlink" title="乘法定理基本定义"></a>乘法定理基本定义</h2><p>实际上，乘法定理就是条件概率定义式的变形：</p><p>设 $P(A) &gt; 0$，则有 $P(AB) = P(B|A)P(A)$.</p><div class="note info flat"><p>这个公式的变形在后面的贝叶斯公式中起到至关重要的作用：</p><script type="math/tex; mode=display">P(AB) = P(B|A)P(A) = P(A|B)P(B)</script></div><p>乘法定理支持符合运算：设 $A,B,C$ 为事件，且 $P(AB)&gt;0$ ，则有：</p><script type="math/tex; mode=display">P(ABC) = P(C|AB)P(B|A)P(A) = P(C|AB)P(AB)</script><p>推广到 $n$ 个事件，也能写出：</p><script type="math/tex; mode=display">P(A_1A_2\cdots A_n) = P(A_n|A_1A_2\cdots A_{n-1})\times A(A_{n-1}|A_1A_2\cdots A_{n-2})</script><h2 id="乘法定理例题解析"><a href="#乘法定理例题解析" class="headerlink" title="乘法定理例题解析"></a>乘法定理例题解析</h2><p>设袋中装有 $r$ 只红球、 $t$ 只白球. 每次自袋中任取一只球, 观察其颜色然后放回 并再放入 $a$ 只与所取出的那只球同色的球, 若在袋中连续取球四次, 试求第一、二次取到红球且第三、四次取到白球的概率</p><p>解：</p><p>假设 $A_i$ 表示事件“第 $i$ 次取到红球”的概率，则 $\overline{A_3}$ 和 $\overline{A_4}$ 显然表示第 $3,4$ 次取到白球。</p><script type="math/tex; mode=display">P(A_1A_2\overline{A_3}\ \overline{A_4}) = P(A_1)\times P(A_2|A_1)\times P(\overline{A_3}|A_1A_2)\times P(\overline{A_4}|\overline{A_3}A_1A_2)</script><script type="math/tex; mode=display">= \frac{r}{r+t}\cdot\frac{r+a}{r+t+a}\cdot\frac{t}{r+t+2a}\cdot\frac{t+a}{r+t+3a}</script><blockquote><p>推广公式的应用：事实上不必理会题目中出现的繁琐逻辑，直接代入乘法定理公式求解即可。<br>这个模型被波利亚用来作为描述传染病的数学模型。</p></blockquote><h1 id="（叁）全概率公式与贝叶斯公式"><a href="#（叁）全概率公式与贝叶斯公式" class="headerlink" title="（叁）全概率公式与贝叶斯公式"></a>（叁）全概率公式与贝叶斯公式</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><h3 id="样本空间的划分"><a href="#样本空间的划分" class="headerlink" title="样本空间的划分"></a>样本空间的划分</h3><p>设 $S$ 为试验 $E$ 的样本空间，$B_1,B_2,\cdots, B_n$ 为 $E$ 的一组事件，如果：</p><ul><li>$B_iB_j=\emptyset,\;\; i\ne j,\;\;i,j=1,2,\cdots,n$ </li><li>$B_1\cup B_2\cup \cdots \cup B_n = S$</li></ul><p>则称 $B_1,B_2,\cdots B_n$ 是样本空间 $S$ 的一个<strong>划分</strong></p><center><img src = https://s2.loli.net/2023/02/08/1r5xpiVmqGAXaRu.png width = 50%></center><h3 id="全概率公式"><a href="#全概率公式" class="headerlink" title="全概率公式"></a>全概率公式</h3><p>设试验 $E$ 的样本空间为 $S$，$A$ 为 $E$ 的事件，$B_1,B_2,\cdots,B_n$ 为 $S$ 的一个划分，且 $P(B_i) &gt; 0\;(i = 1,2,\cdots,n)$，则：</p><script type="math/tex; mode=display">P(A) =  P(AB_1) + P(AB_2) + P(AB_3) + \cdots + P(AB_n)</script><script type="math/tex; mode=display">P(A|B_1)P(B_1) + P(A|B_2)P(B_2) + \cdots + P(A|B_n)P(B_n)</script><center><img src = https://s2.loli.net/2023/02/08/3rGoDZN8igCsjvp.png width = 50%></center><blockquote><p>如图是全概率公式的一种可能的模型（因为 $A$ 和 $B_i$ 可能没有交集），$A$ 的面积就相当于被样本空间 $S$ 的“<strong>划分</strong>”切割成的不同面积块的加和。</p><p>所谓全概率公式，其本质就是<strong>用样本空间的划分来切割事件</strong></p></blockquote><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><p>设试验 $E$ 的样本空间为 $S$，$A$ 为 $E$ 的事件，$B_1,B_2,\cdots,B_n$ 为 $S$ 的一个划分，且 $P(A) &gt; 0,\; P(B_i) &gt; 0\;(i=1,2,\cdots,n)$</p><script type="math/tex; mode=display">P(B_i|A) = \frac{P(B_iA)}{P(A)}  = \frac{P(B_i A)}{\sum_{j=1}^nP(B_jA)} = \frac{P(A|B_i)P(B_i)}{\sum_{j=1}^{n}P(A|B_j)P(B_j)}</script><p>事实上，分子仅仅是乘法公式的应用，分母则使用了乘法公式的变形：</p><script type="math/tex; mode=display">P(A) = P(AB_1)+P(AB_2)+\cdots+P(AB_n)\\= P(A|B_1)P(B_1) + P(A|B_2)P(B_2)+\cdots+P(A|B_n)P(B_n)</script><h2 id="例题解析-1"><a href="#例题解析-1" class="headerlink" title="例题解析"></a>例题解析</h2><h1 id="（肆）事件的独立性"><a href="#（肆）事件的独立性" class="headerlink" title="（肆）事件的独立性"></a>（肆）事件的独立性</h1><h2 id="基本定义-1"><a href="#基本定义-1" class="headerlink" title="基本定义"></a>基本定义</h2><h3 id="两个事件相互独立"><a href="#两个事件相互独立" class="headerlink" title="两个事件相互独立"></a>两个事件相互独立</h3><p>设 $A,B$ 是两个事件，如果满足等式 $P(AB) = P(A)P(B)$，则称事件 $A,B$ 相互独立，简称为 $A,B$ 独立。</p><p>如果 $P(A)$ 或 $P(B)$ 为 $0$，事件 $A,B$ 显然相互独立，而当 $P(A)$ 和 $P(B)$ 不为 $0$ 时，应该有：</p><script type="math/tex; mode=display">P(A) = P(A|B) = \frac{P(AB)}{P(B)}, P(B) = P(B|A) = \frac{P(AB)}{P(A)}</script><h3 id="三个事件两两相互独立"><a href="#三个事件两两相互独立" class="headerlink" title="三个事件两两相互独立"></a>三个事件两两相互独立</h3><p>设 $A,B,C$ 是三个事件，如果满足等式：</p><ul><li>$P(AB) = P(A)P(B)$</li><li>$P(BC) = P(B)P(C)$</li><li>$P(AC) = P(A)P(C)$</li></ul><p>则称事件 $A,B,C$ <strong>两两相互独立</strong>。</p><p>进一步地，如果满足：</p><script type="math/tex; mode=display">P(ABC) = P(A)P(B)P(C)</script><p>则称事件 $A,B,C$ <strong>相互独立</strong>。</p><div class="note warning flat"><p><strong>三个事件的两两互相独立 $\ne$ 三个事件互相独立</strong></p></div><p>两两相互独立时，在没有满足 $P(ABC) = P(A)P(B)P(C)$ 时，不一定会有三个事件相互独立：</p><p>因为前三个条件的存在已经能够保证三个事件中一个事件的发生不会对另一个事件产生影响，但是却不能确保如果同时发生两个事件时，会不会对第三个事件的发生造成影响，即不能保证如下等式成立：</p><ul><li>$P(ABC) = P(AB)P(C)$</li><li>$P(ABC) = P(AC)P(B)$</li><li>$P(ABC) = P(BC)P(A)$</li></ul><p>而当 $P(ABC) = P(A)P(B)P(C)$ 成立时，将前三条公式代入代换，即可发现以上三条公式均成立。</p><p>将这个公式进行推广，可以得到 $n$ 个事件相互独立的充要条件：</p><p>设 $A_1,A_2,\cdots,A_n$ 是 $n$ 个事件，如果对于任意的 $k$（$2 \le k\le n$），和任意的 $1 \le i_1 &lt; i_2 &lt; i_3 &lt; \cdots &lt; i_k \le n$，具有等式：</p><script type="math/tex; mode=display">P(A_{i_1}A_{i_2}\cdots A_{i_k}) = P(A_{i_1})P(A_{i_2})\cdots P(A_{i_k})</script><blockquote><p>如果看不太明白可以多看几遍这个表述方式，精练、优雅~</p></blockquote><h2 id="事件独立性定理"><a href="#事件独立性定理" class="headerlink" title="事件独立性定理"></a>事件独立性定理</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><h4 id="定理-1"><a href="#定理-1" class="headerlink" title="定理 1"></a>定理 1</h4><p>设 $A,B$ 是两事件，且 $P(A) &gt; 0$ ，若 $A,B$ 相互独立，则 $P(B|A) = P(B)$，反之亦然。</p><blockquote><p>这个性质已经在介绍定义时描述过了，不再赘述。</p></blockquote><h4 id="定理-2"><a href="#定理-2" class="headerlink" title="定理 2"></a>定理 2</h4><p>若 $A,B$ 互相独立，则对下列各对事件，$\overline{A}$ 与 $B$ ，$A$ 与 $\overline{B}$ ，$\overline{A}$ 与 $\overline{B}$ 也相互独立</p><p>证明：</p><ol><li>$\overline{A}$ 与 $B$ 相互独立</li></ol><p>只要证明：$P(\overline{A}B) = P(\overline{A})P(B)$</p><p>其中 $P(\overline{A}) = 1 - P(A)$，则 $P(\overline{A})P(B) = (1 - P(A))P(B) = P(B) - P(A)P(B) = P(B) - P(AB)$</p><p>根据全概率公式又有：</p><script type="math/tex; mode=display">P(B) = P(B|\overline{A})P(\overline{A}) + P(B|A)P(A) = P(\overline{A}B)+P(AB)</script><p>代入上式中，得到：</p><script type="math/tex; mode=display">P(\overline{A})P(B) = P(\overline{A}B)+P(AB)-P(AB) = P(\overline{A}B)</script><p>即证明了 $\overline{A}$ 与 $B$ 相互独立</p><ol><li>$A$ 与 $\overline{B}$ 相互独立</li></ol><p>证明方法同上，这两个证明是对称的。</p><ol><li>$\overline{A}$ 与 $\overline{B}$ 相互独立</li></ol><p>只要证明：$P(\overline{A}\ \overline{B}) = P(\overline{A}) P(\overline{B})$</p><p>其中代入 $P(\overline{A}) = 1 - P(A)$ 与 $P(\overline{B}) = 1 - P(B)$，即得到：</p><script type="math/tex; mode=display">P(\overline{A})P(\overline{B}) = (1 - P(A))(1 - P(B)) = 1- P(B) - P(A) + P(AB)</script><script type="math/tex; mode=display">= 1 - P(B) - P(A) + P(A)P(B)</script><h3 id="定理推论"><a href="#定理推论" class="headerlink" title="定理推论"></a>定理推论</h3><h4 id="推论-1"><a href="#推论-1" class="headerlink" title="推论 1"></a>推论 1</h4><p>若事件 $A_1,A_2,\cdots,A_n$ 相互独立，则其中任意 $k$（$2\le k \le n$）个事件也是相互独立的</p><h4 id="推论-2"><a href="#推论-2" class="headerlink" title="推论 2"></a>推论 2</h4><p>若 $n$ 个事件 $A_1,A_2,\cdots,A_n$（$n\ge 2$）相互独立，则将 $A_1,A_2,\cdots,A_n$ 中的任意多个事件换成它们的对立事件，所得到的 $n$ 个事件仍然相互独立。</p><h2 id="例题解析-2"><a href="#例题解析-2" class="headerlink" title="例题解析"></a>例题解析</h2>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法储论：时间复杂度</title>
      <link href="/2022/09/07/cu%E7%AE%97%E6%B3%951%E5%82%A8%E8%AE%BA/"/>
      <url>/2022/09/07/cu%E7%AE%97%E6%B3%951%E5%82%A8%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="《算法与数据结构》开篇"><a href="#《算法与数据结构》开篇" class="headerlink" title="《算法与数据结构》开篇"></a>《算法与数据结构》开篇</h1><center><img src = https://s1.ax1x.com/2022/09/11/vOyv79.jpg></center><p>这是算法与数据结构系列的第一篇笔记！！！（$Congratulations!$）</p><blockquote><p>本笔记主要参考中国人民大学信息学院张静老师的课件，但她说她的课件来自于清华大学邓俊辉老师的课程。总之，感谢老师们的讲解和资料！</p><p>笔记中也可能会夹带各路大佬的材料，会在文末注明</p></blockquote><p>本笔记涉及的算法与数据结构包括以下章节，即人民大学图灵班算法与数据结构荣誉课程的教学内容，后续可能视情况作其它知识补充和调整</p><ul><li>向量数据结构</li><li>列表数据结构</li><li>栈数据结构</li><li>队列数据结构</li><li>树数据结构</li><li>图数据结构</li><li>堆数据结构</li><li>高级搜索树数据结构</li><li>排序算法</li><li>其它重要算法</li></ul><p>那么，欢迎开启——算法与数据结构的世界！$Enjoy\; suffering\;!!!$</p><p>想到什么值得在一开始告诉新手的话学完再补，因为……我也才刚开始学</p><h1 id="（一）什么是算法"><a href="#（一）什么是算法" class="headerlink" title="（一）什么是算法"></a>（一）什么是算法</h1><h2 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h2><h3 id="图灵机计算模型"><a href="#图灵机计算模型" class="headerlink" title="图灵机计算模型"></a>图灵机计算模型</h3><h4 id="基本模型"><a href="#基本模型" class="headerlink" title="基本模型"></a>基本模型</h4><p>图灵机计算模型可以看作由一个纸带和一个读写头构成，如下图所示</p><center><img src = https://s1.ax1x.com/2022/09/11/vO6oHH.png width = 90%></center><p>纸带被分成若干个单元格，每个格子上都刻有一个字符，这些字符被初始化为 <code>#</code> ，并且字符除了 <code>#</code> 以外的其它取值可以为 <code>0</code> 或 <code>1</code></p><p>读写头总是对准纸带的其中一个单元格，它具有读取或改写所对准单元格的内容</p><p>每经过一个时刻，读写头可以转向左侧或右侧的单元格。</p><p>在每个时刻，我们可以为整个图灵机系统定义一个指令来方便我们操作它：$S$ ，并规定 $S$ 由以下元素组成：</p><ul><li>当前读写头状态 <code>q</code> </li><li>当前指向的字符内容 <code>c</code></li><li>该读写头将会把指向的内容修改为 <code>d</code></li><li>当前读写头将会转向左（<code>L</code>）或右（<code>R</code>）邻格</li><li>进行操作后读写头将转入状态 <code>p</code></li></ul><blockquote><p><code>q</code> 和 <code>p</code> 的取值有 <code>&lt;</code>（表示读写头正在向左移动）、<code>&gt;</code> （表示读写头正在向右移动）和 <code>h</code> （即 halt ，表示读写头停止移动）</p></blockquote><p>将一条指令记为：<code>S (q, c; d, L/R, p)</code></p><h4 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h4><p>下面的操作演示了如何将一个二进制非负整数 <code>0</code> <code>1</code> <code>1</code> <code>1</code> <code>1</code> 加 <code>1</code></p><ul><li><p>步骤 $1$ ：将待操作数读取到图灵机的纸带中</p></li><li><p>步骤 $2$ ：输入下面 $5$ 条指令并执行：</p><ul><li><p><code>S (&lt;, 1; 0, L, &lt;)</code></p><center><img src = https://s1.ax1x.com/2022/09/11/vO67Ed.png width = 70%></center></li><li><p><code>S (&lt;, 0; 1, R, &gt;)</code></p><center><img src = https://s1.ax1x.com/2022/09/11/vO6HUA.png width = 70%></center></li><li><p><code>S (&lt;, #; 1, R, &gt;)</code></p><center><img src = https://s1.ax1x.com/2022/09/11/vO6fgK.png width = 70%></center></li><li><p><code>S (&gt;, 0; 0, R, &gt;)</code></p><center><img src = https://s1.ax1x.com/2022/09/11/vO6cNR.png width = 70%></center></li><li><p><code>S (&gt;, #; #, L, h)</code></p><center><img src = https://s1.ax1x.com/2022/09/11/vO6R9x.png width = 70%></center><blockquote><p>这些指令是图灵机的运行逻辑，我们解读一下它们：</p><p>第一个指令 <code>S (&lt;, 1; 0, L, &lt;)</code> 表示如果当前处于左行状态，并且读取到的数是 <code>1</code> ，那么将这个 <code>1</code> 修改成 <code>0</code> ，并且下一时刻方向转变为 <code>L</code> ，状态保持 <code>&lt;</code> 不变</p><p>第二个指令 <code>S (&lt;, 0; 1, R, &gt;)</code> 表示如果当前处于右行状态，并且读取到的数是 <code>0</code> ，那么将这个 <code>0</code> 修改成 <code>1</code> ，并且下一时刻方向转变为 <code>R</code> ，状态保持 <code>&lt;</code></p><p>其它指令的涵义和上面的解释相似，我们可能注意到到了：<code>;</code> 符号前表示的是执行操作的条件。<code>;</code> 后表示执行的操作。</p><p>上面五条操作中，每个时刻都一定要执行其中一条指令（这就要求：设计指令序列时一定要考虑条件是能覆盖全部的情形）</p><blockquote><p>比如上面的 $5$ 条指令，它们控制的条件包括 <code>(&lt;, 1)</code> ，<code>(&lt;, 0)</code> ，<code>(&lt;, #)</code> ， <code>(&gt;, 0)</code> ， <code>(&gt;, #)</code></p><p>你可能注意到这里面似乎没有包含 <code>(&gt;, 1)</code> ，事实上，加法程序中在这种情形下并不需要进行操作</p></blockquote><p>特别的，当图灵机的状态转移到 <code>h</code> ，则停机，因此含有 <code>h</code> 的语句可以当作图灵机的状态终止判断语句</p></blockquote></li></ul></li></ul><h3 id="RAM-计算模型"><a href="#RAM-计算模型" class="headerlink" title="$RAM$ 计算模型"></a>$RAM$ 计算模型</h3><p>$RAM$ 全称为 $Random\ Access\ Machine$ ，即随机存取机器模型</p><p>是与CPU直接交换数据的内部存储器，也叫主存（内存）。它可以随时读写，而且速度很快，通常作为操作系统或其他正在运行中的程序的临时数据存储媒介。</p><p>它应该具有以下特点：</p><ul><li>寄存器顺序编号，模型上寄存器总数不作限制</li><li>可通过编号直接访问任意寄存器</li><li>每一基本操作仅需要常数时间</li></ul><h2 id="算法的定义和特点"><a href="#算法的定义和特点" class="headerlink" title="算法的定义和特点"></a>算法的定义和特点</h2><p>算法指的就是：在特定计算模型下，旨在解决特定问题的指令序列</p><blockquote><p>比如，上述的图灵机加法算法</p></blockquote><p>算法应该满足下面的特点：</p><ul><li>正确性：设计出的指令序列的确可以解决指定的问题，进一步地：<ul><li>可以处理简单的输入</li><li>可以处理大规模的输入</li><li>可以处理一般性的输入</li><li>可以处理退化的输入</li><li>可以处理任意合法的输入</li></ul></li><li>确定性：任一算法都应该可以描述为一个由基本操作组成的序列</li><li>可行性：每一个基本操作都可以在常数时间内完成</li><li>有穷性：对于任何输入，经过有穷性次的基本操作，都可以得到输出</li></ul><h1 id="（二）算法成本估量：渐进分析"><a href="#（二）算法成本估量：渐进分析" class="headerlink" title="（二）算法成本估量：渐进分析"></a>（二）算法成本估量：渐进分析</h1><h2 id="渐进分析概念"><a href="#渐进分析概念" class="headerlink" title="渐进分析概念"></a>渐进分析概念</h2><p>算法分析包括时间复杂度分析和空间复杂度分析，其中，我们更加关注的是对时间复杂度的分析</p><p>假设算法时间仅仅依赖于问题的输入规模 $n$ ，我们可以将它表示为 $T(n)$ ，由于算法的每一步基本操作的次数都是常数时间，因此 $T(n)$ 的值就是每一步的基本操作次数之和。</p><p>而渐进分析指的就是，忽略掉 $T(n)$ 的系数和非最高阶项，仅关注最高阶项</p><p>一般我们使用 $O(f(n))$ 来表示渐进分析的结果，基于上面的定义，应有：</p><script type="math/tex; mode=display">若\; \exist c>0,\; 有\; T(n) < cf(n) \; ,\; 则认为可以用\; f(n) \; 代表\; T(n) \; 的增长趋势</script><script type="math/tex; mode=display">简记为 \; O(f(n)) = T(n)</script><p>比如下面的式子就是一个渐进分析的示例</p><script type="math/tex; mode=display">T(n)=\sqrt{5n[3n(n+2)+4]+6}<\sqrt{5n[6n^2+4]+6}<\sqrt{35n^2+6}<6n^{1.5} = O(n^{1.5})</script><p>渐进分析的结果 $O(f(n))$ 和原式 $T(n)$ 的关系大致如下图所示</p><center><img src = https://s1.ax1x.com/2022/09/11/vO66E9.png width = 70%></center><blockquote><p>在图中可以直观地看出，渐进分析的方法事实上并不过多地考虑算法在较小规模输入下的表现，而是更加关注算法在较大规模输入下的潜力</p></blockquote><p>下面会介绍更加具体的渐进分析方法</p><h2 id="一般多项式复杂度分析"><a href="#一般多项式复杂度分析" class="headerlink" title="一般多项式复杂度分析"></a>一般多项式复杂度分析</h2><p>多项式复杂度的分析主要遵循下面两条规则</p><ul><li><p>$O(f(n))=O(cf(n))$</p><blockquote><p>常数系数直接忽略</p></blockquote></li><li><p>$O(n^a+n^b) = O(n^a)\; ,\; a\ge b &gt; 0$ </p><blockquote><p>次数较低的项直接忽略</p></blockquote></li></ul><p>特别的，当时间复杂度不随问题规模的增长而提高，我们则称其复杂度为常数复杂度，相当于进行了 $k$ 次基本操作（其中 $k$ 与规模无关），记作 $O(1)$</p><blockquote><p><code>C++</code> 等高级语言的基本指令，与可以等效于常数条 <code>RAM</code> 的基本指令，在渐进意义下，二者大体相当</p><p>这里的基本指令有：</p><ul><li>分支转向语句 <code>goto</code>、<code>if</code></li><li>迭代循环语句：<code>for</code>、<code>while</code></li><li>函数调用</li></ul></blockquote><h2 id="对数多项式复杂度分析"><a href="#对数多项式复杂度分析" class="headerlink" title="对数多项式复杂度分析"></a>对数多项式复杂度分析</h2><p>有些情况下，算法操作次数的计算结果可能如下：</p><script type="math/tex; mode=display">    T(n) = \sum_{i=1}^ka_ilog_{b_i}n</script><p>这种情况下，我们认为该算法具有<strong>对数多项式复杂度</strong></p><p>对数多项式复杂算法的渐进分析遵循以下规则：</p><ul><li><p>忽略常底数：因为常底数都能通过换底分解出常数，而常数在渐进分析中是可以忽略的</p><script type="math/tex; mode=display">O(log_an)=O(log_ab \cdot log_bn) = O(log_bn) = O(logn)</script><blockquote><p>因此我们在进行渐进分析时索性不关注常底数，直接记为 $O(logn)$ </p></blockquote></li><li><p>忽略真数的常数次幂：真数可以提取到对数符号外作为常数，因此可以被忽略</p></li></ul><script type="math/tex; mode=display">O(loga^b)=O(bloga) = O(loga)</script><ul><li>对数多项式取最高次：这点同“一般多项式复杂度分析”</li></ul><blockquote><p>e.x. $O(123log^{321}+log^{205}(7n^2-15n+31)) = O(log^{321}n)$</p></blockquote><h2 id="指数多项式复杂度分析"><a href="#指数多项式复杂度分析" class="headerlink" title="指数多项式复杂度分析"></a>指数多项式复杂度分析</h2><p>有些情况下，算法操作次数的计算结果可能如下：</p><script type="math/tex; mode=display">T(n) = \sum_{i=1}^k a_in^i</script><p>这种情况下，我们认为该算法具有<strong>指数多项式复杂度</strong></p><p>一般情况下，指数多项式算法的计算成本被我们认为不可接受，因此从 $O(2^n)$ 到 O(n^c) 常被我们认为是无效算法到有效算法的分水岭</p><p>悲观的是，相当一部分问题如 $NP-complete$ ，在目前的计算模型下，不存在常数时间内解决的可能性。</p><h2 id="级数分析方法"><a href="#级数分析方法" class="headerlink" title="级数分析方法"></a>级数分析方法</h2><p>级数分析方法和上面的一些分析规律可能是重合的，但是这里将它们单独罗列，是因为很多算法得到的操作次数 $T(n)$ 会呈现级数的数学形式。</p><h3 id="算术级数"><a href="#算术级数" class="headerlink" title="算术级数"></a>算术级数</h3><script type="math/tex; mode=display">    T(n) = 1 + 2 + 3+ \cdots + n = \frac{n(n+1)}{2}= O(n^2)</script><p>最终结果应与末项的平方同阶</p><h3 id="幂方级数"><a href="#幂方级数" class="headerlink" title="幂方级数"></a>幂方级数</h3><script type="math/tex; mode=display">    T(n) = \sum_{k=0}^nk^d \approx \int_0^nx^ddx = \frac{n^{d+1}}{d+1} = O(n^{d+1})</script><p>最终结果应比最高次幂高出一阶</p><h3 id="几何级数"><a href="#几何级数" class="headerlink" title="几何级数"></a>几何级数</h3><script type="math/tex; mode=display">    T(n) = a^0+a^1+a^2+\cdots+a^n = O(a^n)</script><p>最终结果应与最高次幂同阶</p><h3 id="收敛级数或有限级数"><a href="#收敛级数或有限级数" class="headerlink" title="收敛级数或有限级数"></a>收敛级数或有限级数</h3><ul><li><p>调和级数</p><script type="math/tex; mode=display">  O(f(n)) = O(\sum_{k=1}^n\frac{1}{k}) \approx O(\int_1^n lnxdx) = O(logn)</script></li><li><p>对数级数</p></li></ul><script type="math/tex; mode=display">    O(f(n)) = O(\sum_{k=1}^n{lnk}) \approx O(\int_1^n lnxdx) = O(xlnx-x|_1^n) = O(nlnn)</script><ul><li>线性对数级数</li></ul><script type="math/tex; mode=display">    O(\sum_{k=1}^n{k\cdot logk}) \approx O(\int_1^n{xlnx}dx) = O(n^2logn)</script><h2 id="各种算法复杂度之间的优劣性"><a href="#各种算法复杂度之间的优劣性" class="headerlink" title="各种算法复杂度之间的优劣性"></a>各种算法复杂度之间的优劣性</h2><center><img src = https://s1.ax1x.com/2022/09/11/vO6g41.png  width = 100%></center><h1 id="（三）迭代与递归方法-1-（减而治之）分析"><a href="#（三）迭代与递归方法-1-（减而治之）分析" class="headerlink" title="（三）迭代与递归方法 $1$（减而治之）分析"></a>（三）迭代与递归方法 $1$（减而治之）分析</h1><p>减而治之的要点是——将规模为 $n$ 的问题分成两个部分——其中一部分是规模为 $n-1$ 的问题，另一部分是一个平凡的问题——就是说只需要 $O(1)$ 基本操作即可求解的问题。</p><center><img src = https://s1.ax1x.com/2022/09/11/vO6W36.png width = 70%></center><p>对于规模为 $O(1)$ 的问题，采用直接求解的方式（有时需要将求解结果并入总问题中）</p><p>对于规模为 $O(n-1)$ 的问题，使用递归方法进一步地减而治之</p><h2 id="递归追踪"><a href="#递归追踪" class="headerlink" title="递归追踪"></a>递归追踪</h2><p>对减而治之的算法进行时间复杂度分析时，需要进行递归跟踪：统计递归算法中的所有递归实例，计算每个递归实例的时间复杂度。</p><blockquote><p>e.x. 下图的计算各数总和的递归算法中，一个调用了 $n+1$ 个递归实例，每个递归实例的时间复杂度为 $O(1)$（每个递归实例中进行的都是有限次基本操作），故有 $O(f(n)) = (n+1)O(1)= O(n)$</p><center><img src = https://s1.ax1x.com/2022/09/11/vO6hjO.png width = 50%></center></blockquote><h2 id="递归方程"><a href="#递归方程" class="headerlink" title="递归方程"></a>递归方程</h2><p>有时也可以不必进行递归追踪，特别是在一些非常复杂无法追踪的情形，此时可以采用递归方程法进行归纳推演</p><p>比如上述问题中，可以使用递归方程法给出下式：</p><script type="math/tex; mode=display">    T(n) = T(n-1) + O(1)</script><script type="math/tex; mode=display">    T(0) = O(1)</script><script type="math/tex; mode=display">    T(n) = T(n-2)+2O(1)=T(n-3)+3O(1)=\cdots=T(0)+nO(1) = O(n)</script><h1 id="（四）迭代与递归方法-2-（分而治之）分析"><a href="#（四）迭代与递归方法-2-（分而治之）分析" class="headerlink" title="（四）迭代与递归方法 $2$ （分而治之）分析"></a>（四）迭代与递归方法 $2$ （分而治之）分析</h1><p>减而治之的要点是——将规模为 $n$ 的问题若干个子问题，设它们的规模分别为 $r_1(n),r_2(n),\cdots,r_k(n)$，其中 $r_i(n)&gt;0，\sum_{i=1}^k{r_i(n)}=n$，然后分别进行求解，最后将分问题的解依次合并，最终得到原问题的解</p><center><img src = https://s1.ax1x.com/2022/09/11/vO65uD.png width = 50%></center><p>比如对下面的程序进行算法分析：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span> <span class="params">(<span class="type">int</span> A[], <span class="type">int</span> lo, <span class="type">int</span> hi)</span></span>&#123;  <span class="comment">// 本笔记中的所有区间都采取左闭右开的形式</span></span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span> A[lo];</span><br><span class="line">    <span class="type">int</span> mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(A, lo, mi) + <span class="built_in">sum</span>(A, mi, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归跟踪"><a href="#递归跟踪" class="headerlink" title="递归跟踪"></a>递归跟踪</h2><p>递归跟踪的结果如下图所示：</p><center><img src = https://s1.ax1x.com/2022/09/11/vO6IDe.png width = 95%></center><p>根据调用关系和计算次数可以得到：$T(n) = O(1)\times(2^0+2^1+\cdots+2^{logn})=O(n)$</p><h2 id="递归方程-1"><a href="#递归方程-1" class="headerlink" title="递归方程"></a>递归方程</h2><p>使用递归方程进行归纳推演的方法如下：</p><script type="math/tex; mode=display">  T(n) = 2T(\frac{n}{2}) + O(1)</script><script type="math/tex; mode=display">  T(1) = O(1)</script><script type="math/tex; mode=display">  T(n) = 4T(\frac{n}{4}) + 3O(1) =\cdots= nT(1) + (n-1)O(1) = O(n) + O(n-1) = O(n)</script><h1 id="（五）动态规划方法（记忆化）分析"><a href="#（五）动态规划方法（记忆化）分析" class="headerlink" title="（五）动态规划方法（记忆化）分析"></a>（五）动态规划方法（记忆化）分析</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>记忆化搜索和动态规划实际上是两种优化大规模递归的有效手段——</p><p>记忆化搜索保留了原本递归的形式和结构，自顶向下进行求解，而动态规划则采用了自底向上进行求解的方式。</p><p>动态规划和记忆化搜索一般还是采取递归追踪/迭代追踪的方法，计算出除了已经被优化掉的计算之外的其它操作次数之和，然后进而计算时间复杂度</p><h2 id="实例：最大公共子序列"><a href="#实例：最大公共子序列" class="headerlink" title="实例：最大公共子序列"></a>实例：最大公共子序列</h2><p>TODO : 待补充</p><h1 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h1><p>本节主要涵盖了以下内容——</p><ul><li>两种计算模型和算法的定义</li><li><strong>渐进分析的概念和方法</strong><ul><li>一般多项式复杂度分析</li><li>对数多项式复杂度分析</li><li>指数多项式复杂度分析</li><li>级数分析</li></ul></li><li>特殊算法的时间复杂度分析方法<ul><li>减而治之的分析方法（递归追踪和递归方程）</li><li>分而治之的分析方法（递归追踪和递归方程）</li><li>动态规划和记忆化搜索分析方法</li></ul></li></ul><p>重点部分应该是“<strong>渐进分析的概念和方法</strong>”，它是贯穿算法课程的重要线索</p><div class="note info flat"><p>知道第一节的笔记比较水（恼），硬核的在后面。。。</p></div>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法与数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑代数基础</title>
      <link href="/2022/09/05/c%E6%95%B0%E7%94%B5%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B01/"/>
      <url>/2022/09/05/c%E6%95%B0%E7%94%B5%EF%BC%9A%E9%80%BB%E8%BE%91%E4%BB%A3%E6%95%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）开篇"><a href="#（一）开篇" class="headerlink" title="（一）开篇"></a>（一）开篇</h1><p>该笔记主要用于记录中国人民大学信息学院《数字逻辑与数字电路》课程的课堂重点、题型总结以及各种地方搜寻来的有关本门课程的资料。</p><center><img src = https://s1.ax1x.com/2022/09/07/vH7OL6.png width = 100%></center><blockquote><p>本笔记主要参考中国人民大学信息学院李亚平老师的课件，<strong>感谢老师的讲解和资料</strong>！</p><p>笔记中也可能会夹带各路大佬的材料，会在文末注明</p></blockquote><p>那么，欢迎开启数字逻辑与数字电路的世界！！！</p><p>下图是本门课程在 $CS$ 体系中的地位，本门课程属于 $EECS151$ 的范畴</p><center><img src = https://s1.ax1x.com/2022/09/07/vHbenx.png width = 50%></center><p>本门课程主要分为以下几个部分:</p><ul><li>逻辑代数</li><li>门电路基础</li><li>组合逻辑电路</li><li>时序逻辑电路</li><li>脉冲产生电路</li><li>模数/数模转换电路</li></ul><hr><h1 id="（二）数字电路概述"><a href="#（二）数字电路概述" class="headerlink" title="（二）数字电路概述"></a>（二）数字电路概述</h1><h2 id="数字信号与模拟信号"><a href="#数字信号与模拟信号" class="headerlink" title="数字信号与模拟信号"></a>数字信号与模拟信号</h2><ul><li>模拟电路：在时间上和数值上连续的信号称为模拟信号，对模拟信号进行传输、处理的电子线路称为模拟电路。</li></ul><center><img src = https://s1.ax1x.com/2022/09/11/vOR6sK.png width = 45%></center><ul><li>数字电路：在时间上和数值上不连续的（即离散的）信号称为数字信号，对数字信号进行传输、处理的电子线路称为数字电路。</li></ul><center><img src = https://s1.ax1x.com/2022/09/11/vORcqO.png width = 45%></center><h2 id="数字电路特点"><a href="#数字电路特点" class="headerlink" title="数字电路特点"></a>数字电路特点</h2><ul><li><p>工作信号是二进制的数字信号，在时间上和数值上是<strong>离散的</strong>（不连续），反映在电路上就是低电平和高电平两种状态（即 0 和 1 两个逻辑值）</p></li><li><p>组成数字电路的元器件的<strong>精度要求不高</strong>，只要在工作时能够可靠地区分 0 和 1 两种状态即可</p></li><li><p>在数字电路中，研究的主要问题是电路的逻辑功能，即<strong>输入信号的状态和输出信号的状态之间的关系</strong></p></li></ul><h2 id="数字电路分类"><a href="#数字电路分类" class="headerlink" title="数字电路分类"></a>数字电路分类</h2><blockquote><p>这个分类现在应该看不懂，可以直接先跳过</p></blockquote><h3 id="按集成度分类"><a href="#按集成度分类" class="headerlink" title="按集成度分类"></a>按集成度分类</h3><ul><li>小规模（$SSI$）：每片数十器件</li><li>中规模（$MSI$）：每片数百器件</li><li>大规模（$LSI$）：每片数千器件</li><li>超大规模（$VLSI$）：每片器件数目大于 $1$ 万</li></ul><h3 id="按所用器件制作工艺分类"><a href="#按所用器件制作工艺分类" class="headerlink" title="按所用器件制作工艺分类"></a>按所用器件制作工艺分类</h3><ul><li>双极型（$TTL$）</li><li>单极型（$MOS$）</li></ul><h3 id="按照电路的结构和工作原理分类"><a href="#按照电路的结构和工作原理分类" class="headerlink" title="按照电路的结构和工作原理分类"></a>按照电路的结构和工作原理分类</h3><ul><li>组合逻辑电路：<strong>没有记忆功能</strong>，其输出信号只与当时的输入信号有关，而与电路以前的状态无关</li><li>时序逻辑电路：<strong>具有记忆功能</strong>，其输出信号不仅和当时的输入信号有关，而且与电路以前的状态有关</li></ul><hr><h1 id="（三）数制和编码"><a href="#（三）数制和编码" class="headerlink" title="（三）数制和编码"></a>（三）数制和编码</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><blockquote><p>关于数制的知识点比较简单，不进行赘诉，主要知识点罗列如下：</p></blockquote><ul><li>进位制</li><li>基数</li><li>位权</li><li>十进制</li><li>二进制</li><li>八进制</li><li>十六进制</li></ul><h2 id="数制转换"><a href="#数制转换" class="headerlink" title="数制转换"></a>数制转换</h2><h3 id="二进制转八、十六进制"><a href="#二进制转八、十六进制" class="headerlink" title="二进制转八、十六进制"></a>二进制转八、十六进制</h3><ul><li>二进制转八进制：数字三位一组进行换算，不够则补零，整数小数部分均如此</li></ul><blockquote><p>e.g. $(001,101,010.010)_2 = (152.2)_8$</p></blockquote><ul><li>二进制转十六进制：数字四位一组进行换算，不够则补零，整数小数部分均如此</li></ul><blockquote><p>e.g. $(0001,1101,0100\ .\ 0110)_2 = (1D4.6)_{16}$</p></blockquote><h3 id="八、十六进制转二进制"><a href="#八、十六进制转二进制" class="headerlink" title="八、十六进制转二进制"></a>八、十六进制转二进制</h3><ul><li>八进制转二进制：数字一位化三位进行换算，整数小数部分均如此</li></ul><blockquote><p>e.g. $(374.26)_8 = (011,111,100\ .\ 010,110)_2$</p></blockquote><ul><li>十六进制转二进制：数字一位化四位进行换算，整数小数部分均如此</li></ul><blockquote><p>e.g. $(AF4.76)_{16} = (1010,1111,0100\ .\ 0111,0110)_2$</p></blockquote><h3 id="十进制数转换为二进制数"><a href="#十进制数转换为二进制数" class="headerlink" title="十进制数转换为二进制数"></a>十进制数转换为二进制数</h3><p>一个十进制数可以先分成<strong>整数部分和小数部分</strong></p><h4 id="整数部分除基取余法"><a href="#整数部分除基取余法" class="headerlink" title="整数部分除基取余法"></a>整数部分除基取余法</h4><ul><li>步骤 1 ：原数除以基数（基数就是 $2$ ）得到余数 $r_1$</li><li>步骤 2 ：不断重复步骤 1 分别得到余数 $r_2,r_3,\cdots,r_n$</li><li>步骤 3 ：将步骤 1 和 2 得到的余数<strong>反向排列</strong>，得到二进制序列：$r_nr_{n-1}\cdots r_2r_1$</li></ul><h4 id="小数部分乘基取整法"><a href="#小数部分乘基取整法" class="headerlink" title="小数部分乘基取整法"></a>小数部分乘基取整法</h4><ul><li>步骤 1 ：原数乘以基数（基数就是 $2$ ）得到数 $K_1$ ，其中 $K_1$ 整数部分为 $i_1$</li><li>步骤 2 ：将上述步骤 1 得到的数 $K_1$ 去掉整数部分 $i_1$ 得到新的数 $K_1’$ ，将 $K_1’$ 作为步骤 1 中的原数重复操作</li><li>步骤 3 ：重复步骤 1 和 2 的操作，得到整数 $i_2,i_3,\cdots,i_n$ </li><li>步骤 4 ：将步骤 3 得到的整数正向排列，得到二进制序列：$i_1i_2\cdots i_{n-1}i_n$</li></ul><blockquote><p>e.g. $(44.375)_{10} = (101100.011)_2 的计算过程$</p><center><img src = https://s1.ax1x.com/2022/09/11/vORhid.png width = 80%></center></blockquote><h2 id="编码方法"><a href="#编码方法" class="headerlink" title="编码方法"></a>编码方法</h2><h3 id="BCD-码"><a href="#BCD-码" class="headerlink" title="$BCD$ 码"></a>$BCD$ 码</h3><p>我们可以用 $4$ 位二进制数串来表示十进制数中的 $0 \sim 9$ 十个数码，然后<strong>将这些二进制数串按照十进制数中各个数字原本的顺序排列</strong>，这种十进制数的编码方法就是 $BCD$ 码。</p><div class="note info flat"><p>举个例子，$892$ 用 $8421BCD$ 码表示就是 $100010010010$</p></div><p>$BCD$ 码有以下几种类型：</p><ul><li><p>$8421$ 码：$4$ 位二进制数串中各位数字的权重（从左到右）是 $8、4、2、1$</p></li><li><p>余三码：在 $8421$ 码的基础上加 $0011$ 得到余三码，即 $0$ 表示为 $0011$ ，$1$ 表示为 $0100$ ，$2$ 表示为 $0101$ ，$\cdots$ ，$9$ 表示为 $1100$</p></li><li><p>格雷码：二进制码的改进，相邻的两个十进制数字只有一位不同，详见此 <a href="https://www.lixinbook.cn/2022/09/03/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">链接</a> 中的染色体编码-格雷编码</p></li><li><p>$2421$ 码：$4$ 位二进制数串中各位数字的权重（从左到右）是 $2、4、2、1$</p></li><li><p>$5421$ 码：$4$ 位二进制数串中各位数字的权重（从左到右）是 $5、4、2、1$</p></li></ul><blockquote><p>各种常用 $BCD$ 码如下</p><center><img src= https://s1.ax1x.com/2022/09/11/vORTQP.png width = 60%></center></blockquote><hr><h1 id="（四）逻辑代数的公式定理"><a href="#（四）逻辑代数的公式定理" class="headerlink" title="（四）逻辑代数的公式定理"></a>（四）逻辑代数的公式定理</h1><p>逻辑是指事物的因果关系，或者说条件和结果的关系，这些因果关系可以用逻辑运算来表示，也就是用逻辑代数来描述，而逻辑代数是用于描述客观事物逻辑关系的数学方法。</p><h2 id="逻辑常量和逻辑变量"><a href="#逻辑常量和逻辑变量" class="headerlink" title="逻辑常量和逻辑变量"></a>逻辑常量和逻辑变量</h2><ul><li><p>逻辑代数中仅存在两个逻辑常量，即逻辑 $0$ 和逻辑 $1$，被称为逻辑 $0$ 状态和逻辑 $1$ 状态，表示事物的两种对立的状态。</p></li><li><p>逻辑代数中的变量称为逻辑变量，用大写字母表示。它的取值只能是两种逻辑常量</p></li></ul><h2 id="基本逻辑运算"><a href="#基本逻辑运算" class="headerlink" title="基本逻辑运算"></a>基本逻辑运算</h2><h3 id="与逻辑（与运算）"><a href="#与逻辑（与运算）" class="headerlink" title="与逻辑（与运算）"></a>与逻辑（与运算）</h3><p>逻辑代数中用形式上的乘法来表示与运算。</p><p>当决定事件（$Y$）发生的所有条件（$A，B，C，\cdots$）均满足时，事件（Y）才会发生。逻辑表达式为：</p><script type="math/tex; mode=display">Y=ABC\cdots</script><p>实现与逻辑的电路称为与门，与门的逻辑符号为：</p><center><img src = https://s1.ax1x.com/2022/09/11/vOR7sf.png width = 50%></center><h3 id="或逻辑（或运算）"><a href="#或逻辑（或运算）" class="headerlink" title="或逻辑（或运算）"></a>或逻辑（或运算）</h3><p>逻辑代数中用形式上的加法来表示或运算。</p><p>当决定事件（$Y$）发生的各种条件（$A，B，C，\cdots$）中，只要有一个或多个条件具备，事件（$Y$）就发生。逻辑表达式为：</p><script type="math/tex; mode=display">Y = A+B+C+\cdots</script><p>实现或逻辑的电路称为或门，或门的逻辑符号为：</p><center><img src = https://s1.ax1x.com/2022/09/11/vORqeS.png width = 50%></center><h3 id="非逻辑（非运算）"><a href="#非逻辑（非运算）" class="headerlink" title="非逻辑（非运算）"></a>非逻辑（非运算）</h3><p>非逻辑指的是逻辑的否定。逻辑表达式为：</p><script type="math/tex; mode=display">Y = \overline{A}</script><p>实现非逻辑的电路称为非门。非门的逻辑符号：</p><center><img src = https://s1.ax1x.com/2022/09/11/vORLdg.png width = 50%></center><blockquote><p>注意要在方框后面加一个小圆圈表示电路的断开</p></blockquote><h3 id="与非运算"><a href="#与非运算" class="headerlink" title="与非运算"></a>与非运算</h3><p>与非运算就是与运算和非运算的复合运算，当且仅当参与运算的所有条件都为真时，与非运算返回的结果才为真</p><p>逻辑表达式为：</p><script type="math/tex; mode=display">Y = \overline{AB}</script><p>真值表为：</p><blockquote><p>关于什么是真值表，请移步这个 <a href="">链接</a> （离散数学入门）</p></blockquote><div class="table-container"><table><thead><tr><th>$A$</th><th>$B$</th><th>$Y$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>实现与非运算的电路称为与非门。与非门的逻辑符号：</p><center><img src = https://s1.ax1x.com/2022/09/11/vORvJs.png width = 40%></center><h3 id="或非运算"><a href="#或非运算" class="headerlink" title="或非运算"></a>或非运算</h3><p>或非运算就是或运算和非运算的复合运算，当且仅当参与运算对的所有条件都为假时，或非运算返回的结果才为假</p><p>逻辑表达式为：</p><script type="math/tex; mode=display">Y = \overline{A+B}</script><p>真值表为：</p><div class="table-container"><table><thead><tr><th>A</th><th>B</th><th>Y</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td></tr><tr><td>0</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>实现或非运算的电路称为或非门，或非门的逻辑符号：</p><center><img src =https://s1.ax1x.com/2022/09/11/vOW9yV.png width = 40%></center><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>异或运算指的是：如果参与运算的逻辑条件的真值不同，返回的结果为 $0$ ，如果参与运算的逻辑条件的真值相同，返回的结果为 $1$</p><p>逻辑表达式为：</p><script type="math/tex; mode=display">Y = \overline{A}B + A\overline{B} = A \oplus B</script><p>真值表为：</p><div class="table-container"><table><thead><tr><th>$A$</th><th>$B$</th><th>$Y$</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>0</td><td>1</td></tr><tr><td>1</td><td>1</td><td>0</td></tr></tbody></table></div><p>实现异或运算的电路称为异或门，异或门的逻辑符号：</p><center><img src =https://s1.ax1x.com/2022/09/11/vOWieU.png width = %40></center><h3 id="与或非运算"><a href="#与或非运算" class="headerlink" title="与或非运算"></a>与或非运算</h3><p>与或非运算是与运算、或运算、非运算的综合。</p><p>逻辑表达式为：</p><script type="math/tex; mode=display">Y = \overline{AB+CD}</script><p>实现与或非运算的电路称为与或非门，与或非门的逻辑符号：</p><center><img src = https://s1.ax1x.com/2022/09/11/vOWVY9.png width = 40%></center><h2 id="逻辑函数基础"><a href="#逻辑函数基础" class="headerlink" title="逻辑函数基础"></a>逻辑函数基础</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><ul><li><p><strong>逻辑表达式</strong>：由逻辑变量和与、或、非 $3$ 种运算符连接起来所构成的式子，称为逻辑表达式。</p><blockquote><p> 逻辑表达式实际上也可以看作是整体的一个变量</p></blockquote></li><li><p><strong>原变量和非变量</strong>：逻辑表达式中字母上面没有非运算符的叫做原变量</p></li></ul><h3 id="逻辑函数"><a href="#逻辑函数" class="headerlink" title="逻辑函数"></a>逻辑函数</h3><p>对于一组逻辑变量 $A、B、C、\cdots$ 的任意一种取值情况得到的真值串，逻辑变量 Y 都有唯一确定的值，则称 Y 是 $A、B、C、\cdots$ 的逻辑函数，记为：</p><script type="math/tex; mode=display">Y = f(A,B,C,\cdots)</script><blockquote><p>提示：在逻辑代数中，不管是变量还是函数，其取值都只能是 0 或 1</p></blockquote><p>对于两个逻辑函数 $Y_1 = f_1(A,B,C,\cdots)$ 和 $Y_2 = f_2(A,B,C,\cdots)$ ，如果这两个函数的真值表相等，那么这两个逻辑函数就相等。</p><blockquote><p>两个逻辑函数的真值表相等，意味着首先它们的逻辑变量个数相等，另外这些逻辑变量任取 $0$ 或 $1$ 时，这两个逻辑函数的真值都会相等</p></blockquote><hr><h1 id="（五）基本公式定理"><a href="#（五）基本公式定理" class="headerlink" title="（五）基本公式定理"></a>（五）基本公式定理</h1><p>逻辑代数的基本公式定理构筑了逻辑代数体系大楼的基石，本节介绍一些关于逻辑代数的底层定理以及它们的理解和习题技巧。</p><h2 id="逻辑常量关系定理"><a href="#逻辑常量关系定理" class="headerlink" title="逻辑常量关系定理"></a>逻辑常量关系定理</h2><blockquote><p>一定要转变一下认知：$+$ 表示或运算，$\cdot$ 表示与运算，否则逻辑代数的世界将使你感到疑惑</p></blockquote><h3 id="与运算系列"><a href="#与运算系列" class="headerlink" title="与运算系列"></a>与运算系列</h3><ul><li>$0 \cdot 0 = 0$</li><li>$0 \cdot 1 = 0$</li><li>$1 \cdot 1 = 1$</li></ul><h3 id="或运算系列"><a href="#或运算系列" class="headerlink" title="或运算系列"></a>或运算系列</h3><ul><li>$1+ 1 = 1$</li><li>$1 + 0 = 1$</li><li>$0+0=0$</li></ul><h3 id="非运算系列"><a href="#非运算系列" class="headerlink" title="非运算系列"></a>非运算系列</h3><ul><li>$\overline{1} = 0$</li><li>$\overline{0} = 1$</li></ul><h2 id="逻辑变量和逻辑常量关系定理"><a href="#逻辑变量和逻辑常量关系定理" class="headerlink" title="逻辑变量和逻辑常量关系定理"></a>逻辑变量和逻辑常量关系定理</h2><h3 id="与运算系列-1"><a href="#与运算系列-1" class="headerlink" title="与运算系列"></a>与运算系列</h3><ul><li>$A\cdot 1 = A$</li><li>$A\cdot 0 = 0$</li><li>$A\cdot \overline{A} = 0$</li></ul><h3 id="或运算系列-1"><a href="#或运算系列-1" class="headerlink" title="或运算系列"></a>或运算系列</h3><ul><li>$A + 0 = A$</li><li>$A + 1 = 1$</li><li>$A + \overline{A} = 1$</li></ul><h2 id="逻辑变量等式"><a href="#逻辑变量等式" class="headerlink" title="逻辑变量等式"></a>逻辑变量等式</h2><h3 id="交换律"><a href="#交换律" class="headerlink" title="交换律"></a>交换律</h3><ul><li>$A\cdot B = B\cdot A$</li><li>$A + B = B+A$</li></ul><h3 id="结合律"><a href="#结合律" class="headerlink" title="结合律"></a>结合律</h3><ul><li>$(A \cdot B)\cdot C = A \cdot (B\cdot C)$</li><li>$(A+B)+C = A+(B+C)$</li></ul><blockquote><p>$ABC\cdots$ 为真当且仅当 $A,B,C,\cdots$ 均为真</p><p>$A+B+C+\cdots$ 为假当且仅当 $A,B,C,\cdots$ 均为假</p><p>因此结合并不影响最终值</p></blockquote><h3 id="分配律"><a href="#分配律" class="headerlink" title="分配律"></a>分配律</h3><ul><li><p>$A\cdot(B+C) = A\cdot B+ A\cdot C$</p><blockquote><p>左右式均可理解为：满足 $A$ 为真且 $B、C$ 均为真时才为真</p></blockquote></li><li><p>$A + B\cdot C = (A+B)\cdot (A+C)$</p><blockquote><p>左式成立条件为 $A$ 为真或 $B、C$ 均为真，右式成立条件为 $A$ 或 $B$ 为真且 $A$ 或 $C$ 为真，这个公式采用直接理解的方法比较抽象，但是可以根据后面的定律和第一个分配律进行反推，如下：</p></blockquote></li></ul><script type="math/tex; mode=display">(A+B)\cdot(A+C) = A\cdot A + A\cdot C+A\cdot B + B\cdot C</script><script type="math/tex; mode=display">= A + A\cdot(B+C)+B\cdot C = A + B\cdot C</script><h2 id="其它定律"><a href="#其它定律" class="headerlink" title="其它定律"></a>其它定律</h2><h3 id="同一律"><a href="#同一律" class="headerlink" title="同一律"></a>同一律</h3><ul><li>$A\cdot A = A$</li><li>$A+A = A$</li></ul><h3 id="还原律"><a href="#还原律" class="headerlink" title="还原律"></a>还原律</h3><ul><li>$\overline{\overline{A}} = A$</li></ul><h3 id="德摩根定理"><a href="#德摩根定理" class="headerlink" title="德摩根定理"></a>德摩根定理</h3><ul><li><p>$\overline{A\cdot B} = \overline{A} + \overline{B}$</p><blockquote><p>左式和右式都当且仅当 $A、B$ 均为真时为假，右式相当于与非的一种诠释</p></blockquote></li><li><p>$\overline{A+B} = \overline{A} \cdot \overline{B}$</p><blockquote><p>左式和右式都当且仅当 $A、B$ 均为假时为真，右式相当于或非的一种诠释</p></blockquote></li></ul><h2 id="三大规则"><a href="#三大规则" class="headerlink" title="三大规则"></a>三大规则</h2><h3 id="代入规则"><a href="#代入规则" class="headerlink" title="代入规则"></a>代入规则</h3><p>任何一个含有变量 $A$ 的等式，如果将所有出现 $A$ 的位置都用同一个逻辑函数代替，则等式仍然成立。这个规则称为代入规则。</p><p>即“整体换元”的方法在逻辑代数中合理并允许</p><h3 id="反演规则"><a href="#反演规则" class="headerlink" title="反演规则"></a>反演规则</h3><p>对于任何一个逻辑表达式 $Y$ ，如果：</p><ul><li>将表达式中的所有 $\cdot$ 运算符换成 $+$ 运算符，将表达式中的所有 $+$ 运算符换成 $\cdot$ 运算符</li><li>将所有 $0$ 换成 $1$ ，将所有 $1$ 换成 $0$</li><li>原变量换成反变量，反变量换成原变量</li></ul><p>那么我们称所得到的表达式为函数 $Y$ 的反函数 $\overline{Y}$ （或称补函数）</p><blockquote><p>e.g. $Y = A\overline{B}+C\overline{D}E$ 经过反演得到 $\overline{Y} = (\overline{A}+B)(\overline{C}+D+\overline{E})$</p></blockquote><p>反演规则的两个注意点：</p><ul><li>运算符优先级：括号 &gt; 或 &gt; 与</li><li>不属于单个变量上的反号应保留不变</li></ul><blockquote><p>e.g. $Y = A + \overline{B+\overline{C}+\overline{D + \overline{E}}}$ 经过反演得到 $\overline{Y} = \overline{A} \cdot \overline{\overline{B}\cdot C \cdot\overline{\overline{D}\cdot E}}$</p></blockquote><h3 id="对偶规则"><a href="#对偶规则" class="headerlink" title="对偶规则"></a>对偶规则</h3><p>对于任何一个逻辑表达式 $Y$ ，如果：</p><ul><li>将表达式中的所有 $\cdot$ 运算符换成 $+$ 运算符，将表达式中的所有 $+$ 运算符换成 $\cdot$ 运算符</li><li>变量保持不变</li></ul><p>那么我们称所得到的表达式为函数 $Y$ 的对偶函数 $Y’$</p><p>对偶规则的意义在于，使用它可以迅速扩充我们的公式库，它也是一种非常重要的等式转化方法——</p><blockquote><p>e.g. $A\cdot B+A\cdot \overline{B} = A$ 经过对偶得到一个新的公式 $(A+B)(A+\overline{B})=A$</p></blockquote><h2 id="常有定律"><a href="#常有定律" class="headerlink" title="常有定律"></a>常有定律</h2><ul><li><p>$AB + A\overline{B} = A$</p><blockquote><p>$B$ 和 $\overline{B}$ 必然有且只有一个为真 </p></blockquote></li><li><p>$A + AB = A$</p><blockquote><p>这种结构全式取决于 $A$ ，$A$ 为假则全式为假，$A$ 为真则全式为真</p></blockquote></li><li><p>$A + \overline{A}B = A + B$</p><script type="math/tex; mode=display">      A + \overline{A}B = (A+\overline{A})(A+B) = A+B</script></li><li><p>$AB + \overline{A}C+BC = AB + \overline{A}C$</p><blockquote><p>显然可知，$AB+\overline{A}C$ 可以看作一个整体，它的取值只有两种情况——$B$ 或 $C$ ，不论取 $B$ 还是 $C$ ，都会有 $B+BC = B$ 或 $C+BC= C$ ，即左式 = 右式</p></blockquote></li><li><p>$\overline{A\overline{B}+\overline{A}B} = AB+\overline{A} \cdot\overline{B}$</p></li></ul><script type="math/tex; mode=display">\overline{A\overline{B}+\overline{A}B} = \overline{\overline{(\overline{A}+B)(A+\overline{B})}} = \overline{A}A+\overline{A}\cdot\overline{B}+BA+B\overline{B} = \overline{A}\cdot\overline{B}+AB</script><hr><h1 id="（六）本课小结"><a href="#（六）本课小结" class="headerlink" title="（六）本课小结"></a>（六）本课小结</h1><ul><li>数字电路概述<ul><li>数字信号与模拟信号的定义和区别</li><li>数字电路的三个特点（离散、精度要求不高、研究逻辑关系）</li><li>数字电路分类（按集成度、所用器件制作工艺、结构和工作原理分类）</li></ul></li><li>数制和编码<ul><li>二进制、八进制、十进制、十六进制及其相互转换</li><li>$BCD$ 码类型和表示方法</li></ul></li><li>逻辑代数的公式定理<ul><li>逻辑符号的运算规定和电路表示</li><li>逻辑代数的基本定律</li></ul></li></ul><div class="note info flat"><p>下课！！！</p></div>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 数字逻辑与数字电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数字逻辑与数字电路的第一篇笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数项级数基本定理和习题</title>
      <link href="/2022/09/05/c%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B01%EF%BC%9A%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0/"/>
      <url>/2022/09/05/c%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B01%EF%BC%9A%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）柯西收敛原理"><a href="#（一）柯西收敛原理" class="headerlink" title="（一）柯西收敛原理"></a>（一）柯西收敛原理</h1><h2 id="定理-A-1"><a href="#定理-A-1" class="headerlink" title="定理 $A_1$"></a>定理 $A_1$</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\{a_n\}$ 是一个数列，则 $\{a_n\}$ 有极限的充分必要条件是：</p><script type="math/tex; mode=display">    \forall \epsilon > 0, \  \exist N>0, \quad  n,m\ge N, \quad  |a_n-a_m|<\epsilon</script><h2 id="定理-A-1-的另一种表达"><a href="#定理-A-1-的另一种表达" class="headerlink" title="定理 $A_1$ 的另一种表达"></a>定理 $A_1$ 的另一种表达</h2><h3 id="定理内容-1"><a href="#定理内容-1" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\{a_n\}$ 是一个数列，则 $\{a_n\}$ 有极限的充分必要条件是：</p><script type="math/tex; mode=display">    \forall \epsilon > 0 ,\ \exist N>0,\quad n \ge N,\ \forall p \in \mathbb{Z}^+,\quad |a_n-a_{n+p}|<\epsilon</script><h2 id="定理-A-1-函数形式"><a href="#定理-A-1-函数形式" class="headerlink" title="定理 $A_1$ 函数形式"></a>定理 $A_1$ 函数形式</h2><h3 id="定理内容-2"><a href="#定理内容-2" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $f(x)$ 在 $x_0$ 的一个空心邻域内有定义，则 $\lim\limits_{x\rightarrow x_0}f(x) = a$，当且仅当：</p><script type="math/tex; mode=display">\forall \varepsilon>0, \exists \delta>0 \text {,\ 只要 \ } 0<\left|x_{1}-x_{0}\right|<\delta,\ 0<\left|x_{2}-x_{0}\right|<\delta \text {\ , \ }就有 \left|f\left(x_{1}\right)-f\left(x_{2}\right)\right|<\varepsilon</script><h2 id="定理-B-1"><a href="#定理-B-1" class="headerlink" title="定理 $B_1$"></a>定理 $B_1$</h2><h3 id="定理内容-3"><a href="#定理内容-3" class="headerlink" title="定理内容"></a>定理内容</h3><p>设有级数 $\sum_{n=1}^{\infty}a_n$ 和 $\sum_{n=1}^{\infty}b_n$，且存在 $N&gt;0$，当 $n&gt;N$时，有$a_n=b_n$</p><p>则级数 $\sum_{n=1}^{\infty}a_n$ 和级数 $\sum_{n=1}^{\infty}b_n$ 同时收敛或同时发散 </p><h2 id="定理-B-2"><a href="#定理-B-2" class="headerlink" title="定理 $B_2$"></a>定理 $B_2$</h2><h3 id="定理内容-4"><a href="#定理内容-4" class="headerlink" title="定理内容"></a>定理内容</h3><p>级数前面加上或者去掉有限项, 不会影响级数的敛散性</p><h1 id="（二）无穷级数收敛基本定理"><a href="#（二）无穷级数收敛基本定理" class="headerlink" title="（二）无穷级数收敛基本定理"></a>（二）无穷级数收敛基本定理</h1><h2 id="定理-A-2"><a href="#定理-A-2" class="headerlink" title="定理 $A_2$"></a>定理 $A_2$</h2><h3 id="定理内容-5"><a href="#定理内容-5" class="headerlink" title="定理内容"></a>定理内容</h3><p>无穷级数 $S$ 收敛 $\iff$ $\lim\limits_{n\rightarrow \infty}S_n$ 存在（部分和序列有极限） $\iff$ 余项和 $r_n$ 满足 $\lim\limits_{n\rightarrow \infty}r_n=0$</p><h2 id="定理-B-3"><a href="#定理-B-3" class="headerlink" title="定理 $B_3$"></a>定理 $B_3$</h2><h3 id="定理内容-6"><a href="#定理内容-6" class="headerlink" title="定理内容"></a>定理内容</h3><p>无穷级数 $\sum_{n=1}^{\infty}u_n$ 收敛 $\iff$ $\forall\epsilon&gt;0,\exist N \in \mathbb{Z}^+,当n&gt;N时，对\forall p\in \mathbb{Z}^+,有|u_{n+1}+u_{n+2}+\cdots+u_{n+p}|&lt;\epsilon$</p><blockquote><p>级数 $\sum_{n=1}^\infty u_n$ 发散的充要条件是：$\exist \epsilon_0&gt;0，\forall N \in \mathbb{Z}^+，总\exist n_0&gt;N以及p_0\in\mathbb{Z}^+，有|u_{n_0+1}+u_{n_0+2}+\cdots+u_{n_0+p_0}|\ge \epsilon_0$ </p></blockquote><h2 id="定理-B-4"><a href="#定理-B-4" class="headerlink" title="定理 $B_4$"></a>定理 $B_4$</h2><h3 id="定理内容-7"><a href="#定理内容-7" class="headerlink" title="定理内容"></a>定理内容</h3><p>无穷级数 $S$ 收敛 $\Longleftarrow$ 无穷级数 $S$ 从某一项后开始收敛 $\Longleftarrow$ 部分和数列 $S_n$ 从某一项后开始单调有界</p><h2 id="定理-B-5"><a href="#定理-B-5" class="headerlink" title="定理 $B_5$"></a>定理 $B_5$</h2><h3 id="定理内容-8"><a href="#定理内容-8" class="headerlink" title="定理内容"></a>定理内容</h3><p>无穷级数 $S = \sum^{\infty}_{n=1}u_n$ 收敛 $\Longrightarrow$ $\lim\limits_{n\rightarrow \infty}u_n=0$</p><blockquote><p>$\lim\limits_{n\rightarrow\infty}u_n \ne 0$ $\Longrightarrow$ 无穷级数 $S = \sum^{\infty}_{n=1}u_n$ 发散</p></blockquote><h1 id="（三）收敛级数基本性质"><a href="#（三）收敛级数基本性质" class="headerlink" title="（三）收敛级数基本性质"></a>（三）收敛级数基本性质</h1><h2 id="定理-A-3"><a href="#定理-A-3" class="headerlink" title="定理 $A_3$"></a>定理 $A_3$</h2><h3 id="定理内容-9"><a href="#定理内容-9" class="headerlink" title="定理内容"></a>定理内容</h3><p>收敛级数的线性组合也是收敛级数，即：</p><script type="math/tex; mode=display">    若级数 \sum_{n=1}^{\infty}u_n收敛于a，级数 \sum_{n=1}^{\infty}v_n收敛于b，那么级数 c\sum_{n=1}^{\infty}u_n+d\sum_{n=1}^{\infty}v_n收敛于ca+db</script><h2 id="定理-B-6"><a href="#定理-B-6" class="headerlink" title="定理 $B_6$"></a>定理 $B_6$</h2><h3 id="定理内容-10"><a href="#定理内容-10" class="headerlink" title="定理内容"></a>定理内容</h3><p>如果两个级数一个收敛、一个发散，则它们的和或者差一定发散</p><p>如果两个级数都发散，它们的和或差不一定发散</p><h2 id="定理-A-4"><a href="#定理-A-4" class="headerlink" title="定理 $A_4$"></a>定理 $A_4$</h2><h3 id="定理内容-11"><a href="#定理内容-11" class="headerlink" title="定理内容"></a>定理内容</h3><p>收敛级数的项任意加括号后所形成的级数仍然收敛于原级数的和</p><p>若加括号以后的级数收敛，原级数不一定收敛</p><p>若加括号以后的级数发散，原级数一定发散</p><blockquote><p>加括号会“提升一个级数的收敛性”</p></blockquote><h1 id="（四）正项级数的收敛判别法"><a href="#（四）正项级数的收敛判别法" class="headerlink" title="（四）正项级数的收敛判别法"></a>（四）正项级数的收敛判别法</h1><h2 id="定理-A-6"><a href="#定理-A-6" class="headerlink" title="定理 $A_6$"></a>定理 $A_6$</h2><h3 id="定理内容-12"><a href="#定理内容-12" class="headerlink" title="定理内容"></a>定理内容</h3><p>正项级数 $\sum_{n=1}^\infty u_n$ 收敛 $\iff$ 部分和序列 $\{S_n\}$ 有上界</p><h2 id="定理-A-7-：比较判别法"><a href="#定理-A-7-：比较判别法" class="headerlink" title="定理 $A_7$ ：比较判别法"></a>定理 $A_7$ ：比较判别法</h2><h3 id="定理内容-13"><a href="#定理内容-13" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\sum_{n=1}^\infty u_n$ 和 $\sum_{n=1}^\infty v_n$ 是两个正项级数，且存在 $N\in \mathbb{Z}^+$，对一切 $n&gt;N$，都有 $u_n \le v_n$，则有：</p><p>若级数 $\sum_{n=1}^\infty v_n$ 收敛，则 $\sum_{n=1}^\infty u_n$ 收敛</p><p>若级数 $\sum_{n=1}^\infty u_n$ 发散，则 $\sum_{n=1}^\infty v_n$ 发散</p><h2 id="定理-B"><a href="#定理-B" class="headerlink" title="定理 $B$"></a>定理 $B$</h2><h3 id="定理内容-14"><a href="#定理内容-14" class="headerlink" title="定理内容"></a>定理内容</h3><p>若存在常数 $k,N&gt;0$，对于一切的 $n&gt;N$，应有：</p><p>若 $u_n&gt;\frac{k}{n}$，则 $\sum_{n=1}^\infty u_n$ 发散</p><p>若 $u_n\le \frac{k}{n_p}$ ，其中 $p&gt;1$ ，则 $u_n&gt;\frac{k}{n}$ 收敛</p><h2 id="定理-A-7-极限形式"><a href="#定理-A-7-极限形式" class="headerlink" title="定理 $A_7$ 极限形式"></a>定理 $A_7$ 极限形式</h2><h3 id="定理内容-15"><a href="#定理内容-15" class="headerlink" title="定理内容"></a>定理内容</h3><p>设两个正项级数 $\sum_{n=1}^\infty u_n$ 和 $\sum_{n=1}^\infty v_n$ 满足：$\lim\limits_{n\rightarrow \infty}\frac{u_n}{v_n}=l$，则有：</p><p>当 $l=0$ 时，若 $\sum_{n=1}^\infty v_n$ 收敛，$\sum_{n=1}^\infty u_n$ 收敛</p><p>当 $0&lt;l&lt;\infty$ 时，$\sum_{n=1}^\infty u_n$ 和 $\sum_{n=1}^\infty v_n$ 同时收敛或发散</p><p>当 $l=\infty$ 时，若 $\sum_{n=1}^\infty v_n$ 发散，$\sum_{n=1}^\infty u_n$ 也发散</p><h2 id="定理-A-：达朗贝尔判别法"><a href="#定理-A-：达朗贝尔判别法" class="headerlink" title="定理 $A$ ：达朗贝尔判别法"></a>定理 $A$ ：达朗贝尔判别法</h2><h3 id="定理内容-16"><a href="#定理内容-16" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\sum_{n=1}^\infty u_n$ 为正项级数，且 $\lim\limits_{n\rightarrow \infty}\frac{u_{n+1}}{u_{n}}=\rho$，则：</p><p>如果 $\rho&lt;1$ ，级数收敛</p><p>如果 $\rho&gt;1$（包括 $\rho=\infty$），级数发散</p><p>如果 $\rho=1$，级数可能收敛也可能发散</p><h2 id="定理-A-：-柯西判别法"><a href="#定理-A-：-柯西判别法" class="headerlink" title="定理 $A$ ： 柯西判别法"></a>定理 $A$ ： 柯西判别法</h2><h3 id="定理内容-17"><a href="#定理内容-17" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\sum_{n=1}^\infty u_n$ 为正项级数，且 $\lim\limits_{n \rightarrow \infty}\sqrt[n]{u_n}=\rho$，则</p><p>当 $\rho&lt;1$ 时，级数收敛</p><p>当 $\rho&gt;1$ 时，级数发散</p><p>当 $\rho=1$ 时，级数可能收敛也可能发散</p><h2 id="定理-A-：-积分判别法"><a href="#定理-A-：-积分判别法" class="headerlink" title="定理 $A$ ： 积分判别法"></a>定理 $A$ ： 积分判别法</h2><h3 id="定理内容-18"><a href="#定理内容-18" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\sum_{n=1}^\infty u_n$ 为正项级数，若存在一个单调下降的非负函数 $f(x)$ ，使得：</p><script type="math/tex; mode=display">u_n=f(n),n=1,2,\cdots</script><p>则级数 $\sum_{n=1}^\infty u_n$ 的敛散性和无穷积分 $\int_{1}^nf(x)dx$ 的敛散性一致 </p><h1 id="（五）任意项级数的收敛判别法"><a href="#（五）任意项级数的收敛判别法" class="headerlink" title="（五）任意项级数的收敛判别法"></a>（五）任意项级数的收敛判别法</h1><h2 id="定理-A"><a href="#定理-A" class="headerlink" title="定理 $A$"></a>定理 $A$</h2><h3 id="定理内容-19"><a href="#定理内容-19" class="headerlink" title="定理内容"></a>定理内容</h3><p>假设一个级数为 $\sum_{n=1}^{\infty}u_n$</p><p>如果 $\sum_{n=1}^{\infty}|u_n|$ 收敛，那么原级数 $\sum_{n=1}^{\infty}u_n$ 一定收敛（称原级数绝对收敛）</p><p>如果 $\sum_{n=1}^{\infty}u_n$ 收敛，加上绝对值后的级数 $\sum_{n=1}^{\infty}|u_n|$ 不一定收敛（称原级数条件收敛）</p><blockquote><p>加绝对值会“提升一个级数的收敛性”</p></blockquote><h2 id="定理-A-：-级数重排定理"><a href="#定理-A-：-级数重排定理" class="headerlink" title="定理 $A$ ： 级数重排定理"></a>定理 $A$ ： 级数重排定理</h2><h3 id="定理内容-20"><a href="#定理内容-20" class="headerlink" title="定理内容"></a>定理内容</h3><blockquote><p>引理：收敛的正项级数经过重排后仍收敛于原来的和</p></blockquote><p>若级数 $\sum_{n=1}^{\infty}u_n$ 绝对收敛于 $S$ ，则其重排后得到的级数 $\sum_{n=1}^{\infty}v_n$ 也  绝对收敛于 $S$ </p><blockquote><p>对绝对收敛的级数, 可以任意交换其各项的次序, 不会影响级数的和。但是对条件收敛的级数, 此性质并不成立</p></blockquote><h2 id="引理-C-：-阿贝尔引理"><a href="#引理-C-：-阿贝尔引理" class="headerlink" title="引理 $C$ ： 阿贝尔引理"></a>引理 $C$ ： 阿贝尔引理</h2><h3 id="引理-：-阿贝尔变换"><a href="#引理-：-阿贝尔变换" class="headerlink" title="引理 ： 阿贝尔变换"></a>引理 ： 阿贝尔变换</h3><p>设 $\alpha_i,\beta_i(i=1,2,\cdots,n)$ 是两组数，令 $B_i=\beta_1+\beta_2+\cdots+\beta_i(i=1,2,\cdots,m)$，则有下面这个变换成立：</p><script type="math/tex; mode=display">\sum_{i=1}^n\alpha_i\beta_i=\alpha_nB_n-\sum_{i=1}^{n-1}(\alpha_{i+1}-\alpha_i)B_i</script><h3 id="定理内容-21"><a href="#定理内容-21" class="headerlink" title="定理内容"></a>定理内容</h3><p>设 $\alpha_i,\beta_i\ (i=1,2,\cdots,n)$ 是两组实数，且满足条件：</p><ul><li>$\alpha_i$ 是单调的</li><li>对任意的 $i=1,2,\cdots,n$，部分和 $|B_i|=|\sum_{k=1}^i\beta_k|\le M$，其中 $M&gt;0$ 是常数</li></ul><p>以下不等式成立：</p><script type="math/tex; mode=display">|\sum_{i=1}^{n}\alpha_i\beta_i|\le M(|\alpha_1|+2|\alpha_n|)</script><h2 id="定理-A-：-狄利克雷判别法"><a href="#定理-A-：-狄利克雷判别法" class="headerlink" title="定理 $A$ ： 狄利克雷判别法"></a>定理 $A$ ： 狄利克雷判别法</h2><h3 id="定理内容-22"><a href="#定理内容-22" class="headerlink" title="定理内容"></a>定理内容</h3><p>若数列 $\{a_n\}$ 和数列 $\{b_n\}$ 满足</p><ul><li>$\lim\limits_{n\rightarrow \infty}a_n=0$，且 ${a_n}$ 单调</li><li><p>级数 $\sum_{n=1}^{\infty}b_n$ 的部分和序列有界，即存在常数 $M&gt;0$，使得 </p><script type="math/tex; mode=display">|\sum_{k=1}^nb_k|<M,\ n=1,2,\cdots</script><p>则级数 $\sum_{n=1}^\infty a_nb_n$ 收敛</p></li></ul><h2 id="定理-B-：-莱布尼兹判别法"><a href="#定理-B-：-莱布尼兹判别法" class="headerlink" title="定理 $B$ ： 莱布尼兹判别法"></a>定理 $B$ ： 莱布尼兹判别法</h2><h3 id="定理内容-23"><a href="#定理内容-23" class="headerlink" title="定理内容"></a>定理内容</h3><p>若交错级数 $\sum_{n=1}^\infty (-1)^{n-1}u_n$ 满足：</p><ul><li>$\lim\limits_{n\rightarrow \infty}u_n = 0$ ，即绝对值趋近于 $0$</li><li>$u_n \ge u_{n+1}\quad (n=1,2,\cdots)$ ，即绝对值单调递减</li></ul><p>则该交错级数收敛，且其和 $S\le u_1$ ，余项和 $r_n=S-S_n$ 满足 $|r_n|\le u_{n+1}$</p><h2 id="定理-A-：-阿贝尔判别法"><a href="#定理-A-：-阿贝尔判别法" class="headerlink" title="定理 $A$ ： 阿贝尔判别法"></a>定理 $A$ ： 阿贝尔判别法</h2><h3 id="定理内容-24"><a href="#定理内容-24" class="headerlink" title="定理内容"></a>定理内容</h3><p>若数列 $\{a_n\}$ 和数列 $\{b_n\}$ 满足</p><ul><li>$\{a_n\}$ <strong>单调有界</strong></li><li>级数 $\sum_{n=1}^\infty b_n$ <strong>收敛</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率论与数理统计开篇——储论</title>
      <link href="/2022/09/05/c%E6%A6%82%E7%BB%9F1%EF%BC%9A%E7%BB%AA%E8%AE%BA/"/>
      <url>/2022/09/05/c%E6%A6%82%E7%BB%9F1%EF%BC%9A%E7%BB%AA%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="（壹）概率统计开篇"><a href="#（壹）概率统计开篇" class="headerlink" title="（壹）概率统计开篇"></a>（壹）概率统计开篇</h1><p>该笔记主要用于记录中国人民大学信息学院《概率论与数理统计》课程的课堂重点、题型总结以及各种地方搜寻来的有关本门课程的资料。</p><center><img src = https://s1.ax1x.com/2022/09/05/vTN9XD.png width = 85%></center><blockquote><p>本笔记主要参考中国人民大学信息学院李亚平老师的课件，感谢老师的讲解和资料！</p><p>笔记中也可能会夹带各路大佬的材料，会在文末注明</p></blockquote><p>本门课程主要分为如下几个章节：</p><ul><li><p>概率部分</p><ul><li>概率论的基本概念</li><li>随机变量及其分布</li><li>多维随机变量及其分布</li><li>随机变量的数字特征</li></ul></li><li><p>统计部分</p><ul><li>大数定律和中心极限定理</li><li>数理统计的基本概念</li><li>参数估计</li><li>假设检验</li></ul></li></ul><p>那么，欢迎开启——概率统计世界！$Enjoy\; suffering\;!!!$</p><p>想到什么值得在一开始告诉新手的话学完再补，因为……我也才刚开始学</p><hr><h1 id="（贰）随机现象和随机试验"><a href="#（贰）随机现象和随机试验" class="headerlink" title="（贰）随机现象和随机试验"></a>（贰）随机现象和随机试验</h1><h2 id="随机现象"><a href="#随机现象" class="headerlink" title="随机现象"></a>随机现象</h2><p>自然界所观察到的现象基本可以分为两类: 确定性现象和随机现象。</p><p>在一定条件下必然发生的现象称为确定性现象</p><blockquote><p>e.g. “太阳不会从西边升起”、“同性电荷必然互斥”</p></blockquote><p>在一定条件下可能出现也可能不出现的现象称为随机现象</p><blockquote><p>e.g. “在相同条件下掷一枚均匀的硬币，观察正反两面出现的情况”</p></blockquote><h2 id="概率论"><a href="#概率论" class="headerlink" title="概率论"></a>概率论</h2><p>随机现象揭示了条件和结果之间的<strong>非确定性联系</strong> , 其<strong>数量关系无法用函数加以描述</strong></p><p>随机现象在一次观察中出现什么结果具有偶然性, 但在大量试验或观察中, 这种结果的出现具有一定的统计规律性，<strong>概率论就是研究随机现象规律性的一门数学学科</strong></p><h2 id="随机试验"><a href="#随机试验" class="headerlink" title="随机试验"></a>随机试验</h2><p>在概率论中,把具有以下三个特征的试验称为<strong>随机试验</strong></p><ul><li>可以在相同的条件下重复地进行；</li><li>每次试验的可能结果不止一个，并且能事先明确试验的所有可能结果；</li><li>进行一次试验之前不能确定哪一个结果会出现</li></ul><p><strong>随机现象是通过随机试验来研究的</strong></p><p>在概率论中，随机试验简称为试验，是一个广泛的术语，通常用 $E$ 来表示</p><hr><h1 id="（叁）样本空间和随机事件"><a href="#（叁）样本空间和随机事件" class="headerlink" title="（叁）样本空间和随机事件"></a>（叁）样本空间和随机事件</h1><h2 id="样本空间、样本点定义"><a href="#样本空间、样本点定义" class="headerlink" title="样本空间、样本点定义"></a>样本空间、样本点定义</h2><p>随机试验 $E$ 的所有可能结果组成的集合称为 $E$ 的样本空间，记为 $S$</p><p>样本空间的元素，即试验 $E$ 的每一个可能的结果，称为样本点</p><blockquote><p>e.g. 抛一枚质地均匀的硬币，观察字面、花面出现的情况</p><p>$S = \{H,T\}$ ，其中 $H$ 表示字面朝上，$T$ 表示花面朝上，$S$ 就是样本空间</p></blockquote><p>事实上，样本空间就是随机现象的数学模型，研究具体问题时，描述随机现象的第一步就是建立样本空间</p><h2 id="随机事件相关定义"><a href="#随机事件相关定义" class="headerlink" title="随机事件相关定义"></a>随机事件相关定义</h2><p>随机试验 $E$ 的样本空间 $S$ 的子集称为 $E$ 的随机事件, 简称事件，一般我们用大写英文字母来表示事件</p><blockquote><p>e.g. 抛掷一枚骰子, 观察出现的点数</p><p>试验中,骰子“出现 1 点”，“出现 2 点”， $\cdots$ ， “出现 6 点”，“点数不大于 4 ”，“点数为偶数” 等都为随机事件</p></blockquote><p>基本事件是指由一个样本点组成的单点集。</p><blockquote><p>事件可以包含多个样本点，基本事件只包含一个样本点</p><p>e.g. “出现 1 点”，“出现 2 点”，$\cdots$ ， “出现 6 点”</p></blockquote><center><img src = https://s1.ax1x.com/2022/09/07/vHTvCj.png width = 85%></center><p>此外，必然事件是随机试验中必然会出现的结果，不可能事件是随机试验中不可能出现的结果。</p><div class="note danger flat"><p>必然事件是发生概率为 $1$ 的事件，但是发生概率为 $1$ 的事件不一定是必然事件，不可能事件是发生概率为 $0$ 的事件，但是发生概率为 $0$ 的事件不一定是不可能事件</p><blockquote><blockquote><p>e.x. 在区间 $[0,1]$ 任取一个实数，这个实数是 $0.2$ 的概率为 $0$，但这是一个不可能事件</p></blockquote></blockquote></div><hr><h1 id="（肆）随机事件间的关系及运算"><a href="#（肆）随机事件间的关系及运算" class="headerlink" title="（肆）随机事件间的关系及运算"></a>（肆）随机事件间的关系及运算</h1><h2 id="基本关系定义"><a href="#基本关系定义" class="headerlink" title="基本关系定义"></a>基本关系定义</h2><p>设试验 $E$ 的样本空间为 $S$ ，而 $A,B,A_k\ (k=1,2,\cdots)$ 是 $S$ 的子集</p><h3 id="包含事件"><a href="#包含事件" class="headerlink" title="包含事件"></a>包含事件</h3><p>若事件 $A$ 出现，必然导致 $B$ 出现，则称事件 $B$ 包含事件 $A$ ，记作 $B \supset A$ 或 $A\subset B$</p><h3 id="相等事件"><a href="#相等事件" class="headerlink" title="相等事件"></a>相等事件</h3><p>若事件 $A$ 包含事件 $B$，并且事件 $B$ 包含事件 $A$，则称事件 $A$ 和事件 $B$ 相等，记作 $A= B$</p><h3 id="和事件（并）"><a href="#和事件（并）" class="headerlink" title="和事件（并）"></a>和事件（并）</h3><p>我们将和事件定义为：$A\cup B = \{x| x\in A 或 x \in B\}$</p><div class="note info flat"><p>和事件相当于逻辑代数中的 “$+$” 或离散数学中的 “$\land$” 运算得到的结果</p></div><h3 id="积事件（交）"><a href="#积事件（交）" class="headerlink" title="积事件（交）"></a>积事件（交）</h3><p>我们将积事件定义为 $A\cap B = \{x|x\in A且x\in B\}$ </p><div class="note info flat"><p>积事件相当于逻辑代数中的 “$\cdot$” 或离散数学中的 “$\lor$” 运算得到的结果</p></div><h3 id="互斥事件"><a href="#互斥事件" class="headerlink" title="互斥事件"></a>互斥事件</h3><p>若事件 $A$ 的出现必然导致事件 $B$ 不出现，事件 $B$ 的出现也必然导致 $A$ 不出现，则称事件 $A$ 和 $B$ 不相容，称为 $A\cap B = AB = \emptyset$</p><div class="note info flat"><p>互斥事件相当于逻辑代数中的 $\overline{AB} 或离散数学中的 $\lnot{(p\land q)}$$</p></div><h3 id="对立事件"><a href="#对立事件" class="headerlink" title="对立事件"></a>对立事件</h3><p>若 $A$ 表示事件 $A$ 出现，则事件 $A$ 不出现称为事件 $A$ 的对立事件或逆事件。记作 $\overline{A}$ </p><div class="note info flat"><p>逆事件相当于逻辑代数中的 $\overline{A}$ 或离散数学中的 $\lnot A$</p></div><h3 id="事件之差"><a href="#事件之差" class="headerlink" title="事件之差"></a>事件之差</h3><p>由事件 $A$ 出现而事件 $B$ 不出现所组成的事件称为事件 $A$ 与 $B$ 的差，记作 $A-B$</p><h2 id="事件间的运算规律"><a href="#事件间的运算规律" class="headerlink" title="事件间的运算规律"></a>事件间的运算规律</h2><h3 id="主要算律"><a href="#主要算律" class="headerlink" title="主要算律"></a>主要算律</h3><ul><li>交换律</li><li>结合律</li><li>分配律</li><li>摩根律</li></ul><div class="note info flat"><p>由于概率论的随机事件之间的算律和逻辑代数、离散数学的基本一致，故不再进行详细介绍</p><p>请点击该 <a href="">链接</a> 跳转参考《数字逻辑与数字电路》第一节的逻辑代数基础部分</p></div><h3 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h3><p>容斥原理指的是，事件的并集可以通过一些规律进行转化，如下式：</p><script type="math/tex; mode=display">P(E_1\cup E_2\cup\cdots\cup E_n) = \sum_{i=1}^nE_i-\sum_{i_1<i_2}P(E_{i_1}E_{i_2})+\cdots\\+(-1)^{r+1}P(E_{i_1}E_{i_2}\cdots E_{i_r})+\cdots+(-1)^{n+1}P(E_1E_2\cdots E_n)</script><p>一般情况下，我们使用较多的是二维容斥原理和三维容斥原理：</p><script type="math/tex; mode=display">P(E_1\cup E_2) = P(E_1)+P(E_2)-P(E_1E_2)</script><script type="math/tex; mode=display">P(E_1\cup E_2\cup E_3)= P(E_1)+P(E_2)+P(E_3)-P(E_1E_2)-P(E_2E_3)-P(E_1E_3) + P(E_1E_2E_3)</script><p>有上面三个公式，我们会将一些用事件交集比较难以表达的事件关系先用并集的形式表示出来，然后才使用容斥原理转化成有利于我们进行事件概率计算的并集的形式</p><h1 id="（伍）本节纲要"><a href="#（伍）本节纲要" class="headerlink" title="（伍）本节纲要"></a>（伍）本节纲要</h1><ul><li>随机现象和随机试验的概念</li><li>样本空间和随机事件：理清样本空间、基本事件、随机事件之间的关系</li><li>随机事件间的关系及运算：掌握事件间的运算规律，特别是容斥原理的利用</li></ul><h1 id="题型小结"><a href="#题型小结" class="headerlink" title="题型小结"></a>题型小结</h1><h2 id="题型一：样本空间和随机事件的表示"><a href="#题型一：样本空间和随机事件的表示" class="headerlink" title="题型一：样本空间和随机事件的表示"></a>题型一：样本空间和随机事件的表示</h2><div class="note warning flat"><p>难度：$\bigstar$</p><p>出错率：$\bigstar$</p></div><p>（1）对某工厂出厂的产品进行检查, 合格的记上“正品”, 不合格的记上“次品”, 如连续查出了 $2$ 件次品就停止检查, 或检查了 $4$ 件产品就停止检查, 记录检查的结果。</p><p>解：$S = \{1111,1110,1101,1100,1011,1010,100,0111,0110,0101,0100,00\}$</p><p>其中每一串有序的二进制数字都表示检查的结果，$0$ 代表次品，$1$ 代表正品</p><p>（2）$A$ 发生, $B$ 与 $C$ 不发生.</p><p>解： $A\cap(\overline{B\cup C}) = A \cap\overline{B}\cap\overline{C}$ </p><p>（3）$A, B, C$ 中至少有一个发生.</p><p>解： $A \cup B\cup C$</p><p>（4）$A,B,C$ 都不发生</p><p>解： $\overline{A\cup B\cup C} = \overline{A}\cdot \overline{B}\cdot\overline{C}$</p><h2 id="题型二：根据事件间的关系计算发生概率"><a href="#题型二：根据事件间的关系计算发生概率" class="headerlink" title="题型二：根据事件间的关系计算发生概率"></a>题型二：根据事件间的关系计算发生概率</h2><div class="note warning flat"><p>难度：$\bigstar\bigstar$</p><p>出错率：$\bigstar\bigstar\bigstar$</p></div><h3 id="解题技巧"><a href="#解题技巧" class="headerlink" title="解题技巧"></a>解题技巧</h3><ul><li>技巧 $1$ ：运用容斥原理，将和事件 $A\cup B$ 转化为并事件 $A\cap B$ 进行计算</li><li>技巧 $2$ ：当 $A,B$ 事件<strong>相互独立</strong>（<strong>互不相容</strong>）时，会有 $P(A\overline{B}) = P(A) - P(AB)$<blockquote><p>$P(A\overline{B}) = P(A(S-B)) = P(AS) - P(AB) = P(A) - P(AB)$ ，$S$ 指的是 $A$ 和 $B$ 的样本空间</p></blockquote></li><li>技巧 $3$ ：可以将一些用关系符号联结在一起的“复合事件”看作一个整体，然后使用技巧 $1$、$2$ 进行处理</li></ul><h3 id="易错提醒"><a href="#易错提醒" class="headerlink" title="易错提醒"></a>易错提醒</h3><ul><li>很多题目中，事件已经不再是相互独立的关系了，要警惕这一点，不要陷入以下惯性思维</li></ul><div class="note danger flat"><ul><li>事件 $A\cap B$ 的概率是 $P(A)\cdot P(B)$</li><li>事件 $\bar{A}\cup B$ 的概率是 $P(\bar{A})\cdot P(B)$</li></ul></div><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>设 $A, B, C$ 是三个事件, 且 $P(A)=P(B)=P(C)=1 / 4, P(A B)=P(B C)=0$, $P(A C)=1 / 8$, 求 $A, B, C$ 至少有一个发生的概率.</p><p>误解：<br><div class="note danger flat"><p>没有考虑到非独立事件的陷阱</p></div></p><script type="math/tex; mode=display">只发生一个事件：P_1 = P(A)P(\overline{B})P(\overline{C})+P(\overline{A})P({B})P(\overline{C})+P(\overline{A})P(\overline{B})P({C}) = \frac{27}{64}</script><script type="math/tex; mode=display">发生两个事件：P_2 = P(AC) = \frac{1}{8}</script><script type="math/tex; mode=display">发生三个事件：P_3 = 0</script><script type="math/tex; mode=display">A,B,C至少发生一个的概率是 P= P_1+P_2+P_3= \frac{35}{64}</script><p>正解：</p><div class="note info flat"><p>使用容斥原理解题</p></div><script type="math/tex; mode=display">   \because 0 \le P(ABC)\le P(AB) = 0,\;\therefore P(ABC) = 0</script><script type="math/tex; mode=display">根据容斥原理有P(A\cup B\cup C) = P(A)+P(B)+P(C)-P(AB)\\-P(BC)-P(AC)+P(ABC) = \frac{5}{8}</script><h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>已知 $P(A)=1 / 2,\; P(B)=1 / 3,\; P(C)=1 / 5,\; P(A B)=1 / 10,\; P(A C)=1 / 15,\; P(B C)=$ $1 / 20,\; P(A B C)=1 / 30$,  求 $A \cup B,\; \bar{A} \bar{B},\; A \cup B \cup C,\; \bar{A} \bar{B} \bar{C},\; \bar{A} \bar{B} C, \bar{A} \bar{B} \cup C$ 的概率.</p><div class="note info flat"><p>综合运用技巧 $1$、$2$、$3$</p></div><p>解：</p><script type="math/tex; mode=display">P(A\cup B) = P(A) +P(B) - P(AB)  = \frac{11}{15}</script><script type="math/tex; mode=display">P(\bar{A}\bar{B}) = P(\overline{A\cup B}) = 1 - P(A\cup B) = 1- \frac{11}{15} = \frac{4}{15}</script><script type="math/tex; mode=display">P(A\cup B\cup C)  = P(A)+P(B)+P(C)-P(A)P(B)-P(B)P(C)-P(A)P(C) + P(ABC) = \frac{17}{20}</script><script type="math/tex; mode=display">    P(\bar{A}\bar{B}\bar{C}) = P(\overline{A\cup B\cup C}) = 1 - P(A\cup B \cup C) = \frac{3}{20}</script><script type="math/tex; mode=display">    P(\bar{A}\bar{B}C) = P(\bar{A}\bar{B}) - P(\bar{A}\bar{B}\bar{C}) = \frac{7}{60}</script><script type="math/tex; mode=display">    P(\bar{A}\bar{B}\cup C) = P(\bar{A}\bar{B})+P(C)-P(\bar{A}\bar{B}C) = \frac{7}{20}</script><h2 id="题型三：利用排列组合知识解题"><a href="#题型三：利用排列组合知识解题" class="headerlink" title="题型三：利用排列组合知识解题"></a>题型三：利用排列组合知识解题</h2><div class="note info flat"><p>考察高中基础知识，不作详述</p></div><h3 id="例一-1"><a href="#例一-1" class="headerlink" title="例一"></a>例一</h3><p>一倶乐部有 $5$ 名一年级学生, $2$ 名二年级学生, $3$ 名三年级学生, $2$ 名四年级学生.</p><p>在其中任选 $5$ 名学生,求一、二、三、四年级的学生均包含在内的概率.</p><p>误解：</p><script type="math/tex; mode=display">一、二、三、四年级的学生均包含在内的概率P = \\\frac{C_5^1C_2^1C_3^1C_2^1C_8^1}{C_{12}^5} = \frac{20}{33}</script><div class="note danger flat"><p>注意因为顺序导致的重复问题</p><p>这个误解的错因在于没有考虑以下情形：比如第一次 $C_5^1$ 取的是学生 $A$ ，第二次 $C_8^1$ 取得是学生 $B$，这和第一次 $C_5^1$ 取的是学生 $B$， ，第二次 $C_8^1$ 取得是学生 $A$。两种情况并没有实质上的区别，因此出现重复。</p></div><p>正解：</p><script type="math/tex; mode=display">一、二、三、四年级的学生均包含在内的概率P= \\\frac{C_5^2C_2^1C_3^1C_2^1}{C_{12}^5}+\frac{C_5^1C_2^2C_3^1C_2^1}{C_{12}^5}+\frac{C_5^1C_2^1C_3^2C_2^1}{C_{12}^5}+\frac{C_5^1C_2^1C_3^1C_2^2}{C_{12}^5} = \frac{10}{33}</script><h3 id="例二-1"><a href="#例二-1" class="headerlink" title="例二"></a>例二</h3><p>某油漆公司发出 $17$ 桶油漆, 其中白漆 $10$ 桶、黑漆 $4$ 桶、红漆 $3$ 桶, 在搬运中所有标签 脱落, 交货人随意将这些油漆发给顾客. 问一个订货为 $4$ 桶白漆、$3$ 桶黑漆和 $2$ 桶红漆的顾客, 能按所订颜色如数得到订货的概率是多少?</p><p>解：</p><script type="math/tex; mode=display">    如数得到订货的概率 P = \frac{C_{10}^4C_{4}^3C_3^2}{C_{17}^{9}} = \frac{252}{2431}</script>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概率论与数理统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数项级数基本定理和习题</title>
      <link href="/2022/09/05/c%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B02%EF%BC%9A%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0/"/>
      <url>/2022/09/05/c%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B02%EF%BC%9A%E5%87%BD%E6%95%B0%E9%A1%B9%E7%BA%A7%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>函数项级数的概念比较复杂，因此这里不同前面几个小节，附加整理一下函数项级数的基本知识点</p><h1 id="基本概念定义"><a href="#基本概念定义" class="headerlink" title="基本概念定义"></a>基本概念定义</h1><h2 id="函数项级数-amp-和函数"><a href="#函数项级数-amp-和函数" class="headerlink" title="函数项级数 &amp; 和函数"></a>函数项级数 &amp; 和函数</h2><p>设 $u_n(x)\quad(n=1,2,\cdots,n)$ 为定义在集合 $D$ 上的函数序列，称 $\sum_{n=1}^\infty u_n(x)=u_1(x)+u_2(x)+\cdots$ 为定义在 $D$ 上的<strong>函数项级数</strong></p><p>如果这个函数项级数<strong>收敛</strong>到一个关于 $x$ 的函数，这时函数项级数（就是这个函数）也称作<strong>和函数</strong></p><h2 id="收敛域"><a href="#收敛域" class="headerlink" title="收敛域"></a>收敛域</h2><p>我们取定一个 $x$ 的值 $x_0$，函数项级数就会坍缩成一个数项级数 ： 若数项级数 $\sum_{n=1}^\infty u_n(x_0)$ 收敛，则称 $x_0$ 为该函数项级数的收敛点，所有收敛点的全体称为收敛域<br>9</p><blockquote><p>这里为什么采用了“坍缩”这样的字眼？因为我对函数项级数特殊的理解：</p><p>可以把数项级数看作是一个特殊的数组，把函数序列看成特殊的矩阵（也许它们都不满足这样的定义，但是我们可以用特殊的观点区别地看待它们）</p><script type="math/tex; mode=display">\begin{pmatrix}u_1(x_1)&u_1(x_2)&u_1(x_3)&\cdots&u_1(x_m)&\cdots\\u_2(x_1)&u_2(x_2)&u_2(x_3)&\cdots&u_2(x_m)&\cdots\\u_3(x_1)&u_3(x_2)&u_3(x_3)&\cdots&u_3(x_m)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\u_n(x_1)&u_n(x_2)&u_n(x_3)&\cdots&u_n(x_m)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\\end{pmatrix}</script><p>这个特殊的“矩阵”的特点就是：$x_i$ 序列是连续并且致密的，$m$ 和 $n$ 都是趋近于正无穷的，即行之间离散，列之间致密</p><p>矩阵的每一行都是一个</p></blockquote><h2 id="发散域"><a href="#发散域" class="headerlink" title="发散域"></a>发散域</h2><p>我们取定一个 $x$ 的值 $x_0$，函数项级数就会坍缩成一个数项级数 ： 若数项级数 $\sum_{n=1}^\infty u_n(x_0)$ 发散，则称 $x_0$ 为该函数项级数的发散点，所有收敛点的全体称为发散域</p><h2 id="余项（和）"><a href="#余项（和）" class="headerlink" title="余项（和）"></a>余项（和）</h2><p>我们用 $S_n(x) = \sum_{i=1}^nu_i(x)$ 表示函数项级数的前 $n$ 项和</p><p>函数项级数和函数项级数的前 $n$ 项和的差被称为余项和，即：$r_n(x)=S(x)-S_n(x)$</p><p>如果 $x_0$ 属于收敛域，那么会有：$\lim\limits_{n\rightarrow\infty}S_n(x_0)=S(x_0),\ \lim\limits_{n\rightarrow\infty}r_n(x_0)=0$</p><h2 id="函数序列点态收敛"><a href="#函数序列点态收敛" class="headerlink" title="函数序列点态收敛"></a>函数序列点态收敛</h2><p>函数序列（某函数项级数的前 $n$ 项和） $\{S_n(x)\}$ 在集合 $D$ 上点态收敛于 $S(x)$ 指的是对于任意的 $x_0\in D$ ，$\lim\limits_{n\rightarrow \infty}S_n(x_0)=S(x_0)$</p><p>数学语言表达为：</p><script type="math/tex; mode=display">\begin{gathered}\forall x_{0} \in D \text { 以及 } \varepsilon>0,\, \exists N=N\left(x_{0}, \varepsilon\right), \text { 使得当 } n>N \text { 时, 有 } \\\left|S_{n}\left(x_{0}\right)-S\left(x_{0}\right)\right|<\varepsilon .\end{gathered}</script><blockquote><p>$N(x_0,\epsilon)$ 意味着数学语言中 $N$ 的值随着 $x_0$ 的变化而变化</p><p>用上面“矩阵”的观点看：可以理解为当我们取定一个 $\epsilon$ 的值 $\epsilon_0$ 时，每一行取得满足条件 $\left|S_{n}\left(x_{0}\right)-S\left(x_{0}\right)\right|&lt;\varepsilon$ 的 $N$ 值都不一样，并且往往 $\epsilon_0$ 越小，对 $N$ 值得要求越苛刻，最后到达极端的情况</p><p>换而言之，$N(x_0,\epsilon)$ 也意味着矩阵中的每一行由于 $x_0$ 值的不同，收敛于对应的极限值的速度也是不一样的</p></blockquote><h2 id="函数序列一致收敛"><a href="#函数序列一致收敛" class="headerlink" title="函数序列一致收敛"></a>函数序列一致收敛</h2><p>函数序列（某函数项级数的前 $n$ 项和） $\{S_n(x)\}$ 在集合 $D$ 上一致收敛于 $S(x)$ 指的是对于任意给定的 $\epsilon&gt;0$ ，总存在一个只依赖于 $\epsilon$ 的自然数 $N$ ，使得当 $n&gt;N$ 时，对于集合 $D$ 上的一切 $x$ 都有 $|S_n(x)-S(x)|&lt;\epsilon$ ，记作 $S_n(x)\rightrightarrows S(x)$</p><p>用数学语言表达为：</p><p>$\forall \varepsilon&gt;0 ,\ \exists N=N(\varepsilon)$ , 使得当 $n&gt;N$ 时, 对 $\forall x \in D$, 有</p><script type="math/tex; mode=display">\left|S_{n}(x)-S(x)\right|<\varepsilon .</script><blockquote><p>$N(\epsilon)$ 意味着数学语言中 $N$ 的值不会随着 $x$ 的值变化</p><p>用上面的矩阵的观点理解：一致收敛表明：每次取定一个 $\epsilon_0$ 时，矩阵每行的数项级数在达到一个足够大的 $N$ 后，都会充分趋近于极限，可以用下面的图来表示：</p><center><img src = https://s1.ax1x.com/2022/09/20/xCUYUH.png width = 50%></center><p>在这个图中，我们假定的矩阵的每一列的致密连续值都形成一条曲线</p><p>而矩阵每一行构成的数列的极限值都能形成一个列，即 $\lim\limits_{n\rightarrow\infty}S_n(x_i),\, i=1,2,\cdots$，记为 $S(x)$</p><p>第 $j$ 列代表的“致密数列” $S_j(x_i),\, i=1,2,\cdots$ 形成的曲线只要在 $j&gt;N$ 的区间内都会分布在以 $S(x)$ 为中轴的带状区域内</p></blockquote><h2 id="函数序列在收敛域上不一致收敛"><a href="#函数序列在收敛域上不一致收敛" class="headerlink" title="函数序列在收敛域上不一致收敛"></a>函数序列在收敛域上不一致收敛</h2><p>设函数序列 $\{S_n(x)\}$ 在 $D$ 上点态收敛于 $S(x)$ 。我们将函数序列不一致收敛定义为：</p><script type="math/tex; mode=display">\begin{gathered}\exists \varepsilon_{0}>0, \forall N>0, \text { 总存在 } n_{0}>N \text { 以及 } x_{0} \in D, \text { 有 } \\\left|S_{n_{0}}\left(x_{0}\right)-S\left(x_{0}\right)\right| \geq \varepsilon_{0} .\end{gathered}</script><blockquote></blockquote><h2 id="函数项级数一致收敛"><a href="#函数项级数一致收敛" class="headerlink" title="函数项级数一致收敛"></a>函数项级数一致收敛</h2><p>上面已经定义了函数序列一致收敛，而函数项级数一致收敛实际上指的就是函数序列的部分和序列一致收敛</p><p>设函数项级数 $\sum_{n=1}^{\infty}u_n(x)$ 的每一项都在集合 $D$ 上有定义。若其部分和序列 $S_n(x)=\sum_{i=1}^n u_i(x)$ 在集合 $D$ 上一致收敛，则称函数项级数 $\sum_{n=1}^\infty u_n(x)$ 在 $D$ 上一致收敛</p><blockquote><p>我们在上面提出了一个函数序列矩阵的概念，我们可以用它进一步解释函数项级数：</p></blockquote><script type="math/tex; mode=display">\begin{pmatrix}u_1(x_1)&u_2(x_1)&u_3(x_1)&\cdots&u_n(x_1)&\cdots\\u_1(x_2)&u_2(x_2)&u_3(x_2)&\cdots&u_n(x_2)&\cdots\\u_1(x_3)&u_2(x_3)&u_3(x_3)&\cdots&u_n(x_3)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\u_1(x_m)&u_2(x_m)&u_3(x_m)&\cdots&u_n(x_m)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\\end{pmatrix}</script><blockquote><p>对这个函数序列矩阵进行处理，使其第 $i$ 行第 $j$ 列的元素为：$\sum_{k=1}^j u_k(x_i),\;\;\; i = 1,2,\cdots,n$ ，记作 $S_j(x_i)$ 得到如下矩阵</p></blockquote><script type="math/tex; mode=display">\begin{pmatrix}S_1(x_1)&S_2(x_1)&S_3(x_1)&\cdots&S_n(x_1)&\cdots\\S_1(x_2)&S_2(x_2)&S_3(x_2)&\cdots&S_n(x_2)&\cdots\\S_1(x_3)&S_2(x_3)&S_3(x_3)&\cdots&S_n(x_3)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\S_1(x_m)&S_2(x_m)&S_3(x_m)&\cdots&S_n(x_m)&\cdots\\\vdots&\vdots&\vdots&\ddots&\vdots&\ddots\\\end{pmatrix}</script><blockquote><p>这个矩阵的每一行（不同行的区别在于 $x$ 值不同）的极限值都会是： $\lim\limits_{k\rightarrow\infty}\sum_{k=1}^j u_k(x_i)$</p><p>极限 $\lim\limits_{k\rightarrow\infty}\sum_{k=1}^j u_k(x_i)$ 存在的行称为收敛域，极限 $\lim\limits_{k\rightarrow\infty}\sum_{k=1}^j u_k(x_i)$ 不存在的行称为发散域</p><p>将属于收敛域的每一行的得到的 $\lim\limits_{k\rightarrow\infty}\sum_{k=1}^j u_k(x_i)$ 组成一条曲线——<strong>函数项级数</strong></p></blockquote><h2 id="定理-B"><a href="#定理-B" class="headerlink" title="定理 $B$"></a>定理 $B$</h2><h3 id="定理内容"><a href="#定理内容" class="headerlink" title="定理内容"></a>定理内容</h3><p>设函数序列 $\{S_n(x)\}$ 在区间 $D$ 上<strong>点态收敛</strong>到极限函数 $S(x)$。如果存在一个数列 $a_n$ 满足 $\lim\limits_{n\rightarrow\infty}a_n=0$ ，使得：</p><script type="math/tex; mode=display">\left|S_{n}(x)-S(x)\right| \leq a_{n}, \forall x \in D, n>N</script><p>则 $\{S_n(x)\}$ 在 $D$ 上一致收敛于 $S(x)$</p><h2 id="定理-B-1"><a href="#定理-B-1" class="headerlink" title="定理 $B$"></a>定理 $B$</h2><h3 id="定理内容-1"><a href="#定理内容-1" class="headerlink" title="定理内容"></a>定理内容</h3><p>设函数序列 $\{S_n(x)\}$ 在区间 $D$ 上<strong>点态收敛</strong>到极限函数 $S(x)$。如果存在常数 $l&gt;0$ 以及点列 $x_n\in D$ ，使得当 $n&gt;N(N\in\mathbb{Z^+})$ ，有：</p><script type="math/tex; mode=display">\left|S_{n}\left(x_{n}\right)-S\left(x_{n}\right)\right| \geq l</script><p>则 $S_n(x)$ 在 $D$ 上不一致收敛</p><h2 id="定理-B-2"><a href="#定理-B-2" class="headerlink" title="定理 $B$"></a>定理 $B$</h2><h3 id="定理内容-2"><a href="#定理内容-2" class="headerlink" title="定理内容"></a>定理内容</h3><p>设函数序列 $\{S_n(x)\}$ 在区间 $D$ 上点态收敛到极限函数 $S(x)$。若存在点列 $x_n\in D$ ，使得</p><script type="math/tex; mode=display">\lim _{n \rightarrow \infty}\left[S_{n}\left(x_{n}\right)-S\left(x_{n}\right)\right]=k \neq 0</script><p>则 $S_n(x)$ 在 $D$ 上不一致收敛</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 高等数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高等数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命题逻辑与合式公式</title>
      <link href="/2022/09/05/c%E7%A6%BB%E6%95%A31%E5%91%BD%E9%A2%98%E5%92%8C%E5%85%AC%E5%BC%8F/"/>
      <url>/2022/09/05/c%E7%A6%BB%E6%95%A31%E5%91%BD%E9%A2%98%E5%92%8C%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）离散数学开篇"><a href="#（一）离散数学开篇" class="headerlink" title="（一）离散数学开篇"></a>（一）离散数学开篇</h1><p>这是离散数学系列的第一篇笔记！！！（Congratulations!）</p><center><img src = https://s1.ax1x.com/2022/09/07/vH7asP.png width = 85%></center><blockquote><p>本笔记主要参考中国人民大学信息学院李德英老师的课件，感谢老师的讲解和资料！</p><p>笔记中也可能会夹带各路大佬的材料，会在文末注明</p></blockquote><p>本笔记涉及的离散数学包括以下章节，即人民大学图灵班离散数学荣誉课程的教学内容，后续可能视情况作其它知识补充</p><ul><li>数理逻辑</li><li>集合论</li><li>代数结构</li><li>组合数学</li></ul><p>那么，欢迎开启——离散数学世界！$Enjoy\; suffering\;!!!$</p><p>想到什么值得在一开始告诉新手的话学完再补，因为……我也才刚开始学</p><h1 id="（二）命题逻辑基本概念"><a href="#（二）命题逻辑基本概念" class="headerlink" title="（二）命题逻辑基本概念"></a>（二）命题逻辑基本概念</h1><h2 id="是否为命题的判别"><a href="#是否为命题的判别" class="headerlink" title="是否为命题的判别"></a>是否为命题的判别</h2><p>命题是指<strong>判断结果唯一</strong>的陈述句，命题的判断结果被称为命题的<strong>真值</strong>，真值只有“真”和“假”<strong>两种取值</strong></p><p>为了更好地判断一个句子是否为命题，我们应该知道下面几种<strong>不是</strong>命题的情况——</p><ul><li><p><strong>感叹句、祈使句、疑问句</strong>都不是命题</p><blockquote><p>e.g. 离散数学真奇妙呀！</p></blockquote></li><li><p><strong>悖论</strong>不是命题</p><blockquote><p>e.g. 这句话是一句假话</p></blockquote></li><li><p>判断<strong>结果不唯一确定</strong>的不是命题</p><blockquote><p>e.g. $x + 5 &gt; 3$</p></blockquote></li></ul><h2 id="命题的分类和符号化"><a href="#命题的分类和符号化" class="headerlink" title="命题的分类和符号化"></a>命题的分类和符号化</h2><p>命题可以分为<strong>简单命题</strong>和<strong>复合命题</strong></p><ul><li>简单命题（原子命题）：不能再分解成更简单的命题</li><li>复合命题：由简单命题通过联结词联结而成的命题</li></ul><p>简单命题可以进行<strong>符号化</strong>，即通过 $p,q,r,\cdots,p_i,q_i,r_i$ 来表示简单命题</p><h1 id="（三）命题联结词与复合命题"><a href="#（三）命题联结词与复合命题" class="headerlink" title="（三）命题联结词与复合命题"></a>（三）命题联结词与复合命题</h1><h2 id="命题联结词"><a href="#命题联结词" class="headerlink" title="命题联结词"></a>命题联结词</h2><h3 id="否定联结词-lnot"><a href="#否定联结词-lnot" class="headerlink" title="否定联结词 $\lnot$"></a>否定联结词 $\lnot$</h3><p>设 $p$ 为命题，复合命题“非 $p$ ”（或“ $p$ 的否定”）称为 $p$ 的否定式，记作 $\lnot p$</p><p>符号 $\lnot$ 称作否定联结词，$\lnot p$ 为真当且仅当 $p$ 为假</p><h3 id="合取联结词-land"><a href="#合取联结词-land" class="headerlink" title="合取联结词 $\land$"></a>合取联结词 $\land$</h3><p>设 $p,q$ 为两个命题，复合命题 $p$ 并且 $q$ （ $p$ 与 $q$ ）称为 $p$ 与 $q$ 的合取式，记作 $p\land q$</p><p>符号 $\land$ 被称为合取联结符，$p\land q$ 为真当且仅当 $p$ 与 $q$ 同时为真</p><h3 id="析取联结词-lor"><a href="#析取联结词-lor" class="headerlink" title="析取联结词 $\lor$"></a>析取联结词 $\lor$</h3><p>设 $p, q$ 为两个命题，复合命题 $p$ 或 $q$ 称为 $p$ 与 $q$ 的析取式，</p><p>复合命题 $p\lor q$ 为假当且仅当 $p$ 与 $q$ 同时为假。 </p><blockquote><p>一些情况虽然在自然语言下也用“或”表达，但仅仅用 $\lor$ 联结词并不能保证符合原意：</p><blockquote><p>e.g. $2$ 是一个奇数或偶数</p><p>e.g. 小明今年 $18$ 岁或 $19$ 岁</p></blockquote><p>这些情况的前后两个命题中还具有<strong>互斥</strong>（不可能同时为真和同时为假）的关系，使用复合命题 $(\lnot p \land q)\lor(\lnot q \land p)$ 进行描述更加合适，当然，也可以符号化为 $r\lor s$ ——<strong>在数理逻辑中，我们总是认为符号 $r$ 和 $s$ 是互斥的</strong></p></blockquote><h3 id="蕴涵联结词-to"><a href="#蕴涵联结词-to" class="headerlink" title="蕴涵联结词 $\to$"></a>蕴涵联结词 $\to$</h3><p>设 $p, q$ 为二命题，复合命题“如果 $p$ ，则 $q$ ”称作 $p$ 与 $q$ 的蕴涵式，记作 $p\to q$，并称 $p$ 是蕴涵式的前件，$q$ 为蕴涵式的后件</p><p>符号 $\to$ 被称为蕴涵联结词，$p\to q$ 为假当且仅当 $p$ 为真时 $q$ 为假。</p><blockquote><p><del>口诀（bushi）：前为真，后为假，则为假</del></p></blockquote><p>当 $p$ 为假时蕴涵式恒为假，蕴涵式 $p\to q$ 和蕴涵式 $\lnot q \to \lnot p$ 等值</p><blockquote><p>这个联结词比较容易出现判断失误。在数理逻辑的世界里，请不要试图通过通常认知的因果关系来理解蕴涵联结词</p><p>对蕴涵式的判断其实可以直接从定义入手：$p\to q$ 为假当且仅当 $p$ 为真时 $q$ 为假。</p><p>下面这样的句子，蕴涵可以成立，但套用因果未免显得离谱：</p><blockquote><p>e.g. 如果 $1+1=2$，那么明天太阳会从东边升起</p><p>e.g. 如果 $1+1\ne 2$，那么明天太阳会从西边升起</p></blockquote><p>而事实上，$1+1=2\to$ 明天太阳东边升起，和 $1+1\ne 2\to$ 明天太阳西边升起都是正确的蕴涵式</p></blockquote><h3 id="等价联结词-leftrightarrow"><a href="#等价联结词-leftrightarrow" class="headerlink" title="等价联结词 $\leftrightarrow$"></a>等价联结词 $\leftrightarrow$</h3><p>设 $p,q$ 为两个命题，复合命题“$p$ 当且仅当 $q$”称作 $p$ 与 $q$ 的等价式，记作 $p\leftrightarrow q$</p><p>$p\leftrightarrow q$ 称作等价联结词。$p\leftrightarrow q$ 为真当且仅当 $p$ 和 $q$ 同时为真或同时为假</p><h3 id="复合命题的判断"><a href="#复合命题的判断" class="headerlink" title="复合命题的判断"></a>复合命题的判断</h3><p>如果一个命题是通过自然语言描述，要先将这个命题从自然语言转化为数理逻辑语言，然后根据联结词成立的条件进行判断。</p><p>否定联结词、合取联结词、析取联结词、等价联结词的自然语言特征都十分容易辨认。</p><blockquote><p><del>还是提醒一下“一面…一面…”是合取</del></p></blockquote><p>所以重点谈谈蕴涵联结词的自然语言关键词：</p><ul><li>若 $p$，就 $q$</li><li>只要 $p$，就 $q$</li><li>$q$ 仅当 $p$</li><li>只有 $q$ 才 $p$</li><li>除非 $q$ 才 $p$</li><li>除非 $q$ 否则非 $p$</li></ul><p>另外，复合命题中还应该注意联结词的运算顺序：</p><p>$()$ 、$\lnot$ 、$\land$ 、$\lor$ 、$\to$ 、 $\leftrightarrow$</p><h1 id="（四）命题公式基本概念"><a href="#（四）命题公式基本概念" class="headerlink" title="（四）命题公式基本概念"></a>（四）命题公式基本概念</h1><h2 id="命题变项和合式公式"><a href="#命题变项和合式公式" class="headerlink" title="命题变项和合式公式"></a>命题变项和合式公式</h2><blockquote><p>命题变项（命题变元）：可表示任意其值未定的命题的符号称为命题变元</p><p>命题常项：简单命题，其真值是确定不变的。</p></blockquote><h3 id="合式公式的定义"><a href="#合式公式的定义" class="headerlink" title="合式公式的定义"></a>合式公式的定义</h3><p>合式公式采用递归的方式进行定义（归纳定义法）：</p><ul><li>单个命题变项和命题常项是合式公式，称为原子命题公式。</li><li>若 $A$ 是合式，则 $\lnot A$ 也是</li><li>若 $A,B$ 是合式，则 $(A\land B)$ 、$(A\lor B)$ 、$(A\to B)$ 、$(A\leftrightarrow B)$ 也是合式</li><li>有限次地应用以上三点得到的符号串是合式公式</li></ul><h3 id="元语言和对象语言"><a href="#元语言和对象语言" class="headerlink" title="元语言和对象语言"></a>元语言和对象语言</h3><ul><li>元语言：上述定义中引入的 $A$ 和 $B$ 这样的符号就是元语言的符号，元语言的一个符号就能够代表一串具体的公式</li><li>对象语言：用来描述研究对象的语言，指的就是一串具体的公式。</li></ul><blockquote><p>元语言就是用来描述对象语言的语言</p></blockquote><h3 id="合式公式的层次"><a href="#合式公式的层次" class="headerlink" title="合式公式的层次"></a>合式公式的层次</h3><ul><li>若公式 $A$ 是单个的命题变项，则称 $A$ 为 $0$ 层合式</li><li><p>称公式 $A$ 是 $n+1$ （$n\ge 0$）层公式当且仅当以下情况：</p><ul><li>$A=\lnot B$，$B$ 是 $n$ 层公式</li><li>$A = B \land C$ ，其中 $B,C$ 分别为 $i$ 层和 $j$ 层公式，且 $n = max(i,j)$</li><li>$A = B \lor C$ ，其中 $B,C$ 分别为 $i$ 层和 $j$ 层公式，且 $n = max(i,j)$</li><li>$A = B \to C$ ，其中 $B,C$ 分别为 $i$ 层和 $j$ 层公式，且 $n = max(i,j)$</li><li>$A = B \leftrightarrow C$ ，其中 $B,C$ 分别为 $i$ 层和 $j$ 层公式，且 $n = max(i,j)$</li></ul></li></ul><h1 id="（五）合式公式的赋值（解释）与真值表"><a href="#（五）合式公式的赋值（解释）与真值表" class="headerlink" title="（五）合式公式的赋值（解释）与真值表"></a>（五）合式公式的赋值（解释）与真值表</h1><h2 id="公式赋值"><a href="#公式赋值" class="headerlink" title="公式赋值"></a>公式赋值</h2><p>赋值（解释）：设 $p_1,p_2,\cdots,p_n$ 是出现在公式 $A$ 中的全部的命题变项，给命题变项 $p_1,p_2,\cdots,p_n$ 各指定一个值，称为对 $A$ 的一个赋值（解释）</p><blockquote><p>对一个公式的赋值就是 $0$ 和 $1$ 组成的一组真值串，即设 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 为命题 $p_1,p_2,\cdots,p_n$ 的真值，那么赋值 $\alpha = \alpha_1\alpha_2\cdots\alpha_n$（中间不加任何表点符号）</p></blockquote><ul><li>成真赋值：指定一组 $p_1,p_2\cdots,p_n$ 的真值能使 $A$ 的真值为 $1$，则称这组值为为 $A$ 的成真赋值</li><li>成假赋值：指定一组 $p_1,p_2\cdots,p_n$ 的真值能使 $A$ 的真值为 $1$，则称这组值为为 $A$ 的成真赋值</li></ul><blockquote><p>含有 $n$ 个命题变项的公式一共有 $2^n$ 个赋值</p></blockquote><h2 id="公式的类型"><a href="#公式的类型" class="headerlink" title="公式的类型"></a>公式的类型</h2><ul><li>重言式（永真式）：公式 $A$ 在任意一组命题变项的赋值 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 下真值都为真，则称 $A$ 为重言式</li><li>矛盾式（永假式）：公式 $A$ 在任意一组命题变项的赋值 $\alpha_1,\alpha_2,\cdots,\alpha_n$ 下真值都为假，则称 $A$ 为矛盾式</li><li>可满足式：至少有一个成真赋值的公式（非矛盾式的公式称为可满足式）</li></ul><h2 id="列真值表"><a href="#列真值表" class="headerlink" title="列真值表"></a>列真值表</h2><h3 id="列真值表的步骤"><a href="#列真值表的步骤" class="headerlink" title="列真值表的步骤"></a>列真值表的步骤</h3><p>假设我们需要对命题公式 $A$ 求真值表，命题公式 $A$ 的公式层数为 $n$</p><ul><li><p>步骤 1：每个命题变项的真值都能取 $0$ 或 $1$ ，因此赋值 $\alpha = \alpha_1\alpha_2\cdots\alpha_n$ 可以从 $00\cdots0$ 取到 $11\cdots1$ 一共 $2^n$ 种情况</p></li><li><p>步骤 2：将公式 $A$ 依次分解为 $0,1,\cdots,n-1$ 层公式 $A_0,A_1,\cdots,A_n$</p></li><li><p>步骤 3：根据步骤 1 得到的 $2^n$ 种取值情况对步骤 2 分解出的各层公式进行赋值，最终得到命题公式 $A$ 的真值</p></li></ul><p>根据以上步骤得到的表格就是真值表，可以看出，真值表并不存在统一的内容/规格，不同的公式有各自对应的真值表。</p><h3 id="列真值表技巧"><a href="#列真值表技巧" class="headerlink" title="列真值表技巧"></a>列真值表技巧</h3><ul><li>哑元</li></ul><p>设公式 $A,B$ 中共同含有命题变项 $p_1,p_2,\cdots,p_n$ ，而 $A,B$ 并不分别全含这些命题变项，例如，若 $A$ 中不包含命题变项 $p_i,p_{i+1},p_n$，那么这些命题变项被称为 $A$ 的哑元。</p><p>一个公式的真值与哑元的真假无关，这个特性可以帮助简化公式真值表的计算。</p><ul><li>真值互斥</li></ul><p>一个命题的真值要么为真，要么为假——这意味着我们只需要判断出所有真值为真（假）的命题，就能得到所有真值为假（真）的命题</p><blockquote><p>应该利用不同联结式的特点，来决定我们是要找出所有真命题还是假命题，最大程度地简化判断量</p><p>如合取联结式我们倾向于找出所有真命题（因为它命题为真的条件更苛刻），析取联结式和蕴涵联结式我们倾向于找出所有假命题（因为这两者命题为假的条件更苛刻）</p></blockquote><h1 id="（六）本节作业"><a href="#（六）本节作业" class="headerlink" title="（六）本节作业"></a>（六）本节作业</h1><h2 id="将下列命题符号化"><a href="#将下列命题符号化" class="headerlink" title="将下列命题符号化"></a>将下列命题符号化</h2><p>(1) 刘晓月跑得快, 跳得高.</p><blockquote><p>令命题 $p$ 为：刘晓月跑得快；命题 $q$ 为：刘晓月跳得高</p><p>原命题可表示为 $p \land q$</p></blockquote><p>(2) 老王是山东人或河北人.</p><blockquote><p>令命题 $p$ 为：老王是山东人；命题 $q$ 为：老王为河北人</p><p>原命题可表示为 $(\lnot p \land q) \lor (\lnot q \land p)$</p></blockquote><p>(3) 因为天气冷, 所以我穿了羽线服.</p><blockquote><p>令命题 $p$ 为：天气是冷的；命题 $q$ 为：我穿了羽绒服</p><p>原命题可表示为 $p \to q$</p></blockquote><p>(4) 王欢与李乐组成一个小组.</p><blockquote><p>“王欢与李乐组成一个小组”是一个原子命题，直接用符号记为 $p$</p></blockquote><p>(5) 李辛与李末是兄弟.</p><blockquote><p>“李辛与李末是兄弟”是一个原子命题，直接用符号记为 $p$</p></blockquote><p>(6) 王强与刘威都学过法语.</p><blockquote><p>令命题 $p$ 为：王强学过法语；命题 $q$ 为：刘威学过法语</p><p>原命题可表示为 $p \land q$ </p></blockquote><p>(7) 他一面吃饭,一面听音乐.</p><blockquote><p>令命题 $p$ 为：他正在吃饭；命题 $q$ 为：他正在听音乐</p><p>原命题可表示为 $p \land q$</p></blockquote><p>(8) 如果天下大雨,他就乘班车上班.</p><blockquote><p>令命题 $p$ 为：天下大雨；命题 $q$ 为：他乘班车上班</p><p>原命题可表示为 $p \to q$</p></blockquote><p>(9) 只有天下大雨, 他才乘班车上班.</p><blockquote><p>令命题 $p$ 为：他乘班车上班；命题 $q$ 为：天下大雨</p><p>原命题可表示为 $p \to q$</p></blockquote><p>(10) 除非天下大雨, 否则他不乘班车上班.</p><blockquote><p>令命题 $p$ 为：他乘班车上班；命题 $q$ 为：天下大雨</p><p>原命题可表示为 $p \to q$</p></blockquote><p>(11) 下雪路滑,他迟到了.</p><blockquote><p>令命题 $p$ 为：下雪路滑；命题 $q$ 为：他迟到了</p><p>原命题可表示为 $p \to q$</p></blockquote><p>(12) 2 与 4 都是素数, 这是不对的.</p><blockquote><p>令命题 $p$ 为：2 是素数；命题 $q$ 为：4 是素数</p><p>原命题可表示为 $\lnot(p \land q)$</p></blockquote><p>(13) “ 2 或 4 是素数, 这是不对的” 是不对的.</p><blockquote><p>令命题 $p$ 为：2 是素数；命题 $q$ 为：4 是素数</p><p>原命题可表示为 $\lnot(\lnot(p \lor q))$</p></blockquote><h2 id="用真值表判断下列公式的类型"><a href="#用真值表判断下列公式的类型" class="headerlink" title="用真值表判断下列公式的类型"></a>用真值表判断下列公式的类型</h2><p>(1) $p \rightarrow(p \vee q \vee r)$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>$pqr$</th><th>$p\lor q$</th><th>$p\lor q \lor r$</th><th>$p\to(p\lor q \lor r)$</th></tr></thead><tbody><tr><td>000</td><td>0</td><td>0</td><td>1</td></tr><tr><td>001</td><td>0</td><td>1</td><td>1</td></tr><tr><td>010</td><td>1</td><td>1</td><td>1</td></tr><tr><td>011</td><td>1</td><td>1</td><td>1</td></tr><tr><td>100</td><td>1</td><td>1</td><td>1</td></tr><tr><td>101</td><td>1</td><td>1</td><td>1</td></tr><tr><td>110</td><td>1</td><td>1</td><td>1</td></tr><tr><td>111</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个永真式</p></blockquote><p>(2) $(p \rightarrow \neg p) \rightarrow \neg q$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>$pq$</th><th>$p\to \lnot p$</th><th>$(p\to \lnot p)\to\lnot q$</th></tr></thead><tbody><tr><td>00</td><td>1</td><td>1</td></tr><tr><td>01</td><td>1</td><td>0</td></tr><tr><td>10</td><td>0</td><td>1</td></tr><tr><td>11</td><td>0</td><td>1</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个可满足式</p></blockquote><p>(3) $\neg(q \rightarrow r) \wedge r$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>$qr$</th><th>$\lnot (q \to r)$</th><th>$\lnot (q \to r)\land r$</th></tr></thead><tbody><tr><td>00</td><td>0</td><td>0</td></tr><tr><td>01</td><td>0</td><td>0</td></tr><tr><td>10</td><td>1</td><td>0</td></tr><tr><td>11</td><td>0</td><td>0</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个可满足式</p></blockquote><p>(4) $(p \rightarrow q) \rightarrow(\neg q \rightarrow \neg p)$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>pq</th><th>$p\to q$</th><th>$\lnot q \to \lnot p$</th><th>$(p\to q)\to (\lnot q \to \lnot p)$</th></tr></thead><tbody><tr><td>00</td><td>1</td><td>1</td><td>1</td></tr><tr><td>01</td><td>1</td><td>1</td><td>1</td></tr><tr><td>10</td><td>0</td><td>0</td><td>1</td></tr><tr><td>11</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个永真式</p></blockquote><p>(5) $(p \wedge r) \leftrightarrow(\neg p \wedge \neg q)$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>$pqr$</th><th>$p\land r$</th><th>$\lnot p \land \lnot q$</th><th>$(p\land r)\leftrightarrow(\lnot p \land \lnot q)$</th></tr></thead><tbody><tr><td>000</td><td>0</td><td>1</td><td>0</td></tr><tr><td>001</td><td>0</td><td>1</td><td>0</td></tr><tr><td>010</td><td>0</td><td>0</td><td>1</td></tr><tr><td>011</td><td>0</td><td>0</td><td>1</td></tr><tr><td>100</td><td>0</td><td>0</td><td>1</td></tr><tr><td>101</td><td>1</td><td>0</td><td>0</td></tr><tr><td>110</td><td>0</td><td>0</td><td>1</td></tr><tr><td>111</td><td>1</td><td>0</td><td>0</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个可满足式</p></blockquote><p>(6) $((p \rightarrow q) \wedge(q \rightarrow r)) \rightarrow(p \rightarrow r)$</p><blockquote><p>列出真值表如下：</p></blockquote><div class="table-container"><table><thead><tr><th>$pqr$</th><th>$p\to q$</th><th>$q\to r$</th><th>$p\to r$</th><th>$(p\to q)\land (q\to r)$</th><th>$((p \rightarrow q) \wedge(q \rightarrow r)) \rightarrow(p \rightarrow r)$</th></tr></thead><tbody><tr><td>000</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>001</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>010</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>011</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr><tr><td>100</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>101</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>110</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr><tr><td>111</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个永真式</p></blockquote><p>(7) $(p \rightarrow q) \leftrightarrow(r \leftrightarrow s)$</p><blockquote><p>列出真值表如下</p></blockquote><div class="table-container"><table><thead><tr><th>$pqrs$</th><th>$p\to q$</th><th>$r\leftrightarrow s$</th><th>$(p\to q)\leftrightarrow(r\leftrightarrow s)$</th></tr></thead><tbody><tr><td>0000</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0001</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0010</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0011</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0100</td><td>1</td><td>1</td><td>1</td></tr><tr><td>0101</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0110</td><td>1</td><td>0</td><td>0</td></tr><tr><td>0111</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1000</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1001</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1010</td><td>0</td><td>0</td><td>1</td></tr><tr><td>1011</td><td>0</td><td>1</td><td>0</td></tr><tr><td>1100</td><td>1</td><td>1</td><td>1</td></tr><tr><td>1101</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1110</td><td>1</td><td>0</td><td>0</td></tr><tr><td>1111</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><blockquote><p>$\therefore$ 这个公式是一个可满足式</p></blockquote><h2 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h2><h4 id="已知-p-rightarrow-p-vee-q-wedge-p-wedge-q-rightarrow-p-是重言式-试判断公式-p-rightarrow-p-vee-q-及-p-wedge-q-rightarrow-p-的类型"><a href="#已知-p-rightarrow-p-vee-q-wedge-p-wedge-q-rightarrow-p-是重言式-试判断公式-p-rightarrow-p-vee-q-及-p-wedge-q-rightarrow-p-的类型" class="headerlink" title="已知 $(p \rightarrow(p \vee q)) \wedge((p \wedge q) \rightarrow p)$ 是重言式, 试判断公式 $p \rightarrow(p \vee q)$ 及 $(p \wedge q) \rightarrow p$ 的类型."></a>已知 $(p \rightarrow(p \vee q)) \wedge((p \wedge q) \rightarrow p)$ 是重言式, 试判断公式 $p \rightarrow(p \vee q)$ 及 $(p \wedge q) \rightarrow p$ 的类型.</h4><p>列出真值表如下：</p><div class="table-container"><table><thead><tr><th>$pq$</th><th>$p\lor q$</th><th>$p\land q$</th><th>$p\to (p\lor q)$</th><th>$(p\land q)\to p$</th><th>$(p \rightarrow(p \vee q)) \wedge((p \wedge q) \rightarrow p)$</th></tr></thead><tbody><tr><td>00</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>01</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>10</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>11</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td></tr></tbody></table></div><p>可知 $p\to (p\lor q)$ 和 $(p\land q)\to p$ 都是永真式</p><h4 id="已知-neg-p-rightarrow-q-wedge-q-vee-neg-neg-q-vee-p-wedge-p-是矛盾式-试判断公式-neg-p-rightarrow-q-wedge-q-及-neg-neg-q-vee-p-wedge-p-的类型"><a href="#已知-neg-p-rightarrow-q-wedge-q-vee-neg-neg-q-vee-p-wedge-p-是矛盾式-试判断公式-neg-p-rightarrow-q-wedge-q-及-neg-neg-q-vee-p-wedge-p-的类型" class="headerlink" title="已知 $(\neg(p \rightarrow q) \wedge q) \vee(\neg(\neg q \vee p) \wedge p)$ 是矛盾式, 试判断公式 $\neg(p \rightarrow q) \wedge q$ 及 $\neg(\neg q \vee p) \wedge p$ 的类型."></a>已知 $(\neg(p \rightarrow q) \wedge q) \vee(\neg(\neg q \vee p) \wedge p)$ 是矛盾式, 试判断公式 $\neg(p \rightarrow q) \wedge q$ 及 $\neg(\neg q \vee p) \wedge p$ 的类型.</h4><p>列出真值表如下：</p><div class="table-container"><table><thead><tr><th>$pq$</th><th>$\neg(p \rightarrow q)$</th><th>$\neg(\neg q \vee p)$</th><th>$\neg(p \rightarrow q) \wedge q$</th><th>$\neg(\neg q \vee p) \wedge p$</th><th>$(\neg(p \rightarrow q) \wedge q) \lor (\neg(\neg q \vee p) \wedge p)$</th></tr></thead><tbody><tr><td>00</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>01</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td></tr><tr><td>10</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>11</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr></tbody></table></div><p>可知 $\neg(p \rightarrow q) \wedge q$ 和 $\neg(\neg q \vee p) \wedge p$ 均为矛盾式</p><blockquote><p>列完 24、25 两题的真值表忽然反应过来……我智商果然灌了水了……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> 离散数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 离散数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>启发式算法——基本遗传算法</title>
      <link href="/2022/09/03/c%E5%9F%BA%E6%9C%AC%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/03/c%E5%9F%BA%E6%9C%AC%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="启发式算法系列开篇"><a href="#启发式算法系列开篇" class="headerlink" title="启发式算法系列开篇"></a>启发式算法系列开篇</h1><p>这是介绍启发式算法家族的第一篇文章。</p><p>启发式算法指的是：</p><p>启发式算法主要区别于传统优化算法，后者通过目标函数的梯度达到目标函数结果最优化，它是一种确定性的搜索方式。</p><p>而启发式算法的特点就在于随机搜索并且通过这一特性获取更高的全局最优可能性。由于和函数梯度的利用无关，所以启发式算法并不要求目标函数具有连续可微的条件，为一些无法通过梯度下降优化的目标函数提供了优化的可能性。</p><p>人类通过观察自然的演变和动物的行为，将它们用于真实场景的模拟当中，这些就是启发式算法的灵感来源，因此这些算法听上去也比一般的算法更加有趣，无论是初入算法世界的萌新，还是准备数模竞赛的同学，都能在启发式算法的家族里窥探到算法学家的智慧和有趣。</p><p>本文同接下来一个系列的几篇文章都将介绍启发式算法的原理、具体过程到最后的代码实现，代码实现上，会提供尽量 <code>MATLAB</code> 和 <code>python</code> 两种代码框架。</p><p>欢迎关注 &amp; 追更！！！</p><h1 id="遗传算法基础"><a href="#遗传算法基础" class="headerlink" title="遗传算法基础"></a>遗传算法基础</h1><h2 id="遗传算法简介"><a href="#遗传算法简介" class="headerlink" title="遗传算法简介"></a>遗传算法简介</h2><p>遗传算法（Genetic Algorithm，简称 GA ），顾名思义，这是一种模拟自然选择生物进化和个体繁衍时交叉、复制、变异等现象的算法。</p><p>遗传算法的过程就模拟了一个物种的进化史诗，而其结果旨在于通过残酷的优胜劣汰机制留下我们规定的世界中的最优解——哪个种群越接近最优解，才能挺过无数场竞争，让基因得以保留。</p><h2 id="遗传算法术语和概念"><a href="#遗传算法术语和概念" class="headerlink" title="遗传算法术语和概念"></a>遗传算法术语和概念</h2><h3 id="染色体、位串、基因"><a href="#染色体、位串、基因" class="headerlink" title="染色体、位串、基因"></a>染色体、位串、基因</h3><p>位串在算法中就相当于生物学上的染色体的概念。</p><p>而基因则可以看作染色体的组成单元，染色体上的所有基因共同作用，最终决定了一个个体的性状。</p><p>比如，在很多情况下，我们会将基因建模成一个个二进制位，则染色体就是一个二进制串。</p><p>举一个非常简单的例子，我们希望确定一组参数 $w_1,w_2,\cdots,w_n$ ，能够使目标问题得到最优解。</p><p>就取 $w_1,w_2,\cdots,w_n$ 的二进制数，将它们拼接成一个 $01$ 串，这个串上的每个 $0$ 或者 $1$，都是一个基因</p><p>而这组参数的取值就可以称之为一个染色体，比如我们认为 $w_1,w_2,\cdots,w_n$ 都是一个八位二进制数，它们就能表示为：</p><script type="math/tex; mode=display">\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}</script><h3 id="特征值"><a href="#特征值" class="headerlink" title="特征值"></a>特征值</h3><p>在用串表示整数时，基因的特征值与二进制数的权一致——比如染色体 $10001$ 中第一个 $1$ 表示的基因的特征值为 $16$</p><h3 id="基因型和表现型"><a href="#基因型和表现型" class="headerlink" title="基因型和表现型"></a>基因型和表现型</h3><p>基因型在遗传算法中指的就是问题可行解的一种编码，比如上面举的那个例子中，$10111010101010111\cdots0101001001001111\cdots010100111100101$ 就是一个基因型，它经过解码后还原得到的一组参数 $w_1,w_2,\cdots w_n$ 在实际问题中的表现状态就是一组可行解的表现型。</p><blockquote><p>事实上，一组可行解就是一个个体</p></blockquote><h3 id="适应度"><a href="#适应度" class="headerlink" title="适应度"></a>适应度</h3><p>这是遗传算法中最重要的概念之一（<strong>敲黑板</strong>），因为——</p><p>它决定了我们规定的进化方向，是这个优胜劣汰的世界中的基本规则</p><p>适应度的本质就是一个函数，根据上面的例子，这个函数可能就像下面这样：</p><script type="math/tex; mode=display">X = t(w_1,w_2,\cdots,w_n)</script><script type="math/tex; mode=display">S = f(X)</script><p>这两行公式的意思是，函数 $t(w_1,w_2,\cdots,w_n)$ 表示一个生物个体的基因在目标函数下的表现性状。</p><blockquote><p>目标函数指的就是我们希望优化的对象</p><p>在自然界中，这个目标函数就是尽量地活下去</p><p>在我们的遗传算法空间中，这个目标函数就由我们自己定义：它可以指旅行商问题中的路径，可以指加工一批硬件的时间……</p></blockquote><p>生物的表现性状 $X$ 由它的一系列基因 $w_1,w_2\cdots,w_n$ 决定，$f(X)$ 就是适应度函数，适应度函数旨在于评估生物性状，给出哪些生物更适合活下来的依据。</p><p>对应到算法中，适应度函数就是我们优化的对象，比如让旅行商的行走总路径，那么遍历每个城市的任何一种方案都可以视为具有各自染色体的个体，我们的适应度设计目的就是为了寻找最优、最符合问题答案的个体的染色体，它就是我们问题的解。</p><h3 id="算子"><a href="#算子" class="headerlink" title="算子"></a>算子</h3><p>算子的英文原名就是 $operator$，其实就是操作，算子的种类有：</p><ul><li>选择算子（Selection Operator）</li><li>交叉算子（Crossover Operator）</li><li>变异算子（Mutation Operator）</li></ul><p>这三个算子的涵义和作用会在后面具体过程中进行讲解，注意：这只是基本遗传算法的算子，更复杂的遗传算法会包含更多种类的算子。</p><h1 id="遗传算法的步骤"><a href="#遗传算法的步骤" class="headerlink" title="遗传算法的步骤"></a>遗传算法的步骤</h1><h2 id="（一）染色体编码"><a href="#（一）染色体编码" class="headerlink" title="（一）染色体编码"></a>（一）染色体编码</h2><p>我们刚刚已经提到过，遗传算法的可行解可以表示成基因的形式，基因也可以被还原为可行解的形式。前者被称为编码，后者则称为解码。</p><blockquote><p>比如 $\underbrace{10111010101010111\cdots0101001001001111\cdots010100111100101}_{共 8\times n位}$ 就是基因，$w_1,w_2,\cdots w_n$ 就是一组可行解（性状）</p></blockquote><p>一般而言，染色体编码要遵循下面这些准则：</p><ul><li><p>完备性（Completeness）：问题空间中的所有候选解都能编码为 GA 空间中的染色体</p></li><li><p>非冗余性（Nonredundancy）：染色体和候选解一一对应</p></li></ul><p>下面提供三种染色体编码的技巧和思路：</p><h3 id="二进制编码方法"><a href="#二进制编码方法" class="headerlink" title="二进制编码方法"></a>二进制编码方法</h3><p>就是将一组问题的可行解全部转换为二进制数的形式，并对这些二进制数进行拼接得到一个 $01$ 串，这个 $01$ 串就是染色体</p><blockquote><p>注意：小数和整数都可以编码成二进制数。对于小数而言，还应该在编码时确定小数点的位置</p><p>编码方案应该和数据范围以及数据变化灵敏度相适应，如下：</p></blockquote><p>$000000\cdots00000 = 0\delta$ 对应范围的下界</p><p>$111111\cdots11111 = (2^n-1)\delta$ 对应范围的上界</p><p>而 $000000\cdots00001$ 表示数据的灵敏度 $\delta$</p><h3 id="格雷编码"><a href="#格雷编码" class="headerlink" title="格雷编码"></a>格雷编码</h3><p>格雷码（Grey Code）也被称之为反射二进制码，是一个二进制数系，其中两个相邻数的二进制位只有一位不同，并且最大数与最小数之间也仅一位数不同。</p><p>二进制码和格雷码在使用时的一点明显区别就是：</p><p>比如当一个染色体的取值需要增加一个单位量时（$\sigma$），如果原染色体是 $1000001111111$ ，转换后得到的就是 $100001000000$ ，一共需要修改 $7$ 个基因，而如果使用格雷码进行编码，“相邻染色体”之间的差别就是一个基因，大大降低了相邻值之间的转换时间，能够使算法的局部搜索能力增强。</p><p>格雷码和二进制码的相互转换可以使用下面的思路进行转换：</p><p>设某二进制格雷码为 $G_{n-1}G_{n-2}\cdots G_2G_1G_0$，自然二进制码为 $B_{n-1}B_{n-2}\cdots B_2B_1B_0$</p><p>二进制码转格雷码：</p><ul><li>最高位保留：$G_{n-1} = B_{n-1}$</li><li>其它各位进行异或操作：$G_i = B_{i+1}\oplus B_i$</li></ul><p>格雷码转二进制码：</p><ul><li>最高位保留：$B_{n-1}=G_{n-1}$</li><li>其它各位进行异或运算：$B_{i-1}=G_{i-1}\oplus B_i$</li></ul><blockquote><p>由于格雷码拥有二进制编码的优点，并且其特性更提供了一些额外的优势，因此建议在使用二进制时，总是用格雷码进行替代</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>返回结果为：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="浮点数编码方法"><a href="#浮点数编码方法" class="headerlink" title="浮点数编码方法"></a>浮点数编码方法</h3><p>将一组问题的可行解全部转换为浮点数的形式，浮点数的设计可以参照 $IEEE$ 标准自行完成，目的是为了增大可行解的表示范围，又不至于让染色体变得过长</p><blockquote><p>一些精度要求较高的问题，如果使用二进制编码直接表示，往往会使得染色体的长度变得过长，不利于我们求解</p><p>使用浮点数进行编码不是为了能够表示小数（这点二进制编码也能够做到），而是为了能够利用阶码表示更大的数</p></blockquote><h3 id="符号编码方法"><a href="#符号编码方法" class="headerlink" title="符号编码方法"></a>符号编码方法</h3><p>使用自定义的符号进行编码的方法，其中自定义的符号是指无数值含义、而只有代码含义的符号集，比如 $\{solution_1,solution_2,\cdots,solution_n\}$</p><p>应该注意的是，使用符号编码后，还要考虑后续的变异、交叉等算子应该怎样对染色体上的基因进行操作，这些操作是否符合约束条件。</p><h3 id="实数编码方法"><a href="#实数编码方法" class="headerlink" title="实数编码方法"></a>实数编码方法</h3><p>遗传算法可以使用二进制串来表示整数和实数，但是使用二进制串表示的实数的精度受串长度（位数）的限制。由于需要提前确定该长度，因此最终可能由于二进制串太短导致精度不足或编码过长。</p><p>因此除了使用浮点表示方法外，使用实数值数组代替二进制串也是一种简单可行的方法。</p><p>比如将染色体设计为 $x_1x_2x_3$ ，其中 $x_1 = 1.57,x_2 = 2.89,x_3 = 3.68$ ，这就是一个实数编码的染色体。</p><blockquote><p>本文指的实数编码方法和浮点数编码方法是有区别的，前者指每个变量就是一个基因，用原始的实数数据进行编码，后者指用类似于 <code>IEEE754</code> 的格式先将浮点数转换成二进制数，再用来进行编码。</p></blockquote><h2 id="（二）生成初始种群"><a href="#（二）生成初始种群" class="headerlink" title="（二）生成初始种群"></a>（二）生成初始种群</h2><p>遗传算法的操作对象是一个群体，因此现需要准备一些表示起始搜索点的初始群体数据。对于启发式算法而言，更好的起始数据更有利于算法的搜索表现。</p><p>原则上，在不确定解的大致情况时，我们希望初始种群的群体尽量大，减少解得到的偶然性；基因尽量分散，使解的来源尽量广泛。</p><h2 id="（三）进行选择运算"><a href="#（三）进行选择运算" class="headerlink" title="（三）进行选择运算"></a>（三）进行选择运算</h2><p>选择运算也是遗传算法中的一种算子（Operator），选择操作从旧群体中以一定概率选择优良个体组成新的种群，以繁殖得到下一代个体。</p><p>这时就应该提到开始时定义的“适应度”，在自然界，适应度反映的是一个生物群体能否适应环境并在残酷竞争中存活下来；在遗传算法中，适应度反映的是一个解（染色体/个体）是否在我们的目标函数中表现得更优，比如上面规定的：路程是否更短，时间开销是否更小…….</p><p>适应度的大小应该和一个解的优质程度成正相关，假设一个种群的数量为 $M$，个体 $i$ 的适应度为 $f_i$ ，则个体被选取的概率为 </p><script type="math/tex; mode=display">P_i = \frac{f_i}{\sum_{k=1}^Mf_k} \qquad i = 1,2,\cdots,n</script><p>如下几种方法可以用来充当选择算子：</p><h3 id="俄罗斯轮盘赌"><a href="#俄罗斯轮盘赌" class="headerlink" title="俄罗斯轮盘赌"></a>俄罗斯轮盘赌</h3><p>一般而言，选择算子使用俄罗斯轮盘赌算法（Russian roulette），它的起源就是左轮手枪对赌自杀游戏</p><blockquote><p>不错，这很战斗民族……</p><center><img src = https://s1.ax1x.com/2022/09/03/voVRWq.png width = 45%></center></blockquote><p>俄罗斯轮盘赌算法的操作过程如下：</p><ul><li>计算所有个体的适应度总和 $F = f_0 + f_1 + \cdots + f_n$</li><li>在 $[0,F]$ 之间生成一个随机数，并根据 $f_0,f_1,\cdots,f_n$ 的大小将 区间 $[0,F]$ 分成 $n$ 个“弹膛”</li><li>这个随机数落入哪个“弹膛”，就选择哪个“弹膛”对应的个体</li></ul><blockquote><p>一个个体的适应度越大，那么它对应的弹膛也就越大，被选中的概率就越高</p><p>由于这是一个基于随机数的算法，因此可能会出现适应度很高的个体却无法遗传至下一代的情况，这并不完全是缺点，因为它也保证了后代种群的演化多样性——最强大的个体不一定能活下来，大自然的戏剧性不也如此吗？</p></blockquote><h3 id="锦标赛选择"><a href="#锦标赛选择" class="headerlink" title="锦标赛选择"></a>锦标赛选择</h3><p>所有个体被随机选择，开展若干轮竞赛（两两竞赛/多个体竞赛），其中适应度最高的获胜并被选中。</p><blockquote><p>每轮锦标赛参与的个体数量称为锦标赛规模，而锦标赛的轮数一般由个体总数和锦标规模决定</p></blockquote><p>如果个体数量（$n$ 个）过多，保证个体进行两两竞赛是比较困难的（开展 $C_n^2$ 轮），此时可以先对个体进行分组淘汰</p><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的选择算子</p></blockquote><h2 id="（四）进行配对和交叉操作"><a href="#（四）进行配对和交叉操作" class="headerlink" title="（四）进行配对和交叉操作"></a>（四）进行配对和交叉操作</h2><p>和生物学中的过程一样，进行交叉之前还应该先进行染色体的配对环节（也就是个体的配对），配对指的时从种群中随机选择两个个体进行组合，类似于自然界中的交配现象。</p><p>交叉操作则指对已经配对的两条染色体中的基因进行交换，有如下几种交叉算子支持这一操作的实现：</p><blockquote><p>以下是基于二进制编码（格雷码、浮点数编码）的交叉操作</p></blockquote><h3 id="单点交叉（Single-point-Crossover）"><a href="#单点交叉（Single-point-Crossover）" class="headerlink" title="单点交叉（Single-point Crossover）"></a>单点交叉（Single-point Crossover）</h3><p>在两条配对的染色体中随机设置一个位置交叉点，在该交叉位置对两条配对的染色体进行进行分割并交换位置交叉点右侧的染色体片段。</p><center><img src = https://s1.ax1x.com/2022/09/03/voV6oj.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVseg.png width = 41%></center><blockquote><p>单点交叉混合的速度较慢（因为将染色体分成两段进行交叉，这种方式交叉粒度较大），但对于选取交叉点位置具有一定内在含义的问题而言，单点交叉可以造成更小的破坏。</p></blockquote><h3 id="两点交叉（Two-points-Crossover）"><a href="#两点交叉（Two-points-Crossover）" class="headerlink" title="两点交叉（Two-points Crossover）"></a>两点交叉（Two-points Crossover）</h3><p>两点交叉是指在个体染色体中随机设置了两个交叉点，然后再将两个交叉点之间的染色体片段进行交换。</p><center><img src = https://s1.ax1x.com/2022/09/03/voVgFs.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVywQ.png width = 39.5%></center><h3 id="多点交叉（Multi-point-Crossover）"><a href="#多点交叉（Multi-point-Crossover）" class="headerlink" title="多点交叉（Multi-point Crossover）"></a>多点交叉（Multi-point Crossover）</h3><p>多点交叉或称广义交叉，是指在个体染色体中随机设置多个交叉点，然后在这些点的位置进行单个基因的交换。</p><center><img src = https://s1.ax1x.com/2022/09/03/voV2Yn.png width = 40%> &nbsp;&nbsp;&nbsp;<img src = https://s1.ax1x.com/2022/09/03/voVfS0.png width = 38.6%></center><h3 id="均匀交叉（Uniform-Crossover）"><a href="#均匀交叉（Uniform-Crossover）" class="headerlink" title="均匀交叉（Uniform Crossover）"></a>均匀交叉（Uniform Crossover）</h3><p>均匀交叉也称一致交叉，这个交叉算子遍历两个染色体的全部基因位点，每个基因位点都有相同的交叉概率发生在两个染色体间的交叉互换，效果如下：</p><center><img src = https://s1.ax1x.com/2022/09/03/voVhlV.png width = 45%></center><blockquote><p>以下是实数编码的交叉操作</p></blockquote><h3 id="算术交叉"><a href="#算术交叉" class="headerlink" title="算术交叉"></a>算术交叉</h3><p>算术交叉算子是一种适用于实数编码的交叉操作，它将父母两个个体的染色体进行线性组合，进而产生的新的个体。</p><script type="math/tex; mode=display">X_A^{t+1} = \alpha X_B^{t} + (1-\alpha)X_A^{t}</script><script type="math/tex; mode=display">X_B^{t+1} = \alpha X_A^t + (\alpha-1)X_B^t</script><p>上式中的 $\alpha$ 是一个参数，它可以是常数或者进化代数决定的变量，如果是后者的情况，此时的交叉变换就称为非均匀交叉变换。</p><h3 id="混合交叉（blend-crossover）"><a href="#混合交叉（blend-crossover）" class="headerlink" title="混合交叉（blend crossover）"></a>混合交叉（blend crossover）</h3><p>混合交叉算子是一种适用于实数编码的交叉操作，在混合交叉中，每个后代都是从其亲代创建的以下区间中<strong>随机</strong>选择的：</p><script type="math/tex; mode=display">X^{t+1}\in [X^t_1-\alpha (X^t_2 - X^t_1),\;X_2^t+\alpha(X_2^t - X_1^t)</script><blockquote><p>该式假设 $X_2^t &gt; X_1^t$ ，实际情况灵活处理</p></blockquote><p>$\alpha$ 是一个预确定的参数，其值在 $0$ 到 $1$ 之间，$\alpha$ 越大，区间就越大。</p><blockquote><p>$\alpha=0$ 时，选取范围就在两个亲代之间。</p></blockquote><h3 id="模拟二进制交叉（Simulated-Binary-Crossover）"><a href="#模拟二进制交叉（Simulated-Binary-Crossover）" class="headerlink" title="模拟二进制交叉（Simulated Binary Crossover）"></a>模拟二进制交叉（Simulated Binary Crossover）</h3><p>模拟二进制交叉算子是一种适用于实数编码的交叉操作，在模拟二进制交叉中，每个后代都是由亲代染色体创建的以下等式决定的：</p><script type="math/tex; mode=display">X_1^{t+1} = \frac{1}{2}(1+\beta)X_1^t+\frac{1}{2}(1-\beta)X_2^t</script><script type="math/tex; mode=display">X_2^{t+1} = \frac{1}{2}(1-\beta)X_1^t+\frac{1}{2}(1+\beta)X_2^t</script><p>模拟二进制交叉算子的特性是：</p><ul><li>不管 $\beta$ 的值如何，两个后代的平均值等于两个亲代的平均值</li><li>当 $\beta$ 的值为 $1$ 时，后代是双亲的副本</li><li>当 $\beta$ 值小于 1 时，后代间的距离比亲代间的距离更短</li><li>当 $\beta$ 值大于 1 时，后代间的距离比双亲间的距离更远</li></ul><center><img src = https://s1.ax1x.com/2022/09/03/voV7TJ.png width = 45%></center><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的交叉算子</p><p>更多交叉方法可以参见 <a href="https://blog.csdn.net/u010743448/article/details/108445588">https://blog.csdn.net/u010743448/article/details/108445588</a> ，这里不作完全枚举</p></blockquote><h2 id="（五）变异"><a href="#（五）变异" class="headerlink" title="（五）变异"></a>（五）变异</h2><p>为了防止遗传算法在优化过程中陷入局部最优解，在搜索过程中，需要对个体进行变异操作，并以此更准确地模拟自然选择的过程。</p><p>变异是产生新的基因和个体的重要方式，往往能在遗传算法中起到随机搜索避免陷入局部最优的效果。但是如果变异概率过高，会导致变异过于频繁而丢失优秀的个体。</p><blockquote><p>下面是适用于基于二进制的编码（包括格雷码、浮点数编码）的变异算子</p></blockquote><h3 id="位翻转突变（Flip-Bit-Mutation）"><a href="#位翻转突变（Flip-Bit-Mutation）" class="headerlink" title="位翻转突变（Flip Bit Mutation）"></a>位翻转突变（Flip Bit Mutation）</h3><p>适用于以二进制为基础的编码方式，比如自然二进制编码法、格雷编码法和浮点数编码法。</p><p>算法流程非常简单：在随机选择若干个基因，将其值进行翻转（$01$互换 ）</p><center><img src = https://s1.ax1x.com/2022/09/03/voV4yT.png width = 66%></center><h3 id="交换突变（Swap-Mutation）"><a href="#交换突变（Swap-Mutation）" class="headerlink" title="交换突变（Swap Mutation）"></a>交换突变（Swap Mutation）</h3><p>随机选择若干对个基因并交换一对基因中的两个值</p><center><img src = https://s1.ax1x.com/2022/09/03/voV5OU.png width = 66%></center><p>这个突变算子适用于有序列表的染色体，因为新染色体仍带有与原始染色体相同的基因，如果是无序染色体，交换突变将会失效。</p><h3 id="反转突变（Inversion-Mutation）"><a href="#反转突变（Inversion-Mutation）" class="headerlink" title="反转突变（Inversion Mutation）"></a>反转突变（Inversion Mutation）</h3><p>选择一段随机的染色体片段（基因序列），将该序列中的基因顺序颠倒</p><center><img src = https://s1.ax1x.com/2022/09/03/voVomF.png width = 66%></center><p>同样，这个突变算子仅适用于有序列表的染色体。</p><blockquote><p>下面是适用于基于实数编码方法的变异算子</p></blockquote><h3 id="高斯变异"><a href="#高斯变异" class="headerlink" title="高斯变异"></a>高斯变异</h3><p>高斯变异算子通过用一个均值 $\mu$ 、方差为 $\sigma$ 的正态分布的一个随机数来替换原有基因值 $u$。</p><p>高斯变异的局部搜索能力较好，但是引导个体跳出局部较优解的能力较弱，不利于全局收敛。</p><h3 id="步长变异"><a href="#步长变异" class="headerlink" title="步长变异"></a>步长变异</h3><p>步长变异算子通过给变异基因加上或减去一个称为步长的值来实现变异的效果，即：</p><script type="math/tex; mode=display">X^{t+1} = X^{t} + Ld</script><blockquote><p>对于符号编码的情况，可能需要考虑采用自行设计的变异算子</p></blockquote><h2 id="检查退出条件"><a href="#检查退出条件" class="headerlink" title="检查退出条件"></a>检查退出条件</h2><p>通过检查经过选择、遗传、交叉和变异这些过程后得到的新种群是否满足预设的判断条件。如果满足，退出循环迭代体系；如果不满足，则将当前的种群加入下一轮循环迭代</p><p>至此，一个遗传算法的完整流程可以被总结如下——</p><p>一个基本的遗传算法至少需要确定四个运行参数：</p><ul><li>种群大小 $M$</li><li>遗传算法的终止进化代数 $T$<blockquote><p>用于设置预定义的遗传算法结束条件</p></blockquote></li><li>交叉概率 $PC$</li><li>变异概率 $PM$</li></ul><p>整合上面的各个过程，一个基本的遗传算法框架如下：</p><center><img src = https://s1.ax1x.com/2022/09/03/voVTw4.png width = 50%></center><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="代码框架详见下篇：遗传算法的代码构建"><a href="#代码框架详见下篇：遗传算法的代码构建" class="headerlink" title="代码框架详见下篇：遗传算法的代码构建"></a>代码框架详见下篇：遗传算法的代码构建</h2><h2 id="其它补充"><a href="#其它补充" class="headerlink" title="其它补充"></a>其它补充</h2><p>遗传算法发展至今已经加入了很多全新并且深刻的内容，比如变异方法、选择方法、交叉方法的改进版本，如柯西变异、混沌变异这样的新名词不断浮现。</p><p>本文旨在于给出一个最基本的遗传算法框架，实际情况使用的模型往往是需要不断修正、补充和丰富的。</p><h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a><strong><center>参考文献：</center></strong></h1><blockquote><p>格雷码和俄罗斯轮盘赌算法的简介部分：<a href="http://accu.cc/content/ga/russian_roulette/">http://accu.cc/content/ga/russian_roulette/</a></p><p>遗传算法简介部分：<a href="https://zhuanlan.zhihu.com/p/100337680">https://zhuanlan.zhihu.com/p/100337680</a></p><p>遗传算法交叉算子部分：<a href="https://blog.csdn.net/u010743448/article/details/108445588">https://blog.csdn.net/u010743448/article/details/108445588</a> &amp; <a href="https://benpaodewoniu.github.io/2018/10/27/es4/">https://benpaodewoniu.github.io/2018/10/27/es4/</a> &amp; <a href="https://zhuanlan.zhihu.com/p/435885104">https://zhuanlan.zhihu.com/p/435885104</a></p><p>遗传算法变异算子部分：<a href="https://zhuanlan.zhihu.com/p/435885104">https://zhuanlan.zhihu.com/p/435885104</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP 入门指南</title>
      <link href="/2022/08/31/cOpenMP%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/"/>
      <url>/2022/08/31/cOpenMP%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>注：本文是参考人大编程集训随堂课件和 <a href="https://www.openmp.org/resources/refguides/">OpenMP 官方文档（点击跳转）</a> 总结的笔记，听课前晚为调一个 bug 两点多才睡，可能存在听课不仔细导致的一些疏漏和错误，欢迎指出，感谢！</p></blockquote><h1 id="vscode-设置-OpenMP-支持"><a href="#vscode-设置-OpenMP-支持" class="headerlink" title="vscode 设置 OpenMP 支持"></a><code>vscode</code> 设置 <code>OpenMP</code> 支持</h1><p>安装过 <code>GCC</code> 之后就可以直接进行 <code>OpenMP</code> 编程，但是需要指定一些编译选项——</p><p>如果是使用 <code>vscode</code> 进行操作，只需要对文件 <code>.vscode/tasks.json</code> 进行更改即可：</p><p>原本的 <code>&quot;args&quot;</code> 参数如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;-fdiagnostics-color=always&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p><strong>将 <code>&quot;-g&quot;,</code> 修改为 <code>&quot;-fopenmp&quot;,</code> 即可，注意逗号</strong>。</p><p>可以用下面这个简单的代码验证一下是否可以使用 <code>OpenMP</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _OPENMP</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;omp.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> _OPENMP</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以下假定代码文件名为 <code>try.cpp</code></p></blockquote><p>或在终端使用如下命令编译并运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; g++ -fopenmp try.cpp -o try.exe</span><br><span class="line">&gt;&gt;&gt; ./try.exe</span><br></pre></td></tr></table></figure><p>也可以创建一个 <code>bash</code> 脚本，然后用比较简短的命令运行</p><p> <code>bash</code> 脚本名：<code>omp.sh</code>， 里面写：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -fopenmp try.cpp -o try.exe</span><br><span class="line">./try.exe</span><br></pre></td></tr></table></figure><p>只需要以下命令一键运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bash opm.sh</span><br></pre></td></tr></table></figure><h1 id="OpenMP-简介入门"><a href="#OpenMP-简介入门" class="headerlink" title="OpenMP 简介入门"></a><code>OpenMP</code> 简介入门</h1><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程：是并发执行的程序在执行过程中分配和管理资源的基本单位，是一个动态概念，竞争计算机系统资源的基本单位。</p></li><li><p>线程：是进程的一个执行单元，是进程内的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</p></li></ul><blockquote><p>上面的解释可能还是有些抽象，但是通俗地解释方式就是：线程是进程的一个单元，如果把进程比作一座工厂，线程类似于工厂中的工人</p><p>这个比喻引用于<a href="https://zhuanlan.zhihu.com/p/403313422">此链接（点击跳转）</a>，可以在这里了解更多详细知识</p></blockquote><h3 id="OpenMP-是什么？"><a href="#OpenMP-是什么？" class="headerlink" title="OpenMP 是什么？"></a><code>OpenMP</code> 是什么？</h3><p><code>OpenMP</code> 是一套支持跨平台的共享内存方式的多线程并发的编程 <code>API</code></p><p>可以理解为，OpenMP 就是一套可以插入在代码中的工具，我们利用这些工具来实现一些多线程相关的功能。</p><p><code>OpenMP</code> 基于 <code>Fork</code> 、<code>Join</code> 模型，如下：</p><center><img src = https://s1.ax1x.com/2022/08/31/v4vuct.png width = 80%></center><p>如图主线程 <code>master thread</code> 在进入并行区域（<code>parallel region</code>）时，线程会被分岔（<code>fork</code>），在并行区域（<code>parallel region</code>）结束后，这些线程最终又会合并（<code>join</code>）</p><p>而简化地说，<code>OpenMP</code> 的作用就是指导编译器应该在何时、以何种方式（细节）将程序编译，让编译器在可行的范围内实现更加高效的操作</p><p>可以大致认为，<code>OpenMP</code> 的语法包括以下三类：</p><ul><li>线程相关的函数调用库</li><li>线程相关的编译指导语句</li><li>线程相关的环境变量</li></ul><p><code>OpenMP</code> 的执行有以下这些特点：</p><ul><li>OpenMP程序串行和并行区域交替出现</li><li>串行区域由 <code>master thread</code>（<code>thread 0</code>） 执行</li><li>并行区域由多个线程同一时间一起执行，不同线程一起完成并行区域中的任务</li></ul><p>如下图展示了语法执行的特点</p><center><img src = https://s1.ax1x.com/2022/08/31/v4vKjP.png width = 35%></center><h1 id="常用线程相关的函数调用库"><a href="#常用线程相关的函数调用库" class="headerlink" title="常用线程相关的函数调用库"></a>常用线程相关的函数调用库</h1><p><code>OpenMP</code> 的函数调用库可以用来进行一些进程相关的设置和信息获取。</p><p><code>OpenMP</code> 函数调用库的语法就是常规的函数调用语法，这个非常简单，这里就简单罗列几个函数并给出使用示例，只要看下面代码中的注释即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// #include &lt;omp.h&gt;</span></span><br><span class="line"><span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>); <span class="comment">// 设置进程的线程数为 3（在此后的分支区，一共会有三个线程参与进行）</span></span><br><span class="line"><span class="type">int</span> thread_num = <span class="built_in">omp_get_thread_num</span>(); <span class="comment">// 获取当前进程中的线程数，此处 thread_num = 3</span></span><br><span class="line"><span class="function"><span class="type">int</span> mex_thread_num <span class="title">omp_get_mex_thread</span><span class="params">()</span></span>; <span class="comment">// 获取最多可以用于并行计算的线程数目</span></span><br><span class="line"><span class="type">int</span> thread_id = <span class="built_in">omp_get_thread_num</span>();  <span class="comment">// 获取当前线程的 id</span></span><br><span class="line"><span class="type">int</span> curTime = <span class="built_in">omp_get_wtime</span>(); <span class="comment">// 获取当前时间，秒为单位</span></span><br><span class="line"><span class="type">int</span> is_in_parallel = <span class="built_in">omp_in_parallel</span>(); <span class="comment">// 当前程序是否在并行中，1 表示并行，0表示串行</span></span><br></pre></td></tr></table></figure><h1 id="常用编译指导语句"><a href="#常用编译指导语句" class="headerlink" title="常用编译指导语句"></a>常用编译指导语句</h1><h2 id="编译指导语句的作用"><a href="#编译指导语句的作用" class="headerlink" title="编译指导语句的作用"></a>编译指导语句的作用</h2><p>编译指导语句在于告知编译器：</p><ul><li>哪些代码段应该并行进行</li><li>在并行进行的代码段中变量的属性是什么<blockquote><p>线程公有？线程私有？初始值应该如何确定？</p></blockquote></li><li>并行过程应该如何完成？各个线程应该如何配合和避免竞争</li></ul><blockquote><p>如果编译指导语句语法不对，会被当作一条注释</p></blockquote><h2 id="编译指导语句的格式"><a href="#编译指导语句的格式" class="headerlink" title="编译指导语句的格式"></a>编译指导语句的格式</h2><p>格式如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#pragma omp 指令 [子句1] [子句2] [...]</span><br></pre></td></tr></table></figure></p><blockquote><p>注：<code>[]</code> 表示可选</p></blockquote><p>解释一下指令和子句指的都是什么——</p><ul><li>指令：规定并指派线程相关的功能</li><li>子句：配合指令，完善功能的细节，辅助指令达成线程相关的任务</li></ul><p>这样解释可能还不够明晰，但是只需要先记住调用的格式，下面结合具体代码进行解释——依葫芦画瓢永远是最快的学习手段</p><h2 id="编译指导语句常用指令"><a href="#编译指导语句常用指令" class="headerlink" title="编译指导语句常用指令"></a>编译指导语句常用指令</h2><h3 id="parallel-指令"><a href="#parallel-指令" class="headerlink" title="parallel 指令"></a><code>parallel</code> 指令</h3><p><code>parallel</code> 用在一个结构块之前，表示这段代码将被多个线程并行执行；</p><p>所谓结构块，就是用花括号框起来的代码块（如果只有一句，可以不框）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>终端显示的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 1</span><br></pre></td></tr></table></figure><blockquote><p>不同次的调用得到的结果并不一样，说明线程并不是每次按固定的顺序先后进行的</p><p>而是 $3$ 个线程在同一段时间中同时调用了 <code>printf</code> 函数，<code>parallel</code> 块中的每行代码都被 $3$ 个线程重复执行。</p></blockquote><p>简单地说，<code>parallel</code> 的作用就是划定一块并行区域。</p><p>了解了 <code>parallel</code> 指令的语法，其它指令也和它类似，我们可以学得稍微快点了~</p><h3 id="for-指令"><a href="#for-指令" class="headerlink" title="for 指令"></a><code>for</code> 指令</h3><p><code>for</code> 指令一般使用在并行域（外部嵌套有 <code>parallel</code>）中，其作用是让多个线程完成<strong>同一个循环</strong>。</p><p><code>for</code> 指令可以直接和 <code>parallel</code> 连用，既创建并行区域，又指导线程共同完成循环</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出的结果只有三行，也就是一次 <code>for</code> 循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 0</span><br></pre></td></tr></table></figure><p>事实上，<code>for</code> 也可以单独使用，比如上面的语句可以修改为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这个语句中我们先划定并行区，然后让多个线程合作完成<strong>一次</strong> <code>for</code> 循环，和 <code>parallel for</code> 效果一致</p></blockquote><h3 id="sections"><a href="#sections" class="headerlink" title="sections"></a><code>sections</code></h3><p><code>sections</code> 指令一般使用在并行域（外部嵌套有 <code>parallel</code>）中，并且可以和 <code>parallel</code> 连用，成为 <code>parallel sections</code></p><p><code>sections</code> 的作用是划定一块代码区域，在代码区域内指定 <code>section</code> 代码块，不同的线程将会执行不同的代码块，通过这种方式来指导线程进行分工。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel sections</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 1\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 2\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp section</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and section 3\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe </span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 2 and section 3</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 1 and section 1</span><br><span class="line">hhh, here is thread 0 and section 2</span><br><span class="line">hhh, here is thread 0 and section 2</span><br><span class="line">hhh, here is thread 0 and section 2</span><br></pre></td></tr></table></figure><p>可见：每个线程会负责一个代码块，不同线程负责不同的代码块，代码块中不会受到其它代码块的干扰</p><blockquote><p>和 <code>for</code> 一样，<code>sections</code> 也能写成单独列出，嵌套在外层 <code>parallel</code> 中的形式 </p><p>注意：没有加 <code>parallel</code> 的 <code>sections</code> 里面的 <code>section</code> 是串行的</p></blockquote><h3 id="single-和-master"><a href="#single-和-master" class="headerlink" title="single 和 master"></a><code>single</code> 和 <code>master</code></h3><p><code>single</code> 和用在并行域内（外部嵌套有 <code>parallel</code>），表示一段只被单个线程执行的代码；</p><ul><li>使用 <code>single</code> 时执行这段代码的线程不一定是 <code>master</code> （编号为 $0$）线程，而是第一个到达 <code>single</code> 语句的线程，具有一定随机性；</li><li>而使用 <code>master</code> 时执行这段代码的线程一定是 <code>master</code> 线程。</li></ul><blockquote><p>在 <code>single</code> 和 <code>master</code> 划定的代码块执行时，其他的线程会等待直到 <code>single</code> 和 <code>master</code> 语句对应的区域执行完成</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp master</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;master %d\n run&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp single</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;the only thread to run single is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">master 0 run</span><br><span class="line">master 0 run</span><br><span class="line">master 0 run</span><br><span class="line">the only thread to run single is 1</span><br><span class="line">the only thread to run single is 1</span><br><span class="line">the only thread to run single is 1</span><br></pre></td></tr></table></figure></p><h3 id="flush"><a href="#flush" class="headerlink" title="flush"></a><code>flush</code></h3><p><code>flush</code> 保证各个 <code>OpenMP</code> 线程的数据影像的一致性</p><p>由于比较少主动使用该命令，在这里仅作简单介绍</p><h3 id="barrier"><a href="#barrier" class="headerlink" title="barrier"></a><code>barrier</code></h3><p><code>barrier</code> 用于并行域内代<code>barrier</code>码的线程同步，线程执行到 <code>barrier</code> 时要停下等待，直到所有线程都执行到barrier时才继续往下执行</p><p>如下代码，会在所有线程都执行完 <code>barrier</code> 前的语句后才执行 <code>barrier</code> 语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp barrier</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d cross barrier\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">thread 2 cross barrier</span><br><span class="line">thread 0 cross barrier</span><br><span class="line">thread 1 cross barrier</span><br></pre></td></tr></table></figure><p>如果我们把 <code>barrier</code> 相关语句去掉，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>会得到以下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0</span><br><span class="line">thread 0</span><br><span class="line">hhh, here is thread 1</span><br><span class="line">thread 1</span><br><span class="line">hhh, here is thread 2</span><br><span class="line">thread 2</span><br></pre></td></tr></table></figure><p>可以观察到线程之间并不同步。</p><blockquote><p><code>parallel</code> 和 <code>for</code> 创建区域结束时都有隐式同步 <code>barrier</code></p></blockquote><h3 id="atomic"><a href="#atomic" class="headerlink" title="atomic"></a><code>atomic</code></h3><p><code>atomic</code> 用于指定一个数据操作需要原子性地完成。即保证内存中的共享存储变量在某时刻只被同一线程修改。</p><p>这里指的数据操作就是类似于 <code>++</code>、<code>--</code> 这类操作，而比如在 <code>#pragma omp atomic</code> 语句下调用 <code>printf</code> 语句会得到一个报错。</p><p>如下，是添加了 <code>atomic</code> 语句的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp atomic</span></span><br><span class="line">        ++a;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : ++a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 2</span><br><span class="line">thread 1 : ++a is 1</span><br><span class="line">thread 2 : ++a is 3</span><br></pre></td></tr></table></figure><p>不添加 <code>atomic</code> 语句则输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 1</span><br><span class="line">thread 1 : ++a is 2</span><br><span class="line">thread 2 : ++a is 1</span><br></pre></td></tr></table></figure><p><code>++a</code> 被混乱执行，可能导致如上错误</p><blockquote><p>虽然有些时候能得到正确的结果，但是这一风险的出现是随机的</p></blockquote><h3 id="critical"><a href="#critical" class="headerlink" title="critical"></a><code>critical</code></h3><p><code>critical</code> 用在一段代码临界区之前，保证每次只有一个 <code>OpenMP</code> 线程进入，即保证程序的特定区域一次（时刻）只有一个线程执行</p><p><code>critical</code> 的作用和 <code>atomic</code> 非常相似，区别是 <code>atomic</code> 只作用于单个数据操作（原子操作），而 <code>critical</code> 作用域是一段代码块</p><p>如下，<code>critical</code> 调用 <code>printf</code> 函数不会再像 <code>atomic</code> 得到报错，理论上，只要是正确的代码块都可以使用 <code>critical</code> 划定区域</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel shared(a)</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp critical</span></span><br><span class="line">        &#123;</span><br><span class="line">            a++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread %d : ++a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果如下，三个线程合作完成了循环，但是每层循环只有一个线程进入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : ++a is 1</span><br><span class="line">thread 2 : ++a is 2</span><br><span class="line">thread 1 : ++a is 3</span><br></pre></td></tr></table></figure><h3 id="threadprivate-指令"><a href="#threadprivate-指令" class="headerlink" title="threadprivate 指令"></a><code>threadprivate</code> 指令</h3><p><code>threadprivate</code> 用于指定一个或多个变量是线程专用，将全局变量的副本与线程绑定，即使跨越多个并行区域这种关系也不会改变。</p><p>简单而言，就是为每个线程定义私有变量时增加一个<strong>保留</strong>性质——</p><p>假设有一个变量 <code>a</code> 经过了 <code>threadprivate(a)</code> 处理，<strong>保留</strong>就是让并行区域结束以后线程中的私有变量不被清除，它的值仍然被相应的线程“记忆”，并且可以在下一个并行区域中调用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>); <span class="comment">// 关闭动态线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel    <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">// 第二个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意 1 ：<code>a</code> 应该设置成一个全局变量否则会被编译器报错</p><p>注意 2 ：使用 <code>threadprivate</code> ，必须关闭动态线程机制，同时不同并行区域中的线程数保持不变</p></blockquote><p>得到的结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : a is 0</span><br><span class="line">thread 2 : a is 2</span><br><span class="line">thread 1 : a is 1</span><br></pre></td></tr></table></figure><p>可以观察到尽管在第二个并行区域并行区域中并没有给变量 <code>a</code> 赋值，但是变量 <code>a</code> 的值还是<strong>保留</strong>了第一个并行区域的设置结果</p><h2 id="编译指导语句的子句"><a href="#编译指导语句的子句" class="headerlink" title="编译指导语句的子句"></a>编译指导语句的子句</h2><h3 id="private-子句"><a href="#private-子句" class="headerlink" title="private 子句"></a><code>private</code> 子句</h3><blockquote><p>以下是关于数据共享和保护的子句</p><p>数据共享：共享的数据可以在多个线程中使用</p><p>数据保护：被保护的数据只能在个别线程中使用</p></blockquote><ul><li><code>private</code>：该子句声明列表中的所有变量都是进程私有的（变量列表列举在尾随圆括号中），如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;   <span class="comment">// 先对 x 进行定义</span></span><br><span class="line"><span class="meta">#progma omp parallel private(x)</span></span><br></pre></td></tr></table></figure><blockquote><p>声明称线程私有变量以后，每个线程都有一个该变量的副本，这些副本可以有不相同的值，并且线程之间对这些值的操作不会互相影响</p><p>注意1：原变量在并行部分不起任何作用，原变量也不会受到并行部分内部操作的影响——并行部分操作的始终不是原变量的<strong>本体</strong>，有点类似于函数的“值传递”</p><p>注意2：<code>private</code> 子句的本质只是为了名字的重用——它创建的变量储存在相应线程的栈中，而不是公共的区域。在我的系统上，如果不对私有变量进行赋值，它将被默认初始化为 $0$</p><p>受到这样的启发——我们是不是可以把线程看作是可以由我们任意指派运行时机（同时运行、先后运行）的函数呢？至少当前可以通过这样理解解释一些知识</p></blockquote><p>下面这段代码中，<code>a</code> 变量在创建以后被声明为线程私有，每个线程中的 <code>a</code> 经过各自的自增操作，因此它们的值都是 <code>2</code><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel private(a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">        a++;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 2</span><br><span class="line">hhh, here is thread 2 and a is 2</span><br><span class="line">hhh, here is thread 1 and a is 2</span><br></pre></td></tr></table></figure><blockquote><p>默认情况下，在并行区域中定义的变量属于私有变量</p></blockquote><h3 id="firstprivate"><a href="#firstprivate" class="headerlink" title="firstprivate"></a><code>firstprivate</code></h3><p><code>firstprivate</code> 的特性和 <code>private</code> 基本一致，只是多了一个附加功能——它能把所有线程私有变量（也就是原变量的副本）的初始值都设置成原变量的值，相当于 <code>private</code> 加一个初始化</p><p>将 <code>private</code> 例子的代码修改为： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel firstprivate(a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a++;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 4</span><br><span class="line">hhh, here is thread 2 and a is 4</span><br><span class="line">hhh, here is thread 1 and a is 4</span><br></pre></td></tr></table></figure><h3 id="lastprivate"><a href="#lastprivate" class="headerlink" title="lastprivate"></a><code>lastprivate</code></h3><p><code>lastprivate</code> 的特性和 <code>private</code> 基本一致，只是多了一个附加功能——它能在退出并行部分时将计算结果赋值回原变量。</p><p>规则很好理解，但是这里就会导致一个问题：如果所有线程同时操作一个变量，究竟将哪个线程操作后的变量值赋值给原变量？</p><p><code>OpenMP</code> 规范明确了这一点——在 <code>for</code> 循环迭代中，将程序语法逻辑上最后一次迭代的值赋值给原变量；在 <code>sections</code> 结构，将程序语法上的最后一个 <code>section</code> 语句赋值给原变量。</p><p>下面代码演示了这一点：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for firstprivate(a), lastprivate(a)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a += i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and a is 1</span><br><span class="line">hhh, here is thread 2 and a is 3</span><br><span class="line">hhh, here is thread 1 and a is 2</span><br><span class="line">at last, a is 3</span><br></pre></td></tr></table></figure><h3 id="shared-子句"><a href="#shared-子句" class="headerlink" title="shared 子句"></a><code>shared</code> 子句</h3><p>该子句用于声明变量列表中的所有变量都是进程公共的。</p><p>一般情况下，除非逻辑上非常严密，或者对变量有着严格的保护，否则使用 <code>shared</code> 子句都是需要非常谨慎的，比如下面的代码看上去就运行得不是那么理想——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel for shared(a)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a += i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d, a is %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at last, a is %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>运行结果是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hhh, here is thread 2, a is 9 and i is 3</span><br><span class="line">hhh, here is thread 0, a is 4 and i is 1</span><br><span class="line">hhh, here is thread 1, a is 6 and i is 2</span><br><span class="line">at last, a is 9</span><br></pre></td></tr></table></figure><blockquote><p><code>shared</code> 的子句是带有继承初值和将最终值传回给原变量的作用的</p></blockquote><h3 id="default-子句"><a href="#default-子句" class="headerlink" title="default 子句"></a><code>default</code> 子句</h3><p><code>default</code> 子句用来指定并行域内的变量的使用方式</p><p><code>default(shared)</code> 子句将所有并行区域外的变量的数据共享属性设置为共享</p><blockquote><p>注意：循环变量和在并行区域内声明的变量不受 <code>default(shared)</code> 影响</p></blockquote><p><code>default(none)</code> 子句并不设置变量的数据共享属性，但是它会强制程序员去指定所有变量的数据共享属性以确保程序的正确性</p><p>在上面已经详细解释过了数据共享属性的涵义，这里不再贴代码。</p><h3 id="copyin-子句"><a href="#copyin-子句" class="headerlink" title="copyin 子句"></a><code>copyin</code> 子句</h3><p>而 <code>copyin</code> 子句专门用于 <code>threadprivate</code> 变量，可以为所有线程的 <code>threadprivate</code> 变量分配相同的值。</p><p>用 <code>copyin</code> 子句设置的 <code>threadprivate</code> 变量，在进入并行区域时，会用主线程变量值为每个线程的该变量副本初始化。</p><p>如下代码所示，所有线程中储存的副本变量 <code>a</code> 都会被修改为 <code>0</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp threadprivate(a)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">omp_set_num_threads</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">omp_set_dynamic</span>(<span class="number">0</span>); <span class="comment">// 关闭动态线程</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel    <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="built_in">omp_get_thread_num</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel copyin(a)<span class="comment">// 第二个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : a is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try.exe</span><br><span class="line">thread 2 : a is 0</span><br><span class="line">thread 0 : a is 0</span><br><span class="line">thread 1 : a is 0</span><br></pre></td></tr></table></figure><h3 id="reduction-子句"><a href="#reduction-子句" class="headerlink" title="reduction 子句"></a><code>reduction</code> 子句</h3><p><code>reduction</code> 子句相当于两个过程——</p><ul><li>在每个线程为全局的原始变量创建属性为 <code>private</code> 的线程局部变量副本</li><li>将各个线程的局部变量副本进行指定的操作，并将操作后的结果返回全局的原始变量</li></ul><p><code>reduction</code> 子句的语法结构是这样的：<code>reduction(操作符 : 进行该操作的变量列表)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">2</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel reduction(+ : a)</span></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a += i;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d, a is %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), a, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;at last, a is %d\n&quot;</span>, a);</span><br></pre></td></tr></table></figure><p>上述代码经历的过程是这样的：</p><p>先将 <code>a</code> 变量拷贝到每个线程中作为线程私有变量，每个线程中初始化为 <code>4</code></p><p>然后线程共同完成 <code>for</code> 循环，即三个线程中的 <code>a</code> 分别加上 <code>1</code>、<code>2</code> 和 <code>3</code> 而得到 <code>5</code>、<code>6</code> 和 <code>7</code></p><p>然后进行 <code>reduction</code> 操作，即加和操作——全局的原始变量 <code>a</code> = <code>2 + 5 + 6 + 7 = 20</code>，因此代码运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0, a is 5 and i is 1</span><br><span class="line">hhh, here is thread 2, a is 7 and i is 3</span><br><span class="line">hhh, here is thread 1, a is 6 and i is 2</span><br><span class="line">at last, a is 20</span><br></pre></td></tr></table></figure><h3 id="nowait-子句"><a href="#nowait-子句" class="headerlink" title="nowait 子句"></a><code>nowait</code> 子句</h3><p>上面介绍 <code>barrier</code> 时提到： <code>parallel</code> 和 <code>for</code> 创建区域结束时都有隐式同步 <code>barrier</code></p><p><code>nowait</code> 子句即用于取消 <code>parallel</code> 和 <code>for</code> 中的默认隐含 <code>barrier</code> ，使一个线程完成指定工作后无需等待其它线程，直接进行后续的工作，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel <span class="comment">// 第一个并行区域</span></span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for nowait</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread %d : hhh\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread %d : www\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出结果得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 0 : hhh</span><br><span class="line">thread 0 : www</span><br><span class="line">thread 1 : hhh</span><br><span class="line">thread 1 : www</span><br><span class="line">thread 2 : hhh</span><br><span class="line">thread 2 : www</span><br></pre></td></tr></table></figure><p>可以发现各线程跑完 <code>for</code> 中的相关任务就直接继续执行 <code>printf(&quot;thread %d : www\n&quot;, omp_get_thread_num());</code> 了，并没有进行停留，如果去掉 <code>nowait</code>，得到的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">thread 2 : hhh</span><br><span class="line">thread 0 : hhh</span><br><span class="line">thread 1 : hhh</span><br><span class="line">thread 0 : www</span><br><span class="line">thread 1 : www</span><br><span class="line">thread 2 : www</span><br></pre></td></tr></table></figure><h3 id="num-threads-子句"><a href="#num-threads-子句" class="headerlink" title="num_threads 子句"></a><code>num_threads</code> 子句</h3><p><code>num_threads(cnt)</code> 效果等同函数 <code>omp_set_num_threads(cnt)</code>，不进行详述。</p><h3 id="schedule-子句"><a href="#schedule-子句" class="headerlink" title="schedule 子句"></a><code>schedule</code> 子句</h3><p><code>schedule</code> 子句的语法规则是：<code>schedule(strategy, chunk_size)</code></p><p><code>schedule</code> 子句用来描述如何将循环迭代划分给一组线程，包含三种方式：</p><ul><li><code>static</code> ：<code>static</code> 划分策略会将循环迭代被分成多个块，块的大小 <code>chunk_size</code> 由程序员指定，然后线程的顺序静态地分配给各线程</li></ul><blockquote><p>如果未指定块大小，则循环迭代将在线程之间尽量均匀连续地划分</p></blockquote><ul><li><p><code>dynamic</code>：<code>dynamic</code> 划分策略会将循环迭代被分成多个块，块的大小 <code>chunk_size</code> 由程序员指定，各线程完成对应的块后会申请执行新的块</p></li><li><p><code>guided</code>：<code>guided</code> 划分策略采用指导性的启发式自调度方法，开始时每个线程会分配到较大的迭代块，之后分配到的迭代块会逐渐递减。迭代块的大小会按指数级下降到指定的块大小，这个指定的块大小 <code>chunk_size</code> 可以由程序员自行指定</p></li></ul><p>如下，我们运行一下 <code>static</code> 的代码——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(static)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 0 and i is 1</span><br><span class="line">hhh, here is thread 0 and i is 2</span><br><span class="line">hhh, here is thread 0 and i is 3</span><br><span class="line">hhh, here is thread 1 and i is 4</span><br><span class="line">hhh, here is thread 1 and i is 5</span><br><span class="line">hhh, here is thread 1 and i is 6</span><br><span class="line">hhh, here is thread 2 and i is 7</span><br><span class="line">hhh, here is thread 2 and i is 8</span><br></pre></td></tr></table></figure><p><code>dynamic</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(dynamic, 3)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ./try.exe</span><br><span class="line">hhh, here is thread 1 and i is 7</span><br><span class="line">hhh, here is thread 1 and i is 8</span><br><span class="line">hhh, here is thread 1 and i is 9</span><br><span class="line">hhh, here is thread 1 and i is 10</span><br><span class="line">hhh, here is thread 1 and i is 11</span><br><span class="line">hhh, here is thread 2 and i is 1</span><br><span class="line">hhh, here is thread 2 and i is 2</span><br><span class="line">hhh, here is thread 2 and i is 3</span><br><span class="line">hhh, here is thread 2 and i is 13</span><br><span class="line">hhh, here is thread 2 and i is 14</span><br><span class="line">hhh, here is thread 2 and i is 15</span><br><span class="line">hhh, here is thread 1 and i is 12</span><br><span class="line">hhh, here is thread 0 and i is 4</span><br><span class="line">hhh, here is thread 0 and i is 5</span><br><span class="line">hhh, here is thread 0 and i is 6</span><br></pre></td></tr></table></figure><p><code>guided</code> 的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> omp for schedule(guided)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">15</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;hhh, here is thread %d and i is %d\n&quot;</span>, <span class="built_in">omp_get_thread_num</span>(), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try.exe</span><br><span class="line">hhh, here is thread 0 and i is 6</span><br><span class="line">hhh, here is thread 0 and i is 7</span><br><span class="line">hhh, here is thread 0 and i is 8</span><br><span class="line">hhh, here is thread 0 and i is 9</span><br><span class="line">hhh, here is thread 0 and i is 12</span><br><span class="line">hhh, here is thread 0 and i is 13</span><br><span class="line">hhh, here is thread 0 and i is 14</span><br><span class="line">hhh, here is thread 0 and i is 15</span><br><span class="line">hhh, here is thread 1 and i is 1</span><br><span class="line">hhh, here is thread 1 and i is 2</span><br><span class="line">hhh, here is thread 1 and i is 3</span><br><span class="line">hhh, here is thread 1 and i is 4</span><br><span class="line">hhh, here is thread 1 and i is 5</span><br><span class="line">hhh, here is thread 2 and i is 10</span><br><span class="line">hhh, here is thread 2 and i is 11</span><br></pre></td></tr></table></figure><p>事实上，它们的区别可能从输出结果上并看不出什么，但是内在的循环进行和迭代的策略是有所不同的</p><h3 id="ordered-子句"><a href="#ordered-子句" class="headerlink" title="ordered 子句"></a><code>ordered</code> 子句</h3><p>让 <code>for</code> 循环按照预期的逻辑和顺序运行</p><blockquote><p>待续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021届信息学院暑期编程集训</title>
      <link href="/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/"/>
      <url>/2022/08/31/c%E7%BC%96%E7%A8%8B%E9%9B%86%E8%AE%AD%E4%BD%9C%E4%B8%9A%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>本次编程集训的两个比较重要的任务是五子棋 <code>AI</code> 算法设计和贪吃蛇算法设计</p><p>两个游戏的共同点是：</p><ul><li><p>系统每次都会传给程序当前的游戏状态，而程序每次都重新调用——因此程序是没有“记忆”的：只能得到当前的状态，无法获取当前状态是经过了什么演变得到的</p></li><li><p>AI 的目标都是根据当前的场景作出最有利的决策——就是需要根据当前的状态进行一定的“对局面的预测”，使得即使不能获取局势的演变信息也能作出比较长远的估计</p></li></ul><h1 id="五子棋算法设计思路"><a href="#五子棋算法设计思路" class="headerlink" title="五子棋算法设计思路"></a>五子棋算法设计思路</h1><h2 id="落子权值估计"><a href="#落子权值估计" class="headerlink" title="落子权值估计"></a>落子权值估计</h2><p>落子的权值估计主要通过考虑各种情形的“价值”，五子棋中比较常规的棋形可以归结为下面几种：</p><p>五连、活四、单四、活三、单三、活二、单二、活一、单一……</p><p>此外，有几种棋形具有特殊的优势：</p><ul><li>两个单四的组合</li><li>单四和活三的组合</li><li>两个活三的组合</li></ul><p>在这三种情况下，原有的棋形会具有更高的威胁，因此应该为它们加上额外的 <code>BUFF</code> 分值，让 <code>AI</code> 能够更加贴合实际中的场景</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*六连的返回值为</span></span><br><span class="line"><span class="type">int</span> Large_Than_Six = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//*以下三个值作为基准值,它们都是必胜局面的情形*//</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Five_1 = <span class="number">500000</span>; <span class="comment">//*(1)如果将棋子放在这个位置,会产生一个五连,那么威力值设置为 5000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*必杀棋形</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Live_Four_1 = <span class="number">10000</span>;       <span class="comment">//*(2)如果将棋子放在这个位置,未产生(1),但产生一个活四,威力值设置为 1000</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Single_Four_2_BUFF = <span class="number">7000</span>; <span class="comment">//*(3)如果将棋子放在这个位置,不会产生(1)(2),但是会产生两个单四,其威力值设置为 1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*准必杀棋形 BUFF 在原有基准上如果满足这种</span></span><br><span class="line"><span class="comment">//*下面两个值是即将会产生必胜局面的情形,不论哪方造成威力都很大,因此不区分自己和对手*//</span></span><br><span class="line"><span class="comment">//*这些值由九个基因进行训练,数据灵敏度 2,数据范围 2 - 1024</span></span><br><span class="line"><span class="type">int</span> Single_Four_1_And_Live_Three_1_BUFF = <span class="number">5000</span>; <span class="comment">//*(4)如果将棋子放在这个位置,不会产生(1)(2)(3)而会产生一个单四和一个活三</span></span><br><span class="line"><span class="type">int</span> Live_Three_2_BUFF = <span class="number">4900</span>;                   <span class="comment">//*(5)如果将棋子放在这个位置,不会产生上述情况,</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="comment">//*这些值由七个基因进行训练,数据灵敏度 2,数据范围 2 - 256</span></span><br><span class="line"><span class="type">int</span> My_Single_Four = <span class="number">5500</span>;       <span class="comment">//*(6)我方单四</span></span><br><span class="line"><span class="type">int</span> Opposite_Single_Four = <span class="number">5500</span>; <span class="comment">//*(7)对方单四</span></span><br><span class="line"><span class="type">int</span> My_Live_Three = <span class="number">3000</span>;        <span class="comment">//*(8)我方活三</span></span><br><span class="line"><span class="type">int</span> Opposite_Live_Three = <span class="number">3000</span>;  <span class="comment">//*(9)对方活三</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//*下面这些情况的威胁很低,不需要区分对手的收益和自己的收益</span></span><br><span class="line"><span class="type">int</span> Single_Three = <span class="number">500</span>; <span class="comment">//*(10)单三</span></span><br><span class="line"><span class="type">int</span> Live_Two = <span class="number">100</span>;     <span class="comment">//*(11)活二</span></span><br><span class="line"><span class="type">int</span> Single_Two = <span class="number">50</span>;    <span class="comment">//*(12)单二</span></span><br><span class="line"><span class="type">int</span> Live_One = <span class="number">1</span>;       <span class="comment">//*(13)活一</span></span><br><span class="line"><span class="type">int</span> Single_One = <span class="number">1</span>;     <span class="comment">//*(14)单一</span></span><br></pre></td></tr></table></figure><p>而评估函数的设计方法是：</p><ul><li>遍历棋盘的每一个斜行、每一个横行、每一个竖列——找到棋盘中的各种上述棋形，然后将它们进行加和，作为一个棋盘状态的“价值”</li><li>我们的落子应该使得两个状态之间的价值差最大化</li></ul><p>评估函数的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getValueSum</span><span class="params">(PieceColor cur_player_color, Board tempBoard)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> valueSum = <span class="number">0</span>; <span class="comment">//*棋盘上各种棋型的价值总和</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! pieceType必须采用指针传参的形式以保证pieceType的值能被记录</span></span><br><span class="line">    Type **piecesType = <span class="keyword">new</span> Type *[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        piecesType[i] = <span class="keyword">new</span> Type[<span class="number">15</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有横行是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子并且数组中还有值,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*如果尺寸为0,不进行清算,这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有竖列是否出现目标情形</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入连续棋子</span></span><br><span class="line">            <span class="keyword">if</span> (tempBoard.pieces[j][i].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[j][i]);</span><br><span class="line">                <span class="comment">//!如果已经达到最后一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//* 判断结尾和开头是否为活</span></span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是我的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有撇斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">-14</span>; b &lt;= <span class="number">14</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++) <span class="comment">//!读取一个斜行的所有可读值并进行判定与加和</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = i + b;</span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col - <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col + <span class="number">1</span>].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//*该循环用于记录所有捺斜行是否出现目标情形</span></span><br><span class="line">    <span class="comment">//*假设坐标为 (i,j), j = -i + b, 每取一个 b 就是探索一个斜行,一共 29 斜行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> b = <span class="number">0</span>; b &lt;= <span class="number">28</span>; b++)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;Piece&gt; continousPieces;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j = -i + b;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//!如果已经达到是一个子,应该立即进行清算,否则将会有来不及清算的部分</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">14</span> &amp;&amp; continousPieces.<span class="built_in">size</span>() != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    front_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                &#123;</span><br><span class="line">                    end_is_live = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &lt; <span class="number">0</span> || j &gt; <span class="number">14</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//* 如果一个位置是当前棋手的颜色,那么就将它计入当前棋手的连续棋子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tempBoard.pieces[i][j].color == cur_player_color)</span><br><span class="line">            &#123;</span><br><span class="line">                continousPieces.<span class="built_in">push_back</span>(tempBoard.pieces[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//*当发现这个位置不是当前棋手的颜色,就开始对这个位置进行清算</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (continousPieces.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="comment">//*这种情况一般出现在该位置是连续非我棋</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">bool</span> front_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="type">bool</span> end_is_live = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row - <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        front_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span> &lt;= <span class="number">14</span> &amp;&amp; tempBoard.pieces[continousPieces.<span class="built_in">front</span>().pos.row + <span class="number">1</span>][continousPieces.<span class="built_in">front</span>().pos.col].color == none)</span><br><span class="line">                    &#123;</span><br><span class="line">                        end_is_live = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//*获取这个vector表示的区域中的价值</span></span><br><span class="line">                    valueSum += <span class="built_in">getZoneValue</span>(continousPieces.<span class="built_in">size</span>(), front_is_live, end_is_live, continousPieces, piecesType);</span><br><span class="line">                    <span class="comment">//!对continousPieces向量要及时进行清洗已备下一次使用</span></span><br><span class="line">                    continousPieces.<span class="built_in">clear</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//!用于当一个节点的类型为 Single_Four 或 Live_Three 时,加入绝杀 BUFF</span></span><br><span class="line">    valueSum += <span class="built_in">getBuffValue</span>(piecesType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] piecesType; <span class="comment">//!每次使用时 piecesType 重新定义并及时删除,防止内存泄漏</span></span><br><span class="line">    <span class="keyword">return</span> valueSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述分值的确认值来自于网上的估计和相关资料的查阅，但是实际情况来看并不完全适用于真实对战中的场景</p><p>过程中也有过先在本地搭建一个五子棋平台，然后通过已有算法作为陪练对参数（估值）使用自适应的遗传算法进行参数优化，但是因为时间紧促，考虑到每局耗时过长，很难争取到足够的训练时间，遂放弃。</p><h2 id="Alpha-Beta-剪支算法框架"><a href="#Alpha-Beta-剪支算法框架" class="headerlink" title="Alpha-Beta 剪支算法框架"></a><code>Alpha-Beta</code> 剪支算法框架</h2><p>对抗搜索是一种可以在理论上寻找到完美策略的策略，这里不作详细介绍，仅简单总结一下基于本次五子棋 <code>AI</code> 开发任务设计的 <code>Alpha-Beta</code> 剪支算法框架</p><p>本次采用的 <code>Alpha-Beta</code> 剪支算法框架流程如下：</p><p>首先介绍一下针对五子棋对抗搜索算法设计的数据结构 <code>Node</code>，具体的数据涵义已经在代码注释中说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">structNode</span>(Board board, NodeType nodeType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;board = board;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodeType = nodeType;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.row = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;place.col = <span class="number">0</span>;</span><br><span class="line">        value = (nodeType == my_max) ? max_LB : min_UB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><h3 id="alphaBetaSearch函数外：外层遍历-函数调用"><a href="#alphaBetaSearch函数外：外层遍历-函数调用" class="headerlink" title="alphaBetaSearch函数外：外层遍历 + 函数调用"></a><code>alphaBetaSearch</code>函数外：外层遍历 + 函数调用</h3><p>遍历每一个可能放置棋子的节点，对这些节点进行 <code>Alpha-Beta</code> 剪支算法搜索，并返回这些节点的最终估值</p><p>这些节点就是我们下一步要放置棋子的位置——所以它们应该是最大层节点，即 <code>nodeType = my_max</code>（节点的另一种属性是 <code>opposite_min</code>）</p><blockquote><p>事实证明：对抗搜索中，根据目的弄清楚初始节点的属性是 <code>my_max</code> 还是 <code>opposite_min</code> 非常重要</p></blockquote><p>我们刚刚已经提出，对一个节点的估值方法是——计算该节点对应的棋盘上我方棋子的总价值减去对方棋子的总价值</p><p>这样，最大层节点和最小层节点的目标也就一目了然了——最大层节点应使节点的 <code>value</code> 值尽量大，最小层节点应使节点的 <code>value</code>值尽量小</p><h3 id="alphaBetaSearch函数外：深度优先搜索-节点价值更新"><a href="#alphaBetaSearch函数外：深度优先搜索-节点价值更新" class="headerlink" title="alphaBetaSearch函数外：深度优先搜索 + 节点价值更新"></a><code>alphaBetaSearch</code>函数外：深度优先搜索 + 节点价值更新</h3><p>对抗搜索的框架和深度优先搜索的框架有一定相似性，准确地说，对抗搜索是深度搜索加入新特性的一种演变</p><p>我定义的函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>lastNode</code> 指的是上一层的节点，也就是上一层决策后的棋盘状态，而我们要往下传递的就是当前层的节点</p><p>首先根据上层节点的信息来对本层节点进行定义和赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node curNode = lastNode;</span><br><span class="line">curNode.nodeType = <span class="built_in">NodeType</span>(!lastNode.nodeType);</span><br><span class="line">curNode.value = (curNode.nodeType == my_max) ? curNode.max_LB : curNode.min_UB;</span><br></pre></td></tr></table></figure><p>然后和深度优先搜索一样，应该进行边界判断，当发现游戏结束或者达到搜索深度时应该估算并返回当前节点的价值，将这个价值向上传递</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!如果深度数值耗尽,则不再进行操作和向深处搜索,直接返回当前的节点及其价值</span></span><br><span class="line"><span class="keyword">if</span> (depth == <span class="number">0</span> || <span class="built_in">getValueSum</span>(myColor, lastNode.board) &gt;= <span class="number">500000</span> || <span class="built_in">getValueSum</span>(oppositeColor, lastNode.board) &gt;= <span class="number">500000</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//!通过节点评估获取最后一层节点的准确价值,并直接返回</span></span><br><span class="line">    curNode.value = <span class="built_in">evaluateNode</span>(curNode);</span><br><span class="line">    <span class="comment">// check(returnNode.board);</span></span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如下图所示：只有最下面一层节点是可以通过对局面的状态估算得到确切价值，其它节点都是通过对抗搜索得到的</p><center><img src = https://s1.ax1x.com/2022/09/01/v5DbHe.jpg width = 60%></center></blockquote><p>接下来应该获取每个可以放置棋子的位置，将这些位置整合到一个数组中等待遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Piece&gt; maybeChosenPiece; <span class="comment">//*可能会被遍历到的棋子</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">14</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">14</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//*如果一个位置的颜色为空并且附近有棋子</span></span><br><span class="line">        <span class="keyword">if</span> (lastNode.board.pieces[i][j].color == none &amp;&amp; <span class="built_in">havePieceNearby</span>(lastNode.board.pieces[i][j].pos, lastNode.board, R))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//*将这个位置作为一种选择放入可选序列中</span></span><br><span class="line">            <span class="comment">// pieceCnt++;</span></span><br><span class="line">            maybeChosenPiece.<span class="built_in">push_back</span>(lastNode.board.pieces[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后对这个存放可下棋位置的数组进行遍历，也就是在这些位置落子，然后将落子后的新状态作为 <code>lastNode</code> 参数，递归地调用 <code>alphaBetaSearch</code> 函数，得到这些落子情况下获得的棋盘状态价值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">   &#123;</span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">       Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">           &#123;</span><br><span class="line">               curNode.value = nextNode.value;</span><br><span class="line">               curNode.place = it.pos;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">       curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><blockquote><p>相对于深度优先搜索附加的并且非常重要的一点是：</p><p>在递归返回后的处理不仅包括状态回溯，还包括更新自身的的最优值（<code>max</code> 层则取 <code>max</code>，<code>min</code> 层则取 <code>min</code>），经过一个循环的最优值更新后，得到的 <code>curNode</code> 就是我们要返回的节点</p></blockquote><h2 id="算法加速和改进"><a href="#算法加速和改进" class="headerlink" title="算法加速和改进"></a>算法加速和改进</h2><p>上述给出的代码实际上 <code>min-max</code> 算法的代码，我们要对这个代码进行加速，实际上只需要加上几行代码进行剪枝，就能得到 <code>Alpha-Beta</code> 搜索算法</p><p>这里很重要的一点就是我们在传递节点的过程中，实际上也传递了上一层节点的 <code>lastNode.value</code> 值，</p><p>对于这个 <code>lastNode.value</code> 值的理解非常重要——</p><p>它相当于一个“指导值”，可以形象化地理解这个值：</p><blockquote><p>每一层节点都会向下一次层节点传递一个包含当前节点信息的节点，它就是下一层节点的 <code>lastNode</code> 参数</p><p>这个参数相当于一个指导值，比如下一层节点是 <code>max</code> 节点，那么如果 <code>max</code> 节点搜索到了一个比 <code>lastNode.value</code> 值大的结果，很显然，由于这个 <code>max</code> 节点要取自己所有子节点的最大值并返回，返回的值一定会大于 <code>lastNode.value</code> ，无法对 <code>lastNode.value</code> 照成改动，很显然这个 <code>max</code> 节点就是一个无效节点，直接剪枝是不会影响最终得到的结果的</p></blockquote><p>将上面的搜索代码修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!遍历每个可能选择的棋子,向下进行限制深度的dfs</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : maybeChosenPiece)</span><br><span class="line">    &#123;</span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = (curNode.nodeType == my_max) ? myColor : oppositeColor;</span><br><span class="line">        Node nextNode = <span class="built_in">alphaBetaSearch</span>(curNode, depth - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curNode.nodeType == my_max) <span class="comment">//! 如果当前是最大值节点,就取下一层节点的最大值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; nextNode.value) <span class="comment">//!如果下一个节点返回的值大于当前节点的值,就对当前节点进行更新</span></span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value; <span class="comment">//!对当前节点的 value 值进行更新</span></span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//! 如果当前是最小值节点,就取下一层节点的最小值</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &gt; nextNode.value)</span><br><span class="line">            &#123;</span><br><span class="line">                curNode.value = nextNode.value;</span><br><span class="line">                curNode.place = it.pos;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!回溯应该清洗状态：但更好的方法是更早地定义nextNode并且将修改都写在nextNode中</span></span><br><span class="line">        curNode.board.pieces[it.pos.row][it.pos.col].color = it.color; <span class="comment">//!还原这颗棋子本来的颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><p>由于剪枝的方式实际上就是直接停止当前节点的搜索进程，直接返回当前节点。所以需要进行的改动也就是在 <code>max</code> 和 <code>min</code> 节点的情况中分别增加了一句判断返回代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &gt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode; <span class="comment">//!剪掉的方式就是直接return</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (curNode.value &lt; lastNode.value)</span><br><span class="line">    <span class="keyword">return</span> curNode;</span><br></pre></td></tr></table></figure><p>另外，对于一些周围没有任何棋子的节点，我们没有必要进行搜索，一般情况下，不会有人会在这些位置落子，判断函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*该函数返回半径为 r 的范围内是否有棋子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">havePieceNearby</span><span class="params">(Pos pos, Board tempBoard, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// check(tempBoard);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos.row - r; i &lt;= pos.row + r; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = pos.col - r; j &lt;= pos.col + r; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt;= <span class="number">14</span> &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt;= <span class="number">14</span>)</span><br><span class="line">                flag += (tempBoard.pieces[i][j].color != none); <span class="comment">//*如果这个位置有棋子,就将flag+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;flag is &quot; &lt;&lt; flag &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> (flag &gt; <span class="number">0</span>); <span class="comment">//!附近有棋子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一的对抗搜索模板"><a href="#统一的对抗搜索模板" class="headerlink" title="统一的对抗搜索模板"></a>统一的对抗搜索模板</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node <span class="title">alphaBetaSearch</span><span class="params">(<span class="type">const</span> Node &amp;lastNode, <span class="type">int</span> depth)</span></span>;</span><br></pre></td></tr></table></figure><p><code>lastNode</code>：上一层节点的状态</p><p><code>curNode</code>：当前节点状态</p><p><code>nextNode</code>：下一层节点的状态</p><p>关于 <code>Node</code> 的定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">structNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> value;         <span class="comment">//!用minmax计算的当前节点的价值</span></span><br><span class="line">    Pos place;         <span class="comment">//!基于当前的棋盘状态,应该选择哪个点</span></span><br><span class="line">    NodeType nodeType; <span class="comment">//!当前节点是最大值节点还是最小值节点</span></span><br><span class="line">    Board board;       <span class="comment">//!当前的棋盘状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>第一步：进行边界判断，是否达到搜索深度或者博弈结局</p></li><li><p>第二步：搜索整个决策空间，将可行决策纳入一个数组中</p><blockquote><p>第二步有一定的剪枝空间，可以调整决策空间的大小</p></blockquote></li><li><p>第三步：遍历整个可行决策数组，对于每个可行决策，对 <code>curNode</code> 进行修改并作为参数调用 <code>alphaBetaSearch</code> ，将返回的节点作为 <code>nextNode</code></p></li><li><p>第四步：根据 <code>nextNode.value</code> 是否比 <code>curNode.value</code> 更优来决定是否对本层节点的 <code>value</code> 值进行更新</p></li><li><p>第五步：如果更新后的节点可以确认当层节点的 <code>curNode.value</code> 值一定不能达到对 <code>lastNode.value</code> 的修改条件，就直接剪枝（当场返回当前节点）</p></li><li><p>第六步：不满足第五步的操作条件，那么对 <code>curNode</code> 进行状态回溯，继续第三、四、五步的循环中的剩余部分，完成循环后， 则 <code>curNode.value</code> 已经被更新为最优值，返回。</p></li></ul><h1 id="贪吃蛇算法设计思路"><a href="#贪吃蛇算法设计思路" class="headerlink" title="贪吃蛇算法设计思路"></a>贪吃蛇算法设计思路</h1><h2 id="食物价值传播"><a href="#食物价值传播" class="headerlink" title="食物价值传播"></a>食物价值传播</h2><p>该贪吃蛇游戏的食物分布是遍布全图的，但是也会碰到这样一种尴尬的情况：就是一些在一些区域中自己的搜索范围内不存在任何的食物，这种情况很有可能就会导致蛇原地打转，非常影响发育。其次，即使有搜索能力，搜索范围过小也有可能导致蛇进入“短视”的状态，体现为它并不关心更远距离的高分值食物，而是只会追逐近距离的低分值食物。因此，引入了食物价值传播的函数——</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foodValueSpread</span><span class="params">(<span class="type">int</span> round)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= round; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">29</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">39</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j - <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">                    map[j][k - <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= <span class="number">29</span>)</span><br><span class="line">                    map[j + <span class="number">1</span>][k].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">                <span class="keyword">if</span> (k + <span class="number">1</span> &lt;= <span class="number">39</span>)</span><br><span class="line">                    map[j][k + <span class="number">1</span>].foodValue += map[j][k].foodValue * Value_Spread_Rate;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数的作用是：将具有食物的位置的“食物价值”按照一定的衰减比例散布到周围四个位置，当我们进行了若干轮这样的传播以后，如果将食物的分值视为高度，整个地图的纵直方向的形状就类似于山地分布——我们的蛇只要向山地中的较高处运动，就能够保证兼具食物价值判断和追逐食物两个效果。</p><p>经过实践调整参数，食物价值传播的轮次设置为 $5$，食物价值传播的价值衰减率设置为 $0.57$</p><h2 id="大区域和小区域的权衡"><a href="#大区域和小区域的权衡" class="headerlink" title="大区域和小区域的权衡"></a>大区域和小区域的权衡</h2><p>在衡量一个位置的价值时，尽管有上述的食物价值图传播操作，但是传播的数量毕竟只有几轮，没办法普及到整个地图的所有位置，因此蛇的方向选择能然有可能只在局部上看来是较优的，但是从全局看来，蛇并没有主动地去移动到资源丰富的地区。所以，一个比较好的方法是同时衡量大区域的移动收益和小区域的移动收益选出最佳的移动方向。</p><p>对于大区域的移动收益，我主要采用区域价值密度作为衡量标准进行量化，考虑的标准有：</p><ul><li>区域的显示价值：所有食物和道具的价值总和</li><li>区域的隐式价值：当有蛇处在这个区域中，杀死它可以获得丰富的收益，这种收益被称为区域的隐式价值</li><li>区域的距离：一个区域距离自己越远，它的价值就相应地降低</li><li>区域的风险：其它蛇和障碍物会给一个区域带来风险——区域的风险对于区域价值而言是负增长的</li></ul><p>将这些因素乘以它们相应的权重，就能够得到一个区域的总价值，在程序中，这个总价值被称为 <code>largeZoneEvaluation</code> ，相应地，一个节点对应的近距离价值收益被称为 <code>closeZoneEvaluation</code>，<code>largeZoneEvaluation</code> 和 <code>closeZoneEvaluation</code> 乘以各自的权重，最终组成一个点的价值总和，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取一个点的利益（最终决策函数）</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">double</span> <span class="title">getPosValue</span><span class="params">(Pos position)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 求出这一点的宏观收益 largeZoneValue</span></span><br><span class="line">    <span class="comment">// 思路：判断这一点的位置和自己的当前位置相比是否距离最富裕区域更近</span></span><br><span class="line">    Pos direc = &#123;position.row - me.bodies.<span class="built_in">front</span>().row, position.col - me.bodies.<span class="built_in">front</span>().col&#125;;</span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> largeZoneValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (direc.row &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(down, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.row &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(up, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(right, position);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (direc.col &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        largeZoneValue = <span class="built_in">newLargeZoneEvaluation</span>(left, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求出这一点的纯粹价值收益 pureValue</span></span><br><span class="line">    <span class="comment">// 思路：bfs 图传播</span></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> closeZoneValue = <span class="built_in">closeZoneEvaluation</span>(position, SearchDepth);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">double</span> temp_Large_Zone_Weight = Large_Zone_Weight;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp_Large_Zone_Weight * largeZoneValue / Large_Zone_Evaluation_Standard + Close_Zone_Weight * closeZoneValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当参数调整得当时，理想的效果应该是，蛇会以资源丰富地区为大方向，并且向这个大方向不断靠近，过程中会主动选择吃掉得分较高的食物，实现快速发育的目标。</p><h2 id="策略计算和选择"><a href="#策略计算和选择" class="headerlink" title="策略计算和选择"></a>策略计算和选择</h2><p>本程序中，在决定向上下左右移动或是使用盾牌/障碍物前，会先经过一个策略选择的流程——</p><p>我为贪吃蛇程序确定了四种策略，它们分别是</p><ul><li>发育策略</li><li>逃跑策略</li><li>攻击策略</li><li>防御策略</li></ul><p>进行策略选择有以下这些流程：</p><ul><li>第一步：判断自己当前是否处在危险当中</li></ul><blockquote><p>主要通过判断区域的风险程度，并且设置一个“危险阈值”参数，当超过这个参数时，就会认定这片区域是存在风险的。这个参数越大，蛇的表现就会越“大胆”</p></blockquote><ul><li>第二步：计算贪心路径和逃跑路径的收益总和</li></ul><blockquote><p>进行深度为 $5$ 的搜索，计算出贪心路径和逃跑路径的总收益</p><p>逃跑路径指的是将风险权重设为 $0.7$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条逃跑路径的价值总和</p><p>贪心路径指的是将风险权重设置为 $0.3$，节点价值总和权重设置为 $0.3$，基于这两个参数计算出整条贪心路径的价值总和</p><p>在第一步中，如果判断为非危险，就不可能采取逃跑路径，如果判定为危险，就会选择贪心路径或逃跑路径，此时需要对它们进一步判断</p><p>设置一个贪心阈值，如果两条路径的价值差超过了贪心阈值，就会采取贪心路径，否则认为不值得冒险，采取逃跑路径。贪心阈值越大，蛇的表现就会越“贪心”</p></blockquote><ul><li>第三步：计算当前是否值得采取攻击策略或是防御策略</li></ul><blockquote><p>当第一步中判断此时处在危险当中时，就会决定是否采取两个特殊策略</p><p>这两个特殊策略都是经过特判决定是否采取，特判的标准有：被攻击蛇的价值，附近蛇的数量，时间……</p></blockquote><ul><li>第四步：根据以上得到的数据选择一个策略</li></ul><p>事实上，以上操作的主要算法思想还是贪心：关键在于如何对贪心进行改善，使得不易陷入局部最优解并且通过对风险进行估值，使决策的结果考虑了一定“对抗”的因素</p><h1 id="反思和总结"><a href="#反思和总结" class="headerlink" title="反思和总结"></a>反思和总结</h1><h2 id="参数管理和优化"><a href="#参数管理和优化" class="headerlink" title="参数管理和优化"></a>参数管理和优化</h2><p>这点缺陷在贪吃蛇项目中显得尤为明显——总共设置的参数多达二十多个，这种情况下，参数管理显得尤为艰难，很多函数/功能在最后比赛时其实反到没有发挥它们的效果</p><p>在程序设计时，尽管设计每个参数都有考虑这些参数包含的涵义，但是当参数数量多时，很容易出现数据崩坏——一些参数的标准值一旦无法确定，就会增加很大的不确定性，那么，二十多个参数的组合很快就会成为一组混沌而无法预测的参数系统。</p><p>直到最后，调节参数很大程度基于直觉，这就让模型失去原有的意义，所以，参数的个数并不越多越好，并且尽量应该在设定一个参数后及时测量它们的标准，防止出现数据过于膨胀导致的问题。</p><h2 id="模型构建和实现步骤"><a href="#模型构建和实现步骤" class="headerlink" title="模型构建和实现步骤"></a>模型构建和实现步骤</h2><p>本次集训中发现的另一个问题是：在模型的构建过程总是期待一举建成完善和全面的模型，而调 <code>BUG</code> 的时间往往达到构建模型时间的两倍以上，事实上这是并不合理的一种开发方式——</p><p>以贪吃蛇为例，这个游戏的两个难点应该是各种棋形的判断和<code>Alpha-Beta</code> 剪枝函数的设计。我的做法是一次性地写好各种棋形的判断和 <code>Alpha-Beta</code> 剪枝函数，但是最后调 <code>BUG</code> 时发现了问题只好在整个程序中一步步搜寻。</p><p>但是，倘若在设计完棋形判断的函数后，并不马上进行 <code>Alpha-Beta</code> 剪枝函数的设计，而是先写一个根据每一点分值高低进行下棋的贪心算法程序。运行后根据下棋的效果很容易就能发现自己漏判断了什么棋形（或者哪种棋形判断出错），将棋形判断函数修改完善以后，再进行 <code>Alpha-Beta</code> 剪枝函数的设计，后续如果又出现问题，那么就在 <code>Alpha-Beta</code> 剪枝函数中寻找 <code>BUG</code> ，这样降低了代码检查的范围。</p><p>所以，很重要的一点教训就是——罗马非一日建成。复杂是简单的叠加，即使一开始就构思出非常复杂的模型时，也应该思考如何将这些复杂程序分解成小的步骤，如何在这些小的步骤中插入检测点，使得能够在逐步完成大作业最终任务的同时保证其正确性。</p>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LINGO 语言入门指南</title>
      <link href="/2022/08/21/cLINGO%E6%8C%87%E5%8D%97/"/>
      <url>/2022/08/21/cLINGO%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）为什么是-LINGO"><a href="#（一）为什么是-LINGO" class="headerlink" title="（一）为什么是 LINGO"></a>（一）为什么是 LINGO</h1><p><code>LINGO</code> 是一款专门用于解决规划类问题的软件。在处理线性规划问题上，和 <code>MATLAB</code> 相比，<code>LINGO</code> 更具有优势：</p><ul><li>可以支持二维决策变量</li><li>求解 <code>NLP</code> 问题时不需要进行初值估计</li><li>使用集合命令，更加直观，方便描述复杂条件</li><li>不需要人为指定算法，减少了理解算法的过程</li></ul><p>对于 <code>LINGO</code> 软件的使用，可以分为以下两种方法——</p><ul><li>直接描述法：用数学语言直接描述出线性规划模型的约束条件、决策变量和目标函数</li><li>建模描述法：通过用 <code>LINGO</code> 编程语言描述线性规划模型的变量和条件，实现模型的求解</li></ul><h1 id="（二）LINGO-直接描述法"><a href="#（二）LINGO-直接描述法" class="headerlink" title="（二）LINGO 直接描述法"></a>（二）LINGO 直接描述法</h1><p>直接描述法几乎没有难度——就是把数学问题几乎原样地在 <code>LINGO</code> 编程区描述一下，比如下面的代码就能直接在 <code>LINGO</code> 上运行，即使不需要注释也能很轻松地看懂.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">max = 4 * x + 3 * y;</span><br><span class="line">2 * x + 3 * y &lt;= 10;</span><br><span class="line">x &gt;= 1;</span><br></pre></td></tr></table></figure><blockquote><p>在默认情况下，<code>LINGO</code> 会指定决策变量的取值都是大于 $0$ 的，解除这个限制需要使用 <code>@free</code> 函数</p><p>和 <code>MATLAB</code> 不同，<code>LINGO</code> 可以通过关键字 <code>max</code> 或 <code>min</code> 来指定目标函数是取最大/最小值</p><p>如果不指明关键字 <code>max</code> 或 <code>min</code> 比如将第一行代码修改为： <code>a = 4 * x + 3 * y</code></p><p>返回的提示就不再是 <code>Global optimal solution found.</code> ，而是 <code>Feasible solution found</code> ，表示找到可行解。</p></blockquote><p>运行结果如下，<code>LINGO</code> 会返回一个窗口，然后再窗口中详细描述本次规划问题解决的信息</p><center><img src = https://s1.ax1x.com/2022/08/21/vyy9RH.png width = 65%></center><blockquote><p>一般而言，简单的线性规划模型我们都会采用 <code>LINGO</code> 的直接描述法而不必进行建模描述</p></blockquote><h1 id="（三）LINGO-数据组织"><a href="#（三）LINGO-数据组织" class="headerlink" title="（三）LINGO 数据组织"></a>（三）LINGO 数据组织</h1><h2 id="LINGO-数据类型——集"><a href="#LINGO-数据类型——集" class="headerlink" title="LINGO 数据类型——集"></a>LINGO 数据类型——集</h2><p><code>LINGO</code> 的集定义为：一群相联系的对象。事实上，“集”就是一个由对象组成的群体。</p><p><code>LINGO</code> 的集分为两种类型——</p><ul><li>原始集：只由对象组成</li><li>派生集：可以由原始集组成，也可以包含其它派生集</li></ul><p>集合的定义：</p><p>我们直接从一个现实实例来具体说明如何定义 <code>LINGO</code> 集合类型：</p><p><code>LINGO</code> 中的所有集合变量必须定义在一个框架中：框架的开头是 <code>sets:</code> ，框架的末尾是 <code>endsets</code> ，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sets:</span><br><span class="line">    !这是一个可以跨越多行的注释（用 &#x27;!&#x27; 开头，用 &#x27;;&#x27; 结尾）</span><br><span class="line">    set1</span><br><span class="line">    set2</span><br><span class="line">    ......</span><br><span class="line">    set3</span><br><span class="line">    ;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure><p>假设我们要将一个学生群体定义成 <code>LINGO</code> 集合数据的形式。</p><p>我们可以单纯地只定义一个学生群体的集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student;</span><br></pre></td></tr></table></figure><p>我们也可以为这个学生集合添加属性变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student: name, age; </span><br></pre></td></tr></table></figure><p>这行代码的语法表示：我们定义学生群体，这个对象有性别和年龄两个属性变量</p><p>而当我们要阐释一个群体中所有成员时，则可以采用下面的语法（显示罗列法）逐个罗列出对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student/stu1, stu2, stu3/: name, age;</span><br></pre></td></tr></table></figure><p>这行代码表示学生集合中有三个对象：他们分别是<code>stu1</code>，<code>stu2</code> 和 <code>stu3</code></p><p>而当我们要定义更多的集合对象时，很明显我们不能一个一个的输入对象们的名字——当数据量一大，这实在是不小的工程量。幸运的是 <code>LINGO</code> 提供了隐式罗列法：这也是 <code>LINGO</code> 的特别之处，它定义了 <code>..</code> 运算符，这个运算符可以智能地根据规律来填充我们没有完全写出的集合对象名，我们可以像下面这样使用它——</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student/stu1..stu100/: name, age;</span><br></pre></td></tr></table></figure><p>这行代码表示学生集合中一共有 $100$ 个学生对象，它们的对象名分别是 <code>stu1</code> ，<code>stu2</code>，$\cdots$ ，<code>stu100</code></p><blockquote><p><code>LINGO</code> 大小写不敏感——这意味着 <code>STU1</code> 和 <code>stu1</code> 代表完全相同的涵义</p><p><code>LINGO</code> 规定在集合数据类型的定义中只有集合名字是必须声明的，而集合的成员列表和属性变量列表都是可以省略的</p></blockquote><p>另外我们还可以通过已有的集合来定义新的集合，这就是派生集的定义。</p><p>考虑工厂加工问题的求解：我们需要定义不同工人操作不同机器，他们加工不同产品，那么可行方案就应该是：哪个工人 + 操作哪台机器 + 生产哪个产品，定义方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sets:</span><br><span class="line">! 原始集;</span><br><span class="line">worker:/worker1..worker3/: efficiency;    ! 工人效率;</span><br><span class="line">machine:/machine1..machine3/: quality;    ! 机器质量;</span><br><span class="line">product:/product1..product3/: value, cost; ! 产品价值和消耗;</span><br><span class="line"></span><br><span class="line">! 派生集;</span><br><span class="line">allowed_plan(worker, machine, product): evaluation;    ! 对可行方案的评价;</span><br><span class="line">endsets</span><br></pre></td></tr></table></figure><p>像上面这样，派生集的所有对象实际上就是原始集的所有对象的组合，即 $(workeri,machinej, productk)\; ,i\in(1,3),\; j\in(1,3),\; k\in(1,3)$ ，这种派生集就称为<strong>稠密集</strong></p><p>相反，如果原始集的所有对象的组合并不包含在派生集中，那么这种派生就被称之为<strong>稀疏集</strong></p><p>此外，我们经常看到 <code>links</code> 相关的语法，事实上它们的本质也是派生集，只是 <code>links</code> 显示地指出这些集是派生出来</p><blockquote><p>也有人用“矩阵工厂”的概念来描述集合，我赞同他们的观点</p></blockquote><h1 id="（四）LINGO-集合初始化"><a href="#（四）LINGO-集合初始化" class="headerlink" title="（四）LINGO 集合初始化"></a>（四）LINGO 集合初始化</h1><p>在定义了“集合”这种数据类型之后，我们就可以对这些集合数据类型进行初始化赋值</p><p><code>LINGO</code> 的集合初始化也是需要定义在一定的框架内，这个框架的形式如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">   !将数据定义在这里面;</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><p>我们对集合数据类型进行初始化赋值，本质上是对属于集合的所有成员对象的属性变量进行赋值，还是通过上面那个工人借助机器生产产品的例子，我们对这个例子中的数据进行赋值——</p><h2 id="对集合对象的所有属性变量进行初始化"><a href="#对集合对象的所有属性变量进行初始化" class="headerlink" title="对集合对象的所有属性变量进行初始化"></a>对集合对象的所有属性变量进行初始化</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">efficiency = 4 3 2</span><br><span class="line">quality = 3 2 1</span><br><span class="line">value = 50 20 10</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><p>像上面这样，我们可以通过每行对一个变量进行赋值，Lingo语言会帮我们将这些空格隔开的数字按照顺序相应的赋值给集合的成员对象</p><p>比如 <code>efficiency</code> 那一行中 <code>=</code> 后的 $3$ 个数字分别意味着 <code>worker1</code> 的效率是 $4$ ，<code>worker2</code> 的效率是 $3$ ，<code>worker3</code> 的效率是 $2$ ，剩下两行的内容同理可得</p><p>当然对于那些对象个数一样的属性变量我们可以将它们放在一行中一起赋值，这个时候数据的组织顺序有所不同，比如我们可以将上面 $3$ 个属性变量（因为它们的对象个数都是 $3$ 个）放在一行中，然后将要输入的数据组织成矩阵进行赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data:</span><br><span class="line">efficiency, quality, value = 4 3 50</span><br><span class="line">                             3 2 20</span><br><span class="line">                             2 1 10;</span><br><span class="line">enddata</span><br></pre></td></tr></table></figure><blockquote><p><code>LINGO</code> 通过换行隔离开不同个数据</p></blockquote><p>在上面这个 $3\times3$ 的矩阵中，第一列代表了工人的效率，第二列代表机器的品质，第三列则代表产品的价值</p><p>这样我们的数据类型描述就算完成了。当然你可能会疑问：那些只能被规定为整数变量的数据类型应该怎么描述呢？这就涉及到 <code>LINGO</code> 函数的使用，紧接着将会解释这一部分内容。</p><h2 id="其他特殊的数据初始化方式"><a href="#其他特殊的数据初始化方式" class="headerlink" title="其他特殊的数据初始化方式"></a>其他特殊的数据初始化方式</h2><ul><li>在所有集合对象中将一个属性变量初始化为同一个值</li></ul><p>比如我们设置所有工人的效率一样，都为 $3$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 3;</span><br></pre></td></tr></table></figure><ul><li>实时数据处理</li></ul><p>比如我们设置 <code>worker2</code> 的效率为非定值，只要在本该放书的地方输入一个 <code>?</code> 即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 2 ? 4;</span><br></pre></td></tr></table></figure><ul><li>未知数值处理</li></ul><p>我们希望在程序模型中将一个属性变量在部分成员对象中设置为未知，以便让 <code>LINGO</code> 求出它们的最优解</p><p>在属性变量的某些值为未知的时候，我们不能再用空格隔开不同的值，而应该用逗号来取代，如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">efficiency = 2, , ;</span><br></pre></td></tr></table></figure><p>这里表示 <code>worker2</code> 和 <code>worker3</code> 的 <code>efficiency</code> 都是未知的</p><h1 id="（五）LINGO-运算符"><a href="#（五）LINGO-运算符" class="headerlink" title="（五）LINGO 运算符"></a>（五）LINGO 运算符</h1><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>当我们需要使用 <code>LINGO</code> 来描述一个线性规划问题时，很自然的就需要使用逻辑运算符来描述问题应该满足的条件</p><p><code>LINGO</code> 提供了 $9$ 种逻辑运算符，如下表所示：</p><div class="table-container"><table><thead><tr><th>运算符名称</th><th>运算符涵义</th></tr></thead><tbody><tr><td>#not#</td><td>一元运算符，否定该操作数的逻辑值</td></tr><tr><td>#eq#</td><td>若两个运算数相等，则为 true ，否则为 false</td></tr><tr><td>#gt#</td><td>若左边的运算符严格大于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#ge#</td><td>若左边的运算符大于或等于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#lt#</td><td>若左边的运算符严格小于右边的运算符，则为 true ，否则为 false</td></tr><tr><td>#le#</td><td>若左边的运算符小于或等于右边的运算符，则为true，否则为false</td></tr><tr><td>#and#</td><td>仅当两个参数都为true时，结果为true，否则为false</td></tr><tr><td>#or#</td><td>仅当两个参数都为false时，结果为false，否则为true</td></tr></tbody></table></div><h2 id="算术运算符和关系运算符"><a href="#算术运算符和关系运算符" class="headerlink" title="算术运算符和关系运算符"></a>算术运算符和关系运算符</h2><p><code>LINGO</code> 提供了 $5$ 种二元运算符，优先级和我们平常认知的相同</p><p>即 <code>^</code>、<code>*</code>、<code>/</code>、<code>+</code> 和 <code>-</code> 。</p><p>一元运算符只有取反：<code>-</code></p><p><code>LINGO</code> 关系运算符主要用于描述约束条件，它们和逻辑运算符并不相同，不存在真假，只要是被关系运算符所描述的，就是在我们的模型中所有决策变量必须遵守的条件。</p><p>提供了 $3$ 种关系运算符，即 <code>=</code>、<code>&lt;=</code> 和 <code>&gt;=</code> 。但 <code>LINGO</code> 并不支持严格小于和严格大于的关系算符，不过我们可以通过修改小于等于式来实现这种关系：</p><p>如 $a&gt;b$ 可以修改为 $a+\epsilon&gt;=b$，$\epsilon$ 是一个很小的正数，它的取值取决于于我们模型中所需要的精度。</p><h1 id="（六）LINGO函数"><a href="#（六）LINGO函数" class="headerlink" title="（六）LINGO函数"></a>（六）LINGO函数</h1><p><code>LINGO</code> 的函数特点是：每个函数都在开头位置有一个 <code>@</code> 符表示这是一个函数。</p><p><code>LINGO</code> 的函数有如下几种分类——</p><h2 id="变量界定函数"><a href="#变量界定函数" class="headerlink" title="变量界定函数"></a>变量界定函数</h2><p>变量界定函数实现对决策变量取值范围的附加限制：</p><ul><li><code>@bin(x)</code> 限制 $x$ 为 $0$ 或 $1$</li><li><code>@bnd(L, x, U)</code> 限制 $L\le x\le U$</li><li><code>@free(x)</code> 取消对变量 $x$ 的默认下界为 $0$ 的限制，即 $x$ 可以取任意实数</li><li><code>@gin(x)</code> 限制 $x$ 为整数</li></ul><blockquote><p>在默认情况下，<code>LINGO</code> 规定变量是非负的，也就是说下界为 $0$，上界为 $+\infty$。<code>@free</code> 取消了默认的下界为 $0$ 的限制，使变量也可以取负值。<code>@bnd</code> 用于设定一个变量的上下界,它也可<br>以取消默认下界为 $0$ 的约束。</p></blockquote><h2 id="集循环函数"><a href="#集循环函数" class="headerlink" title="集循环函数"></a>集循环函数</h2><p>集循环函数通过遍历属性变量所在的整个集的所有对象来进行操作：</p><p>集循环函数的语法是：<code>@for(集合名(i): [对属性名(i)的相关操作])</code></p><p>上面的语法看起来很抽象我们还是通过上面的例子来解释一下这个语法——</p><p>假设我们希望对工人的效率进行赋值，使得工人的效率满足：$工人的效率 = 工人的索引 \times 2 + 1$，可以使用下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@for(worker(i): efficiency(i) = 2 * i + 1);</span><br></pre></td></tr></table></figure><p>如果我们只想操作 <code>worker1</code> 和 <code>worker2</code> 也可以通过 <code>|</code> 后添加范围的语法调用：</p><blockquote><p>操作范围是一个逻辑表达式，当这个逻辑表达式为真时就会对 <code>:</code> 后面的相应索引的属性变量进行相应操作。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@for(worker(i) | i #le# 2 : efficiency(i) = 2 * i + 1);</span><br></pre></td></tr></table></figure><p><code>@sum</code> 函数、 <code>@min</code> 函数、 <code>@max</code> 函数和 <code>prog</code>函数（求积）的语法都非常类似，它们也可以添加函数操作范围，并用竖线 <code>|</code> 分隔属性名和操作范围。</p><p>如下的代码用来计算 $3$ 个工人的效率总和以及前 $2$ 个工人的效率最大值和最小值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">efficiency_sum = @sum(worker(i) | i #le# 3 : efficiency);</span><br><span class="line">efficiency_min = @min(worker(i) | i #le# 2 : efficiency);</span><br><span class="line">efficiency_max = @max(worker(i) | i #le# 2 : efficiency);</span><br></pre></td></tr></table></figure><p>我们详细解释一下第二行代码的意思吧：他表示对 <code>worker</code> 中的 <code>efficiency</code> 属性求解最小值并且索引 <code>i</code> 小于等于 $2$，这意味着他在进行这个函数的时候只会考虑前 $2$ 个对象的 <code>efficiency</code> 属性</p><p>当然我们也可以不指定范围这样就默认对集合中所有成员对象的某个属性变量进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">efficiency_sum = @sum(worker : efficiency);</span><br><span class="line">efficiency_min = @min(worker : efficiency);</span><br><span class="line">efficiency_max = @max(worker : efficiency);</span><br></pre></td></tr></table></figure><p>上面三行代码表示求解所有工人效率的总和、最小值和最大值。</p><blockquote><p>这些集循环函数的调用其实都很相似，只是 <code>@for</code> 函数需要指定操作方式，其它四种只需要指定操作的属性，仅此而已</p><p>可以统一成这种格式：<code>@函数名(集合名(索引) | 范围界定（可选） : 要操作的属性变量或要进行的操作)</code></p><p>很经常地，这些集合操作函数不只是对集合进行操作，往往还用来描述目标函数和约束条件，可以到最后的例题中体会实际使用的方法</p><p>可以让要操作的属性可以不属于集合名，而只是把集合名当作提供索引的“工具人”，如后面例题中的 $TSP$ 问题描述每行/每列之和为 $1$ 时的处理</p></blockquote><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>数学函数是 <code>LINGO</code> 语言中几乎最重要的函数。因为我们刚刚说过 <code>LINGO</code> 只支持 $5$ 种最基本的运算符号，而要实现复杂的函数就必须调用数学函数。</p><p>数学函数都是顾名思义就能理解，可以参见下面这张表格：</p><center><img src = https://s1.ax1x.com/2022/08/21/vysxIO.png width = 40%></center><h2 id="逻辑判断函数"><a href="#逻辑判断函数" class="headerlink" title="逻辑判断函数"></a>逻辑判断函数</h2><p><code>@if</code> 函数是一个逻辑判断函数，通常仅仅在分段函数处出现，一般其出现频率、使用次数不高。</p><p>函数调用形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(条件描述, 满足条件的返回值, 不满足条件的返回值)</span><br></pre></td></tr></table></figure><p>比如我们希望定义一个分段函数，在小于等于零时返回 $0$ ，在大于零时返回原值，就可以用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(x #le# 0, 0, x);</span><br></pre></td></tr></table></figure><p>我们还可以为逻辑判断函数设置嵌套，比如我们希望在小于等于 $-2$ 时返回 $x^2$ 而不是 $0$，就可以：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@if(x #le# 0, @if(x #le# -2, x^2, 0), x);</span><br></pre></td></tr></table></figure><p>这行代码在满足条件的返回值处内嵌了一个 <code>@if</code> 函数</p><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><h3 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h3><p>一些输入输出函数可以用来帮助我们节约从文件转移数据的时间。</p><ul><li><code>@file(&#39;filename&#39;);</code> ： 从外部文件输入数据</li><li><code>@text(&#39;filename&#39;);</code> ： 将指定内容输出到文本文件中</li><li><code>@ole(&#39;filename&#39;)</code> ： 从 <code>EXCEL</code> 中引入或输出数据</li><li><code>@warn(&#39;text&#39;, logical_condition)</code> ： 如果逻辑条件 <code>logical_condition</code> 为真，则产生一个内容为<code>&#39;text&#39;</code> 的信息框。</li></ul><h3 id="返回信息函数"><a href="#返回信息函数" class="headerlink" title="返回信息函数"></a>返回信息函数</h3><p>一些函数返回信息函数能返回模型中求解的情况</p><ul><li><code>@status()</code> ： 返回 LINGO 求解模型结束后的状态：是否可行，全局/局部最优</li><li><code>@dual(variable_name)</code> ： 返回变量的判别数的影子值</li></ul><h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p><code>@rand(seed)</code> ： 返回 $0$ 和 $1$ 间的伪随机数，依赖于指定的种子。</p><blockquote><p>一下子记忆太多内容是痛苦的，这些函数留到需要使用时再查阅具体资料即可（但是知道它们的存在倒是一件重要的事）</p><p>概率函数和金融函数不包含在以上函数中，读者可以在需要使用时自行检索。</p></blockquote><h1 id="（七）LINGO-模型描述"><a href="#（七）LINGO-模型描述" class="headerlink" title="（七）LINGO 模型描述"></a>（七）LINGO 模型描述</h1><p>我们直接用两个具体的例子来讲解 <code>LINGO</code> 的模型描述法如何处理规划类问题</p><h2 id="例题-1"><a href="#例题-1" class="headerlink" title="例题 $1$"></a>例题 $1$</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><center><img src = https://s1.ax1x.com/2022/08/21/vyypJe.png width = 60%></center><h3 id="代码和注释"><a href="#代码和注释" class="headerlink" title="代码和注释"></a>代码和注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">model: ! 模型应写在 model 和 end 间的框架中 ;</span><br><span class="line"></span><br><span class="line">sets: ! 集合数据类型定义 ;</span><br><span class="line"></span><br><span class="line">! 定义 6 个仓库以及它们的容量属性 ;</span><br><span class="line">warehouse/w1..w6/: capacity; </span><br><span class="line"></span><br><span class="line">! 定义 8 个客户以及他们的订单量属性 ;</span><br><span class="line">client/c1..c8/: requirements; </span><br><span class="line"></span><br><span class="line">! 派生上面集合，links 集合的元素是上面两个集合的两两组合，这些元素有一个属性 freight ，相当于 freight(i, j) 为从仓库 i 运输给客户 j 所需要的运费 ;</span><br><span class="line">! 同理 plan(i, j) 表示我们计划从仓库 i 运输给客户 j 的货运量，它就是本题的决策变量;</span><br><span class="line">links(warehouse, client): freight, plan;</span><br><span class="line"></span><br><span class="line">endsets</span><br><span class="line"></span><br><span class="line">data: ! 集合数据类型赋值 ;</span><br><span class="line"></span><br><span class="line">capacity = 60, 55, 51, 43, 41, 52;</span><br><span class="line">requirements = 35, 37, 22, 32, 41, 32, 43, 38;</span><br><span class="line">freight = 6, 2, 6, 7, 4, 2, 5, 9</span><br><span class="line">          4, 9, 5, 3, 8, 5, 8, 2</span><br><span class="line">          5, 2, 1, 9, 7, 4, 3, 3</span><br><span class="line">          7, 6, 7, 3, 9, 2, 7, 1</span><br><span class="line">          2, 3, 9, 5, 7, 2, 6, 5</span><br><span class="line">          5, 5, 2, 2, 8, 1, 4, 3;</span><br><span class="line">enddata</span><br><span class="line"></span><br><span class="line">! 目标函数是求解总运费的最小值 ;</span><br><span class="line">min = @sum(links(i, j) : freight(i, j) * x(i, j)); </span><br><span class="line"></span><br><span class="line">! 约束条件1：一个仓库运出的最大货物不应该超过仓库中的所有货物;</span><br><span class="line">@for(warehouse(i) : @sum(client(j) : plan(i, j)) &lt;= capacity(i));</span><br><span class="line"></span><br><span class="line">! 约束条件2：应该刚好满足客户的订单量;</span><br><span class="line">@for(client(j) : @sum(warehouse(i) : plan(i, j)) = requirement(j));</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="例题-2"><a href="#例题-2" class="headerlink" title="例题 $2$"></a>例题 $2$</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>旅行商问题（$TSP\ Problem$）</p><p>假设有 $9$ 个城市，它们之间两两距离为：</p><center><img src = https://s1.ax1x.com/2022/08/21/vyySiD.png width = 70%></center><p>现在我们需要为旅行商设计一条路线，使得他可以经过所有的 $9$ 个城市（每个城市只经过一次），并且最终行走的总距离最少。</p><h3 id="代码和注释-1"><a href="#代码和注释-1" class="headerlink" title="代码和注释"></a>代码和注释</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">model:</span><br><span class="line"></span><br><span class="line">sets:</span><br><span class="line"></span><br><span class="line">! 定义一段路的起始城市和终点城市 ;</span><br><span class="line">cities/city1..city9/: city;</span><br><span class="line"></span><br><span class="line">! 定义两两城市之间的距离和路线 ;</span><br><span class="line">! dist(i, j) 表示城市 i 和 j;</span><br><span class="line">! route(i, j) = 1 表示环路中存在从城市 i 前往城市 j 这条路径，0 表示不存在 ;</span><br><span class="line">links(cities, cities): dist, route;</span><br><span class="line"></span><br><span class="line">endsets</span><br><span class="line"></span><br><span class="line">data:</span><br><span class="line"></span><br><span class="line">! 数据主要是需要传入两两城市之间的距离 ;</span><br><span class="line">dist = 0, 200, 660, 170, 127, 225, 490, 420, 330                            </span><br><span class="line">       200, 0, 820, 300, 90, 60, 310, 225, 151                        </span><br><span class="line">       660, 820, 0, 530, 770, 120, 1110, 1050, 960                    </span><br><span class="line">       170, 300, 530, 0, 280, 350, 600, 550, 450                </span><br><span class="line">       127, 90, 770, 280, 0, 110, 370, 310, 210            </span><br><span class="line">       225, 60, 120, 350, 110, 0, 280, 250, 120        </span><br><span class="line">       490, 310, 1110, 600, 370, 280, 0, 290, 190    </span><br><span class="line">       420, 225, 1050, 550, 310, 250, 290, 0, 160</span><br><span class="line">       330, 151, 960, 450, 210, 120, 190, 160, 0 ;</span><br><span class="line"></span><br><span class="line">enddata</span><br><span class="line"></span><br><span class="line">n = @size(cities);</span><br><span class="line"></span><br><span class="line">! 目标函数：求总路径的最小值 ;</span><br><span class="line">! 只有在 route(i, j) 不为 0 时表示这条路径存在，乘以 dist(i, j) 代表计入相应的路径长度 ;</span><br><span class="line">min = @sum(links(i, j) : dist(i, j) * route(i, j));</span><br><span class="line"></span><br><span class="line">! 变量定界：0-1 规划问题 ;</span><br><span class="line">@for(links(i, j) : @bin(route(i, j)));</span><br><span class="line"></span><br><span class="line">! 每个城市必须到过一次，即路线矩阵: </span><br><span class="line">    - 每一行的和为 1 </span><br><span class="line">    - 每一列的和也为 1 ;</span><br><span class="line"></span><br><span class="line">! 每一行的和为 1 ;</span><br><span class="line">@for(cities(j) : @sum(cities(i) : route(i,j)) = 1); ! 这里的 cities 就是一个“工具人” ，我们操作的属性并不属于这个集合，只是用它来提供索引 ;</span><br><span class="line"></span><br><span class="line">! 每一列的和为 1 ;</span><br><span class="line">@for(cities(i) : @sum(cities(j) : route(i,j)) = 1);</span><br><span class="line"></span><br><span class="line">! 确保没有子圈（city(i) 和 city(j) 实际上没有赋值，并不具有真实涵义，用来当作辅助值） ;</span><br><span class="line">@for(links(i, j) | i #ne# j #and# i #gt# 1 : city(i) - city(j) + n * route(i, j) &lt;= n - 1);</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="（八）写在后面"><a href="#（八）写在后面" class="headerlink" title="（八）写在后面"></a>（八）写在后面</h1><p><code>LINGO</code> 一直以来就以内置建模语言和优秀的建模算法著称，不少人将 <code>LINGO</code> 作为优化模型求解的不二选择，但是 <code>LINGO</code> 真的就能解决所有的优化问题吗？</p><p>很显然答案是否定的—— <code>LINGO</code> 的优势在于求解非线性规划时比较方便，只需要使用编程语言描述模型，系统就能自动地给出解。这使得使用者不必关心 <code>LINDO</code> 公司具体选择了什么算法来执行求解的过程，能将更多的心力放在模型的架构和完善上。</p><p>但是假如我们要训练一个参数规模巨大的神经网络，使用 <code>LINGO</code> 来进行参数优化求解往往就显得心有余而力不足——因为过程中消耗的时间是我们不得不考虑的因素，这时我们就应该去考虑执行效率更高的工具。</p><blockquote><p>同理对于 <code>matlab</code> 中提供的 <code>ga</code> 函数，</p></blockquote><p>学会扬长避短，根据具体情况选择合适的工具也是建模能力之一。</p><blockquote><p>参考资料：</p><p>数据输入部分：<a href="https://zhuanlan.zhihu.com/p/153127289">https://zhuanlan.zhihu.com/p/153127289</a></p><p>数学函数部分：<a href="https://www.jianshu.com/p/a39b411ec367">https://www.jianshu.com/p/a39b411ec367</a></p><p><code>LINGO</code> 建模例题：<a href="https://blog.csdn.net/Dai_sir_man/article/details/120064306">https://blog.csdn.net/Dai_sir_man/article/details/120064306</a> 和 <a href="https://blog.csdn.net/Xiao_CangTian/article/details/89506978">https://blog.csdn.net/Xiao_CangTian/article/details/89506978</a></p><p>其余部分：《<code>LINGO</code> 官方文档》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从马尔可夫链到 Page Rank 算法</title>
      <link href="/2022/08/18/c%E4%BB%8E%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E5%88%B0PageRank%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/18/c%E4%BB%8E%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E9%93%BE%E5%88%B0PageRank%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）背景介绍"><a href="#（一）背景介绍" class="headerlink" title="（一）背景介绍"></a>（一）背景介绍</h1><p>搜索技术的发展大致可以分为四个阶段，分类目录时期、文本检索时期、链接分析时期和以用户为中心的时期。链接分析时期的搜索引擎建立在文本检索的基础上，通过深入地分析网页中链接所隐含的信息，获取网页之间的“推荐关系”，通过对于链接地分析能够为用户推荐相关地网页，并进行精准地排名，极大改善了搜索质量和搜索体验。本文介绍的 $Page \ Rank$ 算法就是链接搜索领域的一个重要技术。</p><center><img src = https://s1.ax1x.com/2022/08/19/vrw9PI.png width = 50%></center><hr><h1 id="（二）知识基础"><a href="#（二）知识基础" class="headerlink" title="（二）知识基础"></a>（二）知识基础</h1><h2 id="随机游走模型"><a href="#随机游走模型" class="headerlink" title="随机游走模型"></a>随机游走模型</h2><p>给定一个含有 $n$ 个结点的有向图，在有向图上定义随机游走（$Random\ Walk$）模型：</p><p>图的每个节点结点表示一个特定的状态，有向边则用来表示状态之间的转移，假设从一个结点到通过有向边相连的所有结点的转移概率相等。</p><p>假设状态从图的节点 $i$ 转移到节点 $j$ 的概率为 $m_{ij}$ ，将 $m_{ij}$ 作为一个矩阵的第 $i$ 行第 $j$ 列上的元素，那么就能构成一个大小为 （节点个数 $\times$ 节点个数）的矩阵，它被我们定义称转移矩阵 $M$</p><p>设转移矩阵 $M$ 的节点个数是 $n$ 。事实上，根据概率基本事实即可知以下结论总是成立：</p><script type="math/tex; mode=display">    m_{1j}+m_{2_j}+m_{3j}+\cdots+m_{nj}=\sum_{i=1}^nm_{ij}=1, \; j=1,2,\cdots,n</script><p>这个模型就被称为随机游走模型，随机游走模型是马尔可夫链的基础。</p><h2 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h2><h3 id="马尔可夫链概念介绍"><a href="#马尔可夫链概念介绍" class="headerlink" title="马尔可夫链概念介绍"></a>马尔可夫链概念介绍</h3><p>马尔可夫链是一种假设某一状态转移的概率只依赖于它的前一个状态的模型。用数学语言可以表达为：</p><script type="math/tex; mode=display">    P(X^{t+1}|X^0,X^1,X^2,\cdots,X^t) = P(X^{t+1}|X^t)</script><p>其中 $X^k$ 表示经过 $k$ 次状态转移后的当前状态，上述公式描述的是：当前状态仅和上一个状态有关，和上一个状态前的任意一个状态都无关。</p><p>概括而言，马尔可夫链应该具有核心三要素</p><ul><li><p>状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换</p></li><li><p>无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响</p></li><li><p>转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  </p><blockquote><p>有向图的表示方法有邻接矩阵和邻接表，而实际上这里的转移矩阵的实质是一种带权的邻接矩阵</p></blockquote></li></ul><h3 id="马尔可夫链的稳态"><a href="#马尔可夫链的稳态" class="headerlink" title="马尔可夫链的稳态"></a>马尔可夫链的稳态</h3><p>符合上述要求的马尔可夫链都会达到一个最终稳定的状态，如果我们将初始状态整合为一个状态向量，那么，每次得到的下一个状态向量的各状态概率可以用下式表示：</p><script type="math/tex; mode=display">\begin{pmatrix}X_1^i\\X_2^i\\\vdots\\X_n^i\end{pmatrix}=\begin{pmatrix}p_{11}&p_{12}&\cdots&p_{1n}\\p_{21}&p_{22}&\cdots&p_{2n}\\\vdots&\vdots&\ddots&\vdots\\p_{n1}&p_{n2}&\cdots&p_{nn}    \end{pmatrix}^i\begin{pmatrix}X_1^0\\X_2^0\\\vdots\\X_n^0\end{pmatrix}</script><p>其中 $X_j^i$ 表示第 $j$ 个状态经过 $i$ 次迭代后得到的状态， $P_{ab}$ 表示第 $a$ 个状态转移到第 $b$ 个状态的概率。</p><p>我们可以通过一个简单的例子描述这样的模型：</p><p>小离每天选择饮料时总是进行两种选择：$A$ 或 $B$ ，在选择 $A$ 后依旧选择 $A$ 的概率为 $40\%$ ，在选择 $A$ 后选择 $B$ 的概率为 $60\%$ ，在选择 $B$ 后依旧选择 $B$ 的概率为 $50\%$，在选择 $B$ 后选择 $A$ 的概率为 $50\%$。这样我们统计小离每天的饮料选择状态，会发现小离每天的饮料选择倾向于 $B$，并且概率为 $54.5455\%$ ，趋近于某种稳态。</p><center><img src = https://s1.ax1x.com/2022/08/19/vrwSIA.png width = 34.4%><img src = https://s1.ax1x.com/2022/08/19/vrdjqe.png width = 40%></center><h3 id="马尔可夫链的数学性质"><a href="#马尔可夫链的数学性质" class="headerlink" title="马尔可夫链的数学性质"></a>马尔可夫链的数学性质</h3><p>除此之外，对于马尔可夫链，我们还可以发现这样的数学性质：如果我们经过足够多次的转移矩阵 $M$ 迭代，得到的稳态矩阵为 $R$ ，那么实际上由以下两式可知 $R$ 是转移矩阵的特征向量。</p><script type="math/tex; mode=display">RM = R\\R(M-I)=O</script><blockquote><p>在这里我们当然可以借助高等代数的知识进行长篇大论的推演（应该会非常有趣），可是如何借助这个模型来实现一些服务于现实世界的程序，才是本文的重点部分。</p></blockquote><hr><h1 id="（三）Page-Rank-算法"><a href="#（三）Page-Rank-算法" class="headerlink" title="（三）Page Rank 算法"></a>（三）Page Rank 算法</h1><h2 id="Page-Rank-的基本定义"><a href="#Page-Rank-的基本定义" class="headerlink" title="Page Rank 的基本定义"></a>Page Rank 的基本定义</h2><p>由上面对于马尔可夫链的讨论可知，对于含有 $n$ 个节点的满足马尔可夫性质的有向图，我们在图上定义一个随机游走模型。</p><p>对于随机游走模型而言，从图上一个节点转移到与该节点连通的任何一个节点的概率相等。</p><blockquote><p>你可能有点疑惑为什么就认为 “从图上一个节点转移到与该节点连通的任何一个节点的概率相等”。这实际上是一个默认的设定，我们也可以基于显示因素定量或定性地修正这些概率的值</p></blockquote><p>而在 $Page Rank$ 模型中，我们设定每个节点都代表一个网页，节点之间的有向边就代表网页之间的链接关系：这样，网页群就被我们抽象成一张有向图。</p><p>根据这样的结果，我们不难直接定义出转移矩阵 $M$ ，可以证明，这种情况下，马尔可夫链也是具有最终平稳分布 $R$ 的。这样，只要得到最后的平稳分布，并且将平稳分布进行模长化（满足概率和为 $1$ 的分布要求），我们规定 $p(v_i)$ 为最终稳态分布中节点为 $v_i$ 的网页的“被访问概率”</p><script type="math/tex; mode=display">RM=R\ ;\qquadR=\begin{pmatrix}p(v_1)\\p(v_2)\\\vdots\\p(v_n)\end{pmatrix}\ ;\qquad\sum_{i=1}^np(v_i)=1\ ;</script><p>这是Page Rank中的基础模型，现实场景下，为了模拟复杂的情况，我们还需要对Page Rank模型进一步修正。</p><h2 id="Page-Rank-算法模型"><a href="#Page-Rank-算法模型" class="headerlink" title="Page Rank 算法模型"></a>Page Rank 算法模型</h2><p>为更加清晰地解释下文的内容，我们利用一个简单的网站链接模型作为例子。</p><p>如图，有五个网站，它们之间的链接关系如图所示</p><center><img src = https://s1.ax1x.com/2022/08/19/vrdxVH.png width = 30%></center><p>我们定义一个转移矩阵来描述网页之间的链接关系和概率</p><script type="math/tex; mode=display">\begin{pmatrix}1&\frac{1}{3}&0&0&0\\0&0&\frac{1}{2}&0&0\\0&\frac{1}{3}&0&1&1\\0&\frac{1}{3}&\frac{1}{2}&0&0\\0&0&0&0&0    \end{pmatrix}</script><blockquote><p>再强调一下：这个矩阵的第 $i$ 行第 $j$ 列元素表示从网页 $i$ 转移到网页 $j$ 的概率</p></blockquote><h3 id="规避转移到一个网站后无法继续转移的情况"><a href="#规避转移到一个网站后无法继续转移的情况" class="headerlink" title="规避转移到一个网站后无法继续转移的情况"></a>规避转移到一个网站后无法继续转移的情况</h3><p>如果进入到一个网站中，该网站不具有到任何其它网站的链接，那么一旦陷入这样的状态就会被当前页面局限而不再发生转移，这显然不是我们希望的状态。</p><p>这种情况在转换矩阵中体现为：一列中只有对角线元素为 $1$ 而其它元素为 $0$ 。</p><p>因此我们可以将这种不具备链接的网站近似成具备到所有其它网站的等效链接，即对矩阵的相关维的分量进行修正。</p><p>如假设一个页面转移矩阵的第一维分量为 $(1\quad0\quad0)$ ，则可以修正为 $(0.33\quad0.33\quad0.33)$ 。</p><p>同理，我们刚刚定义的转换矩阵应该修改为：</p><script type="math/tex; mode=display">\begin{pmatrix}\frac{1}{5}&\frac{1}{3}&0&0&0\\\frac{1}{5}&0&\frac{1}{2}&0&0\\\frac{1}{5}&\frac{1}{3}&0&1&1\\\frac{1}{5}&\frac{1}{3}&\frac{1}{2}&0&0\\\frac{1}{5}&0&0&0&0    \end{pmatrix}</script><h3 id="阻尼系数的引入"><a href="#阻尼系数的引入" class="headerlink" title="阻尼系数的引入"></a>阻尼系数的引入</h3><p>用户在点击进入网站时，除了使用通过链接到达其它相关的网站，还有另一种选择——就是直接通过引擎转到当前网页未链接的网站，这种情况在我们之前的模型中是一直缺乏考虑的。</p><p>我们引入一个“阻尼系数” $d$ ，将它定义为用户通过链接跳转的概率，那么 $1-d$ 就是用户直接通过搜索引擎跳转的概率，我们规定用户通过非链接方式前往各个网站的概率相等，那么新的转换矩阵 $S$ 应该满足下面的公式</p><script type="math/tex; mode=display">S = dM+(1-d)\frac{K}{n}</script><p>其中，$K$ 表示形状为（网页数$\times$网页数）且每个元素都是 $1$ 的矩阵。Google 的工程师统计得到 $d$ 取 $0.85$ 时效果最优。</p><p>下面展示了添加阻尼系数后的可视化数据：</p><center><img src = https://s1.ax1x.com/2022/08/19/vrdzad.png width = 45%></center><hr><h1 id="（四）Python-代码和-MATLAB-代码"><a href="#（四）Python-代码和-MATLAB-代码" class="headerlink" title="（四）Python 代码和 MATLAB 代码"></a>（四）Python 代码和 MATLAB 代码</h1><p>提供了两个版本的 $Page\ Rank$ 代码</p><blockquote><p>本文代码已经发布到 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/Markov%E9%93%BE%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95">我的 GitHub 仓库</a>（点击跳转），可以直接前往下载。</p></blockquote><h2 id="MATLAB-版本"><a href="#MATLAB-版本" class="headerlink" title="MATLAB 版本"></a>MATLAB 版本</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function outrank <span class="built_in">=</span> pagerank(n, times, tran_mat)</span><br><span class="line">    <span class="comment">% n 是网页的个数</span></span><br><span class="line">    <span class="comment">% times 表示迭代次数，次数越大，精度越高</span></span><br><span class="line">    <span class="comment">% tran_mat 表示转移矩阵</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 设置阻尼</span></span><br><span class="line">    d <span class="built_in">=</span> <span class="number">0.85</span>;</span><br><span class="line">    bias <span class="built_in">=</span> ones(n, n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">            tran_mat <span class="built_in">=</span> d * tran_mat + (<span class="number">1</span> - d) * bias / n;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 矩阵乘法</span></span><br><span class="line"></span><br><span class="line">    value <span class="built_in">=</span> zeros(n, times);</span><br><span class="line">   </span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        value(i,<span class="number">1</span>) <span class="built_in">=</span> <span class="number">1</span> / n;</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">2</span> : times + <span class="number">1</span></span><br><span class="line">       value(:, i) <span class="built_in">=</span> tran_mat * value(:, i - <span class="number">1</span>); </span><br><span class="line">    end</span><br><span class="line">    </span><br><span class="line">    <span class="comment">%% 作图</span></span><br><span class="line">    curtime <span class="built_in">=</span> <span class="number">0</span> : <span class="number">1</span> : times;</span><br><span class="line">    colorGap <span class="built_in">=</span> fix(<span class="number">255</span>/n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        plot(curtime,value(i, :),<span class="string">&#x27;-&#x27;</span>,<span class="string">&#x27;Color&#x27;</span>, [i*colorGap/<span class="number">255</span>, <span class="number">127</span>/<span class="number">255</span>, (<span class="number">255</span> - i*colorGap)/<span class="number">255</span>]);</span><br><span class="line">        hold on;</span><br><span class="line">    end</span><br><span class="line">    xlabel(<span class="string">&quot;迭代次数&quot;</span>);</span><br><span class="line">    ylabel(<span class="string">&quot;状态值&quot;</span>);</span><br><span class="line">    legend(<span class="string">&quot;page1&quot;</span>,<span class="string">&quot;page2&quot;</span>,<span class="string">&quot;page3&quot;</span>,<span class="string">&quot;page4&quot;</span>,<span class="string">&quot;page5&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">%% 归一化并返回最终结果</span></span><br><span class="line">    outrank <span class="built_in">=</span> zeros(n);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : n</span><br><span class="line">        outrank(i) <span class="built_in">=</span> value(i, times + <span class="number">1</span>)/sum(value(:,times + <span class="number">1</span>));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="Python-版本"><a href="#Python-版本" class="headerlink" title="Python 版本"></a>Python 版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">sns.set_style(<span class="string">&#x27;darkgrid&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设有A，B，C，D，E五个网站</span></span><br><span class="line">n = <span class="number">5</span></span><br><span class="line">transfer_matrix = np.array(</span><br><span class="line">    [[<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>], [<span class="number">0.333</span>, <span class="number">0</span>, <span class="number">0.333</span>, <span class="number">0.333</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>, <span class="number">0.5</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=<span class="string">&#x27;float32&#x27;</span>)</span><br><span class="line">start_matrix = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=<span class="string">&#x27;float32&#x27;</span>)  <span class="comment"># 从A页面开始浏览</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置阻尼系数并利用阻尼系数对转换矩阵进行修正</span></span><br><span class="line">d = <span class="number">0.85</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        transfer_matrix[i][j] *= d</span><br><span class="line">        transfer_matrix[i][j] += (<span class="number">1</span> - d) * (<span class="number">1</span> / n)</span><br><span class="line"></span><br><span class="line">value1 = []</span><br><span class="line">value2 = []</span><br><span class="line">value3 = []</span><br><span class="line">value4 = []</span><br><span class="line">value5 = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    start_matrix = np.dot(start_matrix, transfer_matrix)</span><br><span class="line">    value1.append(start_matrix[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">    value2.append(start_matrix[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">    value3.append(start_matrix[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">    value4.append(start_matrix[<span class="number">0</span>][<span class="number">3</span>])</span><br><span class="line">    value5.append(start_matrix[<span class="number">0</span>][<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行可视化</span></span><br><span class="line">x = np.arange(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, value1, label=<span class="string">&#x27;Apage&#x27;</span>)</span><br><span class="line">plt.plot(x, value2, label=<span class="string">&#x27;Bpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value3, label=<span class="string">&#x27;Cpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value4, label=<span class="string">&#x27;Dpage&#x27;</span>)</span><br><span class="line">plt.plot(x, value5, label=<span class="string">&#x27;Epage&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><hr><h1 id="（五）一点补充"><a href="#（五）一点补充" class="headerlink" title="（五）一点补充"></a>（五）一点补充</h1><p>我们稍微回顾一下最开头提出的马尔可夫链模型成立的三个条件</p><ul><li><p>状态空间（$State\ Space$）：状态能且只能在若干个状态间进行转换</p></li><li><p>无记忆性（$Memorylessness$）：当期选择的概率只受到上期状态的影响</p></li><li><p>转移矩阵（$Transition\ Matrix$）： 我们可以使用一个矩阵来描述一个状态转移到所有状态（包括自身状态）的概率，如果不存在转移到某状态的路径，则直接用 $0$ 表示其概率。  </p></li></ul><p>稍加辨析我们很容易发现现实生活中的网页链接模型事实上并不完全符合马尔科夫链的模型要求：</p><p>状态空间上，网页只能在若干网页之间进行链接跳转事实上并不完全符合现实生活中的情况，用户随时有可能做出我们规定了网页群外的其他网页选择。并且还有一些极端情况：某些网页甚至没有跳转到其他网页的链接。</p><p>无记忆性上，用户的若干连续网页跳转之间可能满足一定的逻辑规律，认为当期选择的概率只受上期状态的影响似乎也不完全符合现实。</p><p>转移矩阵上，我们似乎会发现一个不变的矩阵很难满足我们当前的需求：用户在浏览的过程中很有可能对他们的转移矩阵做出一定的更新。</p><p>然而，当我们考虑所有这些复杂的现实因素时，我们会发现建模成为了一件似乎不可能的事，拟和现实生活中的一切因素听起来很酷，却会使我们的建模成为一件混乱而复杂的事，不妨看看 $Page\ Rank$ 模型是怎么处理这些问题的：</p><ul><li><p>忽略网页群外的其他网页选择，将状态空间严格控制在一定的范围内，对于无法跳转到其他网页的链接，直接默认为拥有跳转到所有网页群内的网页的链接。</p></li><li><p>忽略用户连续网页跳转之间的规律，认为用户上一次浏览的网页对于接下来要浏览哪个网页而言具有绝对权重。</p></li><li><p>忽略用户在浏览过程中的一些情况导致的转移矩阵更新，因为不恒定的转移矩阵很有可能使马尔科夫链无法得到一个收敛的结果。</p></li></ul><p>因此，建模既是对现实世界的拟合，也是对现实世界的忽略——抽象必然伴随着忽略。事实也证明，先通过忽略的方式得到抽象的模型，然后在这基础上不断对模型进行基于现实的修正和更改，才是最佳的建模方法。</p>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性与非线性规划（一）</title>
      <link href="/2022/08/18/c%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%80/"/>
      <url>/2022/08/18/c%E7%BA%BF%E6%80%A7%E4%B8%8E%E9%9D%9E%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）知识基础"><a href="#（一）知识基础" class="headerlink" title="（一）知识基础"></a>（一）知识基础</h1><h2 id="规划问题定义"><a href="#规划问题定义" class="headerlink" title="规划问题定义"></a>规划问题定义</h2><ul><li>线性规划：在一组线性约束条件的限制下，求一线性目标函数最大或者最小的问题。</li></ul><blockquote><p>线性意味着所有变量都是一次方的</p></blockquote><ul><li>非线性规划：在一组非线性约束条件（也可以包含线性条件）的限制下，求一线性目标函数最大或者最小的问题。</li></ul><blockquote><p>“也可以包含线性条件”是指非线性规划的约束条件可以是线性和非线性混合的</p></blockquote><h2 id="规划问题关键要素"><a href="#规划问题关键要素" class="headerlink" title="规划问题关键要素"></a>规划问题关键要素</h2><ul><li><p>决策变量：决策中待决定的自变量</p></li><li><p>目标函数：取决于决策变量的函数</p></li><li><p>约束条件：决策变量应该符合的基本条件</p></li></ul><h2 id="规划类优化问题类型"><a href="#规划类优化问题类型" class="headerlink" title="规划类优化问题类型"></a>规划类优化问题类型</h2><ul><li>连续优化<ul><li>线性规划问题（$LP$）：目标和约束函数为线性函数</li><li>非线性规划（$NLP$）：目标或约束中存在非线性函数</li><li>二次规划（$QP$）：目标为二次函数，约束为线性函数</li></ul></li><li>离散优化<ul><li>整数线性规划（$ILP$）：决策变量（部分或全部）为整数的线性规划问题</li><li>整数非线性规划（$INLP$）：决策变量（部分或全部）为整数的非线性规划问题</li><li>$0$-$1$ 规划（$ZOP$）：决策变量为 $0$ 或 $1$ 的规划问题</li></ul></li></ul><h1 id="（二）单目标线性规划"><a href="#（二）单目标线性规划" class="headerlink" title="（二）单目标线性规划"></a>（二）单目标线性规划</h1><h2 id="linprog-函数"><a href="#linprog-函数" class="headerlink" title="linprog 函数"></a>linprog 函数</h2><h3 id="函数模型"><a href="#函数模型" class="headerlink" title="函数模型"></a>函数模型</h3><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tar_x, tar_value] <span class="built_in">=</span> linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li><p><code>tar_fun</code> 表示目标函数</p></li><li><p><code>A</code> 表示不等式约束条件系数矩阵</p></li><li><p><code>b</code> 表示不等式约束条件常数矩阵</p></li><li><p><code>Aeq</code> 表示等式约束条件系数矩阵</p></li><li><p><code>beq</code> 表示等式约束条件常数矩阵</p></li><li><p><code>lb</code> 表示决策变量的下限数组</p></li><li><p><code>ub</code>表示决策变量的上限数组</p></li></ul><blockquote><p>由于 <code>tar_fun</code> 是线性函数，那么直接代入它的系数数组即可（按顺序对应变量）</p><p>对于不存在的约束，在 <code>MATLAB</code> 中可以直接用空矩阵 <code>[]</code> 代替</p></blockquote><p>返回值解释</p><ul><li><p><code>tar_x</code> 表示目标函数 <code>tar_fun</code> 取得最小值时的决策变量取值数组</p></li><li><p><code>tar_value</code> 表示目标函数 <code>tar_fun</code> 取得的最小值</p></li></ul><blockquote><p>对于要求最大值的情形，取相反数作为目标函数代入即可</p></blockquote><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>设有线性规划问题如下：</p><p>不等式约束条件为：</p><script type="math/tex; mode=display">x_1+x_2\le2</script><script type="math/tex; mode=display">x_1+\frac{x_2}{4}\le1</script><script type="math/tex; mode=display">x_1-x_2\le2</script><script type="math/tex; mode=display">-\frac{x_1}{4}-x_2\le1</script><script type="math/tex; mode=display">-x_1-x_2\le-1</script><script type="math/tex; mode=display">-x_1+x_2\le2</script><p>等式约束条件为：</p><script type="math/tex; mode=display">x_1 + \frac{x_2}{4} = \frac{1}{2}</script><p>决策变量上下界为：</p><script type="math/tex; mode=display">-1\le x_1\le1.5</script><script type="math/tex; mode=display">-0.5\le x_2\le1.25</script><p>目标函数是：</p><script type="math/tex; mode=display">-x_1-\frac{x_2}{3}</script><p>将不等式和等式约束条件写成矩阵的形式：</p><script type="math/tex; mode=display">\begin{pmatrix}1&1\\1&\frac{1}{4}\\1&-1\\-\frac{1}{4}&-1\\-1&-1\\-1&1\end{pmatrix}\begin{pmatrix}x_1\\x_2   \end{pmatrix}\le\begin{pmatrix}2\\1\\2\\1\\-1\\2    \end{pmatrix}</script><script type="math/tex; mode=display">\begin{pmatrix}1&\frac{1}{4}\end{pmatrix}\begin{pmatrix}x_1\\x_2    \end{pmatrix}=\frac{1}{2}</script><p>调用函数解决：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar_fun <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">1</span>/<span class="number">3</span>]; <span class="comment">% 目标函数</span></span><br><span class="line">A <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span> ; <span class="number">1</span> <span class="number">1</span>/<span class="number">4</span> ; <span class="number">1</span> -<span class="number">1</span> ; -<span class="number">1</span>/<span class="number">4</span> -<span class="number">1</span> ; -<span class="number">1</span> -<span class="number">1</span> ; -<span class="number">1</span> <span class="number">1</span> ];</span><br><span class="line">b <span class="built_in">=</span> [<span class="number">2</span> ; <span class="number">1</span> ; <span class="number">2</span> ; <span class="number">1</span> ; -<span class="number">1</span> ; <span class="number">2</span>];</span><br><span class="line">Aeq <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span>/<span class="number">4</span>];</span><br><span class="line">beq <span class="built_in">=</span> [<span class="number">1</span>/<span class="number">2</span>];</span><br><span class="line">lb <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">0.5</span>];</span><br><span class="line">ub <span class="built_in">=</span> [<span class="number">1.5</span> <span class="number">1.25</span>];</span><br><span class="line"></span><br><span class="line">[tar_x, tar_value] <span class="built_in">=</span> linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>如果成功调用并且结果正确，会在命令行区显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [tar_x, tar_value] = linprog(tar_fun, A, b, Aeq, beq ,lb, ub);</span><br><span class="line"></span><br><span class="line">Optimal solution found.</span><br></pre></td></tr></table></figure><h2 id="intlinplog-函数"><a href="#intlinplog-函数" class="headerlink" title="intlinplog 函数"></a>intlinplog 函数</h2><p><code>intlinplog</code> 函数主要用于处理整数线性规划问题。</p><p>和 <code>linplog</code> 使用方法基本一致，唯一的不同是：<code>intlinplog</code> 函数在参数列表的第一个参数后插入了一个类型为数组的参数：<code>intcon</code>，这个参数数组的涵义是指明决策变量数组中的第几个变量为整数变量</p><p>比如 <code>intcon = [1, 5]</code> 表示决策变量中 $x_1$ 和 $x_5$ 是整数变量</p><p>假设上面的例子中第二个变量即 $x_2$ 是整数变量，那么调用函数应该这样修改：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">intcon <span class="built_in">=</span> [<span class="number">2</span>];</span><br><span class="line">[tar_x, tar_value] <span class="built_in">=</span> intlinprog(tar_fun, intcon, A, b, Aeq, beq ,lb, ub);</span><br></pre></td></tr></table></figure><p>调用这个函数会给出以下提醒：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; [tar_x, tar_value] = intlinprog(tar_fun, intcon, A, b, Aeq, beq ,lb, ub);</span><br><span class="line"></span><br><span class="line">LP:                Optimal objective value is -0.583333.                                            </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimal solution found.</span><br><span class="line"></span><br><span class="line">Intlinprog stopped at the root node because the objective value is within a gap tolerance of the</span><br><span class="line">optimal value, options.AbsoluteGapTolerance = 0 (the default value). The intcon variables are</span><br><span class="line">integer within tolerance, options.IntegerTolerance = 1e-05 (the default value).</span><br></pre></td></tr></table></figure><p>请不要惊慌——这不是报错，它表示：这个解法得到的结果可能实际上不一定是一个整数，但是它已经尽可能地进行精确，并且当前的误差为 <code>1e-05</code> 即 $0.00001$（你也可以将这个误差允许值设置得更小），它已经在这个误差内得到了结果。</p><h1 id="（三）单目标非线性规划"><a href="#（三）单目标非线性规划" class="headerlink" title="（三）单目标非线性规划"></a>（三）单目标非线性规划</h1><h2 id="使用-LINGO-进行优化（推荐）"><a href="#使用-LINGO-进行优化（推荐）" class="headerlink" title="使用 LINGO 进行优化（推荐）"></a>使用 <code>LINGO</code> 进行优化（推荐）</h2><p><code>LINGO</code> 是一款专门用于解决规划类问题的软件。在处理线性规划问题上，和 <code>MATLAB</code> 相比，<code>LINGO</code> 更具有优势：</p><ul><li>可以支持二维决策变量</li><li>求解 <code>NLP</code> 问题时不需要进行初值估计</li><li>使用集合命令，更加直观，方便描述复杂条件</li><li>不需要人为指定算法，减少了理解算法的过程</li></ul><p>请移步 <a href="https://www.lixinbook.cn/2022/08/18/LINGO%E6%8C%87%E5%8D%97/"><code>LINGO</code> 入门教程</a> </p><h2 id="调用-MATLAB-的-fmincon-函数进行优化"><a href="#调用-MATLAB-的-fmincon-函数进行优化" class="headerlink" title="调用 MATLAB 的 fmincon 函数进行优化"></a>调用 <code>MATLAB</code> 的 <code>fmincon</code> 函数进行优化</h2><p><code>MATLAB</code> 的 <code>fmincon</code> 函数也是进行非线性规划的函数。</p><p>但是由于该函数的内置算法可能会收敛到局部极小值，因此初值的选取可能会对结果造成影响。</p><center><img src = https://pic4.zhimg.com/80/v2-c8c7afc6069d1325a54817d62ba7e5b8.png width = 50%></center><h3 id="函数模型-1"><a href="#函数模型-1" class="headerlink" title="函数模型"></a>函数模型</h3><p>调用形式如下：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tar_x, tar_value] <span class="built_in">=</span> fmincon(tar_fun, x0, A, b, Aeq, beq ,lb, ub, nonlcon, options);</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li><p><code>tar_fun</code> 表示目标函数，由自己编写</p><blockquote><p>非线性函数的 <code>tar_fun</code> 已经不能再使用数组进行描述（这种方法只适用于线性函数描述）</p><p>有两个方法可以解决这个问题，一是定义为匿名函数（见使用示例），二是在同一文件夹下定义函数文件（见使用示例），两个方法都需要使用 <code>@</code> 进行传参</p><p><code>@</code> 其实是 <code>MATLAB</code> 中的一种称为函数句柄的语法，实质类似于面向对象语言的函数对象</p></blockquote></li><li><p><code>x0</code> 表示决策变量搜索的起点数组</p><blockquote><p>增添了 <code>x0</code> 参数，是因为 <code>fmincon</code> 采用的梯度下降方法可能会陷入局部最优，所以一定程度上依赖于初值的选取</p></blockquote></li><li><p><code>A</code> 表示不等式约束条件系数矩阵</p></li><li><p><code>b</code> 表示不等式约束条件常数矩阵</p></li><li><p><code>Aeq</code> 表示等式约束条件系数矩阵</p></li><li><p><code>beq</code> 表示等式约束条件常数矩阵</p></li><li><p><code>lb</code> 表示决策变量的下限数组</p></li><li><p><code>ub</code>表示决策变量的上限数组</p></li><li><p><code>nonlcon</code> 表示非线性约束，也由自己编写</p><blockquote><p>该变量需要 <code>@</code> 一个以决策变量数组 <code>x</code> 为输入，以<strong>标准化形式后</strong>的两个非线性代数式数组为输出的函数，详见使用示例</p></blockquote></li><li><p><code>options</code> 表示函数的设置选项，该参数可选</p><blockquote><p><code>fmincon</code> 里面涉及到诸多内置算法的选择，但一般情况下我们不会修改 <code>options</code></p><p>修改参数可以参见该<a href="https://ww2.mathworks.cn/help/optim/ug/fmincon.html#busog7r-options">网站</a> ，了解内置算法可以参见该<a href="https://ww2.mathworks.cn/help/optim/ug/constrained-nonlinear-optimization-algorithms.html#brnpd5f">网站</a> ，点击跳转</p></blockquote></li></ul><p>返回值解释</p><ul><li><p><code>tar_x</code> 表示目标函数 <code>tar_fun</code> 取得最小值时的决策变量取值数组</p></li><li><p><code>tar_value</code> 表示目标函数 <code>tar_fun</code> 取得的最小值</p></li></ul><p>此外还可以用下面的语法接收更多的返回值：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, fval, exitflag, output] <span class="built_in">=</span> fmincon(tar_fun, x0, A, b, Aeq, beq ,lb, ub, nonlcon)</span><br></pre></td></tr></table></figure><ul><li><code>exitflag</code> 表示 <code>fmincon</code> 退出条件</li><li><code>output</code> 表示优化过程信息结构体</li></ul><blockquote><p>该部分参见<a href="https://ww2.mathworks.cn/help/optim/ug/fmincon.html">官方文档（点击跳转）</a> ，如果觉得当前内容不够详细，可以访问官网获取更详尽的内容</p></blockquote><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><p>假设我们要求解一个多元单目标非线性规划，如下：</p><script type="math/tex; mode=display">tar\_fun =  e^{sin (x_1^3 + cos x_2)} - log_3(e^{x_3}+sin(x_4cos{x_5}))</script><p>线性约束条件为</p><script type="math/tex; mode=display">x_1 + x_2 = 0</script><script type="math/tex; mode=display">x_3 \ge 0</script><script type="math/tex; mode=display">x_1 + x_3 \le 30</script><script type="math/tex; mode=display">x_2 + x_3 + 2x_4 \ge 0</script><p>非线性约束为</p><script type="math/tex; mode=display">e^{sin(x_1)} - 2 e^{cos(2x_5)} = 0</script><script type="math/tex; mode=display">x_2^2-x_3^3+x_4^2\le2</script><p>所有变量的上下界条件为 $[-50,50]$</p><ul><li>第一步：编写目标函数文件</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 目标函数文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% value 是一个值，即我们优化的目标</span></span><br><span class="line"><span class="comment">% x 是决策变量数组，在本题中一共由五个变量构成</span></span><br><span class="line">function value <span class="built_in">=</span> tar_fun(x)</span><br><span class="line">    value <span class="built_in">=</span> exp(sin(x(<span class="number">1</span>) ^ <span class="number">3</span> + cos(x(<span class="number">2</span>)))) - log(exp(x(<span class="number">3</span>)) + sin(x(<span class="number">4</span>) * cos(x(<span class="number">5</span>))) / log(<span class="number">3</span>));</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>第二步：编写非线性约束文件</li></ul><p>非线性函数返回的应该是两个数组，第一个数组为 <code>c(x)</code>，即由 <code>x</code> 处的非线性不等式约束组成的数组；第二个数组为 <code>ceq(x)</code>，即由 <code>x</code> 处的线性不等式约束组成的数组。</p><p>比如上面的例子，我们编写的非线性约束文件应该是：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% c(x) 是由 x 处的非线性不等式约束组成的数组</span></span><br><span class="line"><span class="comment">% ceq(x) 是由 x 处的线性不等式约束组成的数组</span></span><br><span class="line">function [c, ceq] <span class="built_in">=</span> nonlcon(x)</span><br><span class="line">    c <span class="built_in">=</span> x(<span class="number">2</span>) ^ <span class="number">2</span> - x(<span class="number">3</span>) ^ <span class="number">3</span> + x(<span class="number">4</span>) ^ <span class="number">2</span> - <span class="number">2</span>;        <span class="comment">% 不等式条件</span></span><br><span class="line">    ceq <span class="built_in">=</span> exp(sin(x(<span class="number">1</span>))) - <span class="number">2</span> * exp(cos(<span class="number">2</span> * x(<span class="number">5</span>))); <span class="comment">% 等式条件</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>注意：对于非线性不等式，约束的形式应该满足 <code>c(x) &lt;= 0</code>，如果不满足这一条件应该进行移项</p></blockquote><ul><li>第三步：编写主文件</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A <span class="built_in">=</span> [<span class="number">0</span> <span class="number">0</span> -<span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>; <span class="number">0</span> -<span class="number">1</span> -<span class="number">1</span> -<span class="number">2</span> <span class="number">0</span>]; <span class="comment">% 线性不等式约束系数矩阵</span></span><br><span class="line">b <span class="built_in">=</span> [<span class="number">0</span> <span class="number">30</span> <span class="number">0</span>];                              <span class="comment">% 线性不等式约束常数矩阵</span></span><br><span class="line">Aeq <span class="built_in">=</span> [<span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];                         <span class="comment">% 线性等式约束系数矩阵</span></span><br><span class="line">beq <span class="built_in">=</span> [<span class="number">0</span>];                                 <span class="comment">% 线性等式约束常数矩阵</span></span><br><span class="line">x0 <span class="built_in">=</span> [<span class="number">2</span> -<span class="number">2</span> <span class="number">3</span> <span class="number">1</span> <span class="number">1</span>];                         <span class="comment">% 初始条件                     </span></span><br><span class="line">lb <span class="built_in">=</span> [-<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span> -<span class="number">50</span>];                <span class="comment">% 下界</span></span><br><span class="line">ub <span class="built_in">=</span> [<span class="number">50</span> <span class="number">50</span> <span class="number">50</span> <span class="number">50</span> <span class="number">50</span>];                     <span class="comment">% 下界</span></span><br><span class="line">MaxValue <span class="built_in">=</span> <span class="number">10</span>e99;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 提高计算次数上限</span></span><br><span class="line">options <span class="built_in">=</span> optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Display&#x27;</span>,<span class="string">&#x27;iter&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>, <span class="string">&#x27;MaxFunctionEvaluations&#x27;</span>,MaxValue);</span><br><span class="line"></span><br><span class="line">[tar_x, tar_val] <span class="built_in">=</span> fmincon(@tar_fun, x0, A, b, Aeq, beq ,[], [], @nonlcon, options); <span class="comment">% 调用 fmincon 函数</span></span><br></pre></td></tr></table></figure><blockquote><p>这个函数能跑，but 由于模型过于复杂跑不出来，不想改了.jpg，此处只是向大家展示一下正确语法（上述代码语法完全正确）</p></blockquote><h2 id="调用-MATLAB-的全局优化算法进行优化"><a href="#调用-MATLAB-的全局优化算法进行优化" class="headerlink" title="调用 MATLAB 的全局优化算法进行优化"></a>调用 <code>MATLAB</code> 的全局优化算法进行优化</h2><p>MATLAB的全局优化工具箱提供了一些不错的全局优化算法，这个是它们的<a href="https://ww2.mathworks.cn/products/global-optimization.html#global-search-multistart">文档（点击跳转）</a></p><h3 id="一些函数如下"><a href="#一些函数如下" class="headerlink" title="一些函数如下"></a>一些函数如下</h3><h4 id="多点搜索（GlobalSearch-amp-MultiStart）"><a href="#多点搜索（GlobalSearch-amp-MultiStart）" class="headerlink" title="多点搜索（GlobalSearch &amp; MultiStart）"></a>多点搜索（<code>GlobalSearch</code> &amp; <code>MultiStart</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="替代优化（surrogateopt）"><a href="#替代优化（surrogateopt）" class="headerlink" title="替代优化（surrogateopt）"></a>替代优化（<code>surrogateopt</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="模式搜索（patternsearch）"><a href="#模式搜索（patternsearch）" class="headerlink" title="模式搜索（patternsearch）"></a>模式搜索（<code>patternsearch</code>）</h4><p>在《优化算法补充》中介绍</p><h4 id="遗传算法（ga）"><a href="#遗传算法（ga）" class="headerlink" title="遗传算法（ga）"></a>遗传算法（<code>ga</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="粒子群算法（particleswarm）"><a href="#粒子群算法（particleswarm）" class="headerlink" title="粒子群算法（particleswarm）"></a>粒子群算法（<code>particleswarm</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="模拟退火（simulannealbnd）"><a href="#模拟退火（simulannealbnd）" class="headerlink" title="模拟退火（simulannealbnd）"></a>模拟退火（<code>simulannealbnd</code>）</h4><p>在《现代优化算法》中介绍</p><h4 id="多目标规划（gamultiobj-amp-paretosearch）"><a href="#多目标规划（gamultiobj-amp-paretosearch）" class="headerlink" title="多目标规划（gamultiobj &amp; paretosearch）"></a>多目标规划（<code>gamultiobj</code> &amp; <code>paretosearch</code>）</h4><p>在《线性和非线性规划（二）》中介绍</p><blockquote><p>备注：《线性和非线性规划（二）》、《优化算法补充》和《现代优化算法》都是本系列的内容，后续更新</p><p>《线性和非线性规划（二）》介绍多目标规划</p><p>《优化算法补充》介绍多点搜索（<code>GlobalSearch</code> &amp; <code>MultiStart</code>）、替代优化（<code>surrogateopt</code>）和模式搜索（<code>patternsearch</code>）</p><p>《现代优化算法》主要介绍一些启发式算法，比如遗传算法（<code>ga</code>）、粒子群算法（<code>particleswarm</code>）和模拟退火（<code>simulannealbnd</code>），也会增加一些其它内容</p><p>敬请期待！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锻炼左右脑协调的贪吃蛇游戏——《Double Snakes》完整 C 语言代码！</title>
      <link href="/2022/08/18/cdoublesnake/"/>
      <url>/2022/08/18/cdoublesnake/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）运行效果"><a href="#（一）运行效果" class="headerlink" title="（一）运行效果"></a>（一）运行效果</h1><ul><li>游戏开始</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunAA0.png width = 60%></p><ul><li>游戏进行</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunF7q.png width = 40%></p><ul><li>游戏结束</li></ul><p><img src = https://s1.ax1x.com/2022/08/06/vunENV.png width = 40%></p><h1 id="（二）README"><a href="#（二）README" class="headerlink" title="（二）README"></a>（二）README</h1><ul><li><p>本游戏玩法和贪吃蛇一致，可以双人 PK ，也可以单人操纵两蛇（推荐），锻炼大脑能力</p></li><li><p>代码面向新手，提供了非常详细的注释，语言平易近人，没有参杂过多“高端操作”，可以作为初学 C 语言的尝试项目（其实我也是初学hhh）</p></li><li><p>欢迎交流代码内容，发现不足，一起进步！</p></li><li><p>这个代码适用于 Windows 环境，如果使用 Mac 环境或 Linux 环境可能需要修改个别代码</p></li><li><p>可以使用 <code>DEV-C++</code> 直接编译运行，如果使用 <code>vscode</code> 编译运行需要将编码格式修改为 <code>Simplified Chinese(GBK)</code> ，用来识别特殊符号。此外无需安装其它库。</p></li></ul><ul><li>转发使用请注明出处，谢谢！</li></ul><h1 id="（三）一些随笔"><a href="#（三）一些随笔" class="headerlink" title="（三）一些随笔"></a>（三）一些随笔</h1><ul><li><p>使用 C 语言 <code>struct</code> 来构造程序，<code>struct</code> 在某些层面和 C++ 的 class 有某些相似性</p></li><li><p>防闪烁方法主要通过调用系统 API ，移动光标在特定位置进行输出实现，效果可观</p></li></ul><h1 id="（四）挖一些坑"><a href="#（四）挖一些坑" class="headerlink" title="（四）挖一些坑"></a>（四）挖一些坑</h1><ul><li><p>后续可能会出一版零基础 C 语言教程：从安装编程软件到写出《double snake》游戏的 3 天速成教程，目的在于采用碎片化叙述知识和任务导引的方式，帮助初学者建立起对于一门语言的“感觉”，不至于一开始就陷入系统冗杂的教材体系。</p></li><li><p>会在《Double Snakes》的基础上开发《Multiple Snakes》，并基于此用 C 语言手敲一遍遗传算法，帮助刚开始学计算机的同学从底层直接感受和理解算法</p></li></ul><h1 id="（五）完整代码"><a href="#（五）完整代码" class="headerlink" title="（五）完整代码"></a>（五）完整代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********************头文件和预定义*********************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LENGTH 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> h_length 60</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> v_length 50</span></span><br><span class="line"><span class="comment">// 小键盘键位</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UP 72    <span class="comment">//方向键：上</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DOWN 80  <span class="comment">//方向键：下</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT 75  <span class="comment">//方向键：左</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT 77 <span class="comment">//方向键：右</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE 32 <span class="comment">//暂停</span></span></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************自定义 struct 类型和 enum 类型*********************/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Move_Direction</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    up,</span><br><span class="line">    down,</span><br><span class="line">    left,</span><br><span class="line">    right</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Items</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    nothing, <span class="comment">// 空白（表示什么都没有）</span></span><br><span class="line">    wall,</span><br><span class="line">    snakebody0,</span><br><span class="line">    snakebody1,</span><br><span class="line">    snakehead0,</span><br><span class="line">    snakehead1,</span><br><span class="line">    food</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;                             <span class="comment">// id = 0 表示 0 号蛇，id = 1 表示 1 号蛇</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">4</span>;                     <span class="comment">// 蛇的长度</span></span><br><span class="line">    <span class="type">int</span> body_position[MAX_LENGTH][<span class="number">2</span>];   <span class="comment">// 蛇身体的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Move_Direction</span> <span class="title">move_direction</span>;</span> <span class="comment">// 蛇运动的方向</span></span><br><span class="line">    <span class="type">int</span> isdead = <span class="number">0</span>;                     <span class="comment">// 蛇是否已经死亡</span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> <span class="title function_">snake_move</span><span class="params">()</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************地图和两条蛇的定义*********************/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">map</span>[<span class="title">v_length</span>][<span class="title">h_length</span>] =</span> &#123;nothing&#125;; <span class="comment">// 相当于全是 nothing</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Snake</span> <span class="title">snakes</span>[2];</span></span><br><span class="line"><span class="type">int</span> food_position[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> map_choice;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************全局函数声明*************************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pretreatment</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_map</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">change_direction</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">create_food</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> create_time)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">is_eating_food</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">gameover</span><span class="params">()</span>;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************主函数**************************/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    pretreatment();</span><br><span class="line">    welcome();</span><br><span class="line">    <span class="comment">// printf(&quot;hhhhh1&quot;);</span></span><br><span class="line">    init();</span><br><span class="line">    <span class="comment">// system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        change_direction();</span><br><span class="line">        snakes[<span class="number">0</span>].snake_move();</span><br><span class="line">        snakes[<span class="number">1</span>].snake_move();</span><br><span class="line">        <span class="keyword">if</span> (snakes[<span class="number">0</span>].isdead + snakes[<span class="number">1</span>].isdead)</span><br><span class="line">        &#123;</span><br><span class="line">            gameover();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************全局函数**************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myprintf</span><span class="params">(<span class="keyword">enum</span> Items item, <span class="type">int</span> row, <span class="type">int</span> column)</span></span><br><span class="line">&#123;</span><br><span class="line">    COORD pos;                                       <span class="comment">//定义光标位置的结构体变量</span></span><br><span class="line">    pos.X = <span class="number">2</span> * column;                              <span class="comment">//横坐标</span></span><br><span class="line">    pos.Y = row;                                     <span class="comment">//纵坐标</span></span><br><span class="line">    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); <span class="comment">//获取控制台句柄</span></span><br><span class="line">    SetConsoleCursorPosition(handle, pos);           <span class="comment">//设置光标位置</span></span><br><span class="line">    <span class="keyword">switch</span> (item)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> wall:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>); <span class="comment">// 墙体白色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 第一条蛇是绿色的</span></span><br><span class="line">    <span class="keyword">case</span> snakebody0:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> snakehead0:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">11</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 第二条蛇是黄色的</span></span><br><span class="line">    <span class="keyword">case</span> snakebody1:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;■&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> snakehead1:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;□&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> food:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">4</span>); <span class="comment">// 食物红色</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;★&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> nothing:</span><br><span class="line">        SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>); <span class="comment">// 空气（表示什么都没有）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 ＠＠　　　　 　　　　　　　　＠　　　　　　　　＠　　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　＠＠＠＠　　　　　　　　　　　　　　　　　　  ＠＠　　　　　　　　　　　　　＠　　　　　　　　＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠＠＠＠　　　　　　　　　　　　　　　　＠＠　　　　　　　　　　　　　　＠　　　　　　　　＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠＠＠＠＠　＠＠＠＠＠＠　　　　　　＠＠＠＠＠　＠＠＠＠＠＠＠＠＠＠＠　　　　　　＠　　　　＠＠＠＠＠＠＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　＠＠＠＠＠＠　＠＠＠　　＠＠＠＠＠＠　　　　＠＠　　＠　＠＠　　　　　　　　　　　　　　　＠　　　　＠＠　　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　＠＠＠＠＠＠＠＠＠＠＠＠＠＠　　　　　　＠　　　＠＠＠　　　　　　　　　　　　　　＠＠＠  ＠＠　＠　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　　　　　　　＠＠＠＠　　　　　　　＠　　　＠　＠＠＠＠＠＠＠＠＠　　　　　　＠　＠　　＠　＠　＠　　　＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠＠＠＠＠　　　　　　　　＠　　　＠　　　　　　　＠＠＠　　　　　　＠　＠　　＠　＠　＠　　　＠＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠＠＠　　　　　　　　　　　　＠　　　＠　　　　　　＠＠＠　　　　　　　＠　＠　　＠　　　＠　　＠＠＠　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠＠＠＠＠＠＠＠＠＠＠　　　　　　　＠　　　＠　　　　　＠＠＠　　　　　　　　＠　＠　　＠　　　＠　＠＠＠　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠＠　　　＠　　　　＠＠　　　　　　　＠　　　＠　　　　＠＠＠　　　　　　　　　＠＠＠　　＠　　　＠＠＠＠　　　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　　＠　　　　　＠　　　　　　　＠　　　＠　　　＠＠＠　　　　　　　　　　＠＠＠＠＠＠　　　＠＠＠　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　＠＠　　　　　＠　　　　　　　＠　　　＠　　＠＠＠　　　　　＠＠　　　　　　＠　　＠　　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　　＠＠　＠＠　　＠　　　　　　　＠　　　＠　＠＠＠　　　　　　＠＠　　　　　　＠　　＠＠　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　＠　　＠＠＠　＠＠＠＠＠　　　　　　　＠　　　＠　＠＠　　　　　　　＠＠　　　　　　＠　＠＠＠　　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　　　　　＠＠＠　　　＠＠＠＠　　　　　　　＠＠　＠＠　＠＠　　　　　　　＠＠　　　＠＠＠＠＠＠＠＠＠　＠　　　　　＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　＠＠＠＠＠＠　　　　　　＠＠＠　　　　　　＠＠＠＠＠　＠＠＠＠＠＠＠＠＠＠＠　　　＠＠＠＠＠　　＠＠　＠＠　　　＠＠＠　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　　＠＠＠＠　　　　　　　　　＠＠　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　＠＠＠＠＠＠＠　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n\n请按 enter 继续，祝您游戏愉快！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;欢迎进入贪吃蛇游戏！\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏规则如下：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;使用键盘上的 W、A、S、D 键分别可以使蛇向上下左右移动\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请让您的蛇尽量多地吃到食物并避免触碰到自身和墙壁\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;水平方向的墙面长度被设置为%d,\n竖直方向的墙面长度被设置为%d。\n&quot;</span>, h_length, v_length); <span class="comment">// 重复信息，向玩家确认</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n\n现在您可以选择一张地图\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;0：正常模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1：隔离模式墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;2：随机散点墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;3：固定纵横墙模式\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;4：随机水平墙模式\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入 0~4 中的其中一个数字：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;map_choice);</span><br><span class="line">        <span class="keyword">if</span> (map_choice &gt;= <span class="number">0</span> &amp;&amp; map_choice &lt;= <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按 enter 继续，祝您游戏愉快！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf(&quot;请输入地图的水平和竖直尺寸（两个数字中间用空格隔开）：\n&quot;);</span></span><br><span class="line">    <span class="comment">// scanf(&quot;%d %d&quot;, &amp;h_length, &amp;v_length);</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pretreatment</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;title Double Snakes&quot;</span>);         <span class="comment">// 设置cmd窗口的名字</span></span><br><span class="line">    system(<span class="string">&quot;mode con cols=200 lines=100&quot;</span>); <span class="comment">// 设置cmd窗口的大小</span></span><br><span class="line"></span><br><span class="line">    CONSOLE_CURSOR_INFO curInfo;                     <span class="comment">// 定义光标信息的结构体变量</span></span><br><span class="line">    curInfo.dwSize = <span class="number">1</span>;                              <span class="comment">// 如果没赋值的话，光标隐藏无效</span></span><br><span class="line">    curInfo.bVisible = FALSE;                        <span class="comment">// 将光标设置为不可见</span></span><br><span class="line">    HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); <span class="comment">// 获取控制台句柄</span></span><br><span class="line">    SetConsoleCursorInfo(handle, &amp;curInfo);          <span class="comment">// 设置光标信息</span></span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time(<span class="literal">NULL</span>)); <span class="comment">// 随机数播种</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">choose_map</span><span class="params">(<span class="type">int</span> map_choice)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">switch</span> (map_choice)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="comment">// 没有任何模式</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 隔离模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">            myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机生成墙模式</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">19</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// -8 是为了让行列值尽量靠中</span></span><br><span class="line">            <span class="type">int</span> row = rand() % (v_length - <span class="number">4</span>);</span><br><span class="line">            <span class="type">int</span> column = rand() % (h_length - <span class="number">4</span>);</span><br><span class="line">            <span class="comment">// 如果map[row][column] + map[row - 1][column] + map[row + 1][column] + map[row][column - 1] + map[row][column + 1] == 0那么就是这几个位置都是 nothing</span></span><br><span class="line">            <span class="keyword">if</span> (!(<span class="built_in">map</span>[row][column] + <span class="built_in">map</span>[row - <span class="number">1</span>][column] + <span class="built_in">map</span>[row + <span class="number">1</span>][column] + <span class="built_in">map</span>[row][column - <span class="number">1</span>] + <span class="built_in">map</span>[row][column + <span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[row][column] = wall;</span><br><span class="line">                myprintf(wall, row, column);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="comment">// 竖直固定墙模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length / <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i][h_length / <span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">                myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = v_length - v_length / <span class="number">3</span> - <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">map</span>[i][h_length / <span class="number">2</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">map</span>[i][h_length / <span class="number">2</span>] = wall;</span><br><span class="line">                myprintf(wall, i, h_length / <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= h_length / <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">map</span>[v_length / <span class="number">2</span>][i] = wall;</span><br><span class="line">            myprintf(wall, v_length / <span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = h_length - h_length / <span class="number">3</span> - <span class="number">1</span>; i &lt;= h_length - <span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">map</span>[v_length / <span class="number">2</span>][i] = wall;</span><br><span class="line">            myprintf(wall, v_length / <span class="number">2</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        <span class="comment">// 随机水平墙模式</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> row = rand() % (v_length - <span class="number">6</span> * i) + <span class="number">3</span>;</span><br><span class="line">            <span class="type">int</span> column = rand() % (h_length - <span class="number">12</span>) + <span class="number">6</span>;</span><br><span class="line">            <span class="type">int</span> wall_length = rand() % <span class="number">15</span> + <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= wall_length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>[row][column + j] &amp;&amp; column + j &lt;= h_length - <span class="number">2</span>) <span class="comment">// 如果map[row][column + j] 不为 nothing</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">map</span>[row][column + j] = wall;</span><br><span class="line">                    myprintf(wall, row, column + j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化信息函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化一些信息</span></span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 定义循环变量 i，j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先初始化两条蛇的id</span></span><br><span class="line">    snakes[<span class="number">0</span>].id = <span class="number">0</span>;</span><br><span class="line">    snakes[<span class="number">1</span>].id = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将最上方的墙保存到数组当中</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= h_length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[<span class="number">0</span>][i] = wall; <span class="comment">// 最上方的墙位于第 0 行，因此第一维下标都是 0</span></span><br><span class="line">        myprintf(wall, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为第 0 行和第 v_length 行已经用来创建上下两面墙，因此我们的对于二维数组行数的循环范围应该扣去首尾两行，即 1 到 v_length - 2</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= v_length - <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 刻画左右两面墙，这两句代码会被重复 v_length - 1 次，最终组成两面连续的墙</span></span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">0</span>] = wall;            <span class="comment">// 左边的竖直墙</span></span><br><span class="line">        <span class="built_in">map</span>[i][h_length - <span class="number">1</span>] = wall; <span class="comment">// 右边的竖直墙</span></span><br><span class="line">        myprintf(wall, i, <span class="number">0</span>);</span><br><span class="line">        myprintf(wall, i, h_length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后将最下方的墙保存到数组当中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= h_length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[v_length - <span class="number">1</span>][i] = wall;     <span class="comment">// 最下方的墙位于第 v_length - 1 行，因此第一维下标都是  v_length - 1</span></span><br><span class="line">        myprintf(wall, v_length - <span class="number">1</span>, i); <span class="comment">// 打印最下方的墙</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置蛇的初始位置信息</span></span><br><span class="line">    <span class="comment">// 第一条蛇位于地图左上方</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>] = <span class="number">4</span> - i;</span><br><span class="line">        <span class="comment">// 蛇头在1行4列；蛇尾在1行1列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二条蛇位于地图右下方</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>] = v_length - <span class="number">2</span>;</span><br><span class="line">        snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>] = h_length - <span class="number">5</span> + i;</span><br><span class="line">        <span class="comment">// 蛇头在v_length - 2行、h_length - 5列; 蛇尾在v_length - 2行，h_length - 2列</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>[snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]] = snakehead0;     <span class="comment">// 在地图上记录 0 号蛇的蛇头</span></span><br><span class="line">    myprintf(snakehead0, snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">0</span>], snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇头</span></span><br><span class="line">    <span class="built_in">map</span>[snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]] = snakehead1;     <span class="comment">// 在地图上记录 1 号蛇的蛇头</span></span><br><span class="line">    myprintf(snakehead1, snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">0</span>], snakes[<span class="number">1</span>].body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 1 号蛇的蛇头</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= snakes[<span class="number">0</span>].length - <span class="number">1</span>; i++)                                         <span class="comment">// 由于初始状态下 1 号蛇的长度和 0 号蛇的长度是相等的，所以这边 snakes[0].length - 1 就是 snakes[1].length - 1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>]][snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>]] = snakebody0;     <span class="comment">// 在地图上记录 0 号蛇的蛇身</span></span><br><span class="line">        myprintf(snakebody0, snakes[<span class="number">0</span>].body_position[i][<span class="number">0</span>], snakes[<span class="number">0</span>].body_position[i][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇身</span></span><br><span class="line">        <span class="built_in">map</span>[snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>]][snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>]] = snakebody1;     <span class="comment">// 在地图上记录 1 号蛇的蛇身</span></span><br><span class="line">        myprintf(snakebody1, snakes[<span class="number">1</span>].body_position[i][<span class="number">0</span>], snakes[<span class="number">1</span>].body_position[i][<span class="number">1</span>]); <span class="comment">// 在屏幕上绘制 0 号蛇的蛇身</span></span><br><span class="line">    &#125;</span><br><span class="line">    snakes[<span class="number">0</span>].move_direction = right; <span class="comment">// 0 号蛇向右运动</span></span><br><span class="line">    snakes[<span class="number">1</span>].move_direction = left;  <span class="comment">// 1 号蛇向左运动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建地图</span></span><br><span class="line">    choose_map(map_choice);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 3 个食物</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        create_food(i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">change_direction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (kbhit()) <span class="comment">// 如果缓冲区中还有</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (getch())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;w&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != down)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = up;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;S&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != up)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = down;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != right)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">0</span>].move_direction != left)</span><br><span class="line">                snakes[<span class="number">0</span>].move_direction = right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UP:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != down)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = up;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> DOWN:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != up)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = down;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LEFT:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != right)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = left;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> RIGHT:</span><br><span class="line">            <span class="keyword">if</span> (snakes[<span class="number">1</span>].move_direction != left)</span><br><span class="line">                snakes[<span class="number">1</span>].move_direction = right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SPACE:</span><br><span class="line">            system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_food</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> create_time)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (create_time == <span class="number">10000</span>) <span class="comment">// 超过 10000 次仍然不能得到食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        food_position[i][<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        food_position[i][<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">    &#125;                                                             <span class="comment">// 随机数播种</span></span><br><span class="line">    food_position[i][<span class="number">0</span>] = rand() % v_length;                      <span class="comment">// 随机生成行数</span></span><br><span class="line">    food_position[i][<span class="number">1</span>] = rand() % h_length;                      <span class="comment">// 随机生成列数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[food_position[i][<span class="number">0</span>]][food_position[i][<span class="number">1</span>]] == nothing) <span class="comment">// 只有在空地上才能产生食物</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">map</span>[food_position[i][<span class="number">0</span>]][food_position[i][<span class="number">1</span>]] = food;     <span class="comment">// 在地图上更新食物信息</span></span><br><span class="line">        myprintf(food, food_position[i][<span class="number">0</span>], food_position[i][<span class="number">1</span>]); <span class="comment">// 绘制出食物食物</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        create_food(i, create_time + <span class="number">1</span>); <span class="comment">// 递归，再创建一次食物</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_eating_food</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> column)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (food_position[i][<span class="number">0</span>] == row &amp;&amp; food_position[i][<span class="number">1</span>] == column) <span class="comment">// 只要满足吃掉的是其中一个食物</span></span><br><span class="line">        &#123;</span><br><span class="line">            create_food(i, <span class="number">0</span>); <span class="comment">// 再创建一个食物</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">gameover</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Sleep(<span class="number">1000</span>); <span class="comment">// 反应时间</span></span><br><span class="line">    system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                       ＠＠＠＠                           \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     　　　　　　　　　  ＠＠＠　　　　　　　　　　　　       \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　 　　　　　   　　　　＠＠＠　　　　　　　　　　　　        \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;　 　　＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠　　　　\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;      ＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠        \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;     ＠＠＠                                 ＠＠＠         \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;    ＠＠＠            ＠＠＠＠              ＠＠＠          \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                     ＠＠＠＠                              \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;        ＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                    ＠＠＠＠                                \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                 ＠＠＠  ＠＠＠                             \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;               ＠＠＠＠   ＠＠＠＠                          \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;             ＠＠＠        ＠＠＠＠                         \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠＠    \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                  ＠＠＠＠                 \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠＠＠＠＠＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠　　　  ＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;           ＠＠＠＠＠＠＠＠          ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                   ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                                   ＠＠＠                  \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                          ＠      ＠＠＠                   \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                           ＠＠  ＠＠＠                     \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                            ＠＠＠＠＠                      \n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;                              ＠＠＠                       \n&quot;</span>);</span><br><span class="line">    SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;游戏结束，请按 enter 继续！\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 0 条蛇的最终长度是 %d\n&quot;</span>, snakes[<span class="number">0</span>].length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 1 条蛇的最终长度是 %d\n&quot;</span>, snakes[<span class="number">1</span>].length);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请按 enter 退出\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (getch() != <span class="string">&#x27;\r&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************结构体内部函数**************************/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Snake::snake_move</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j; <span class="comment">// 定义循环变量 i，j</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置在这个函数中应该使用哪种绘制蛇的材质</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">temphead</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Items</span> <span class="title">tempbody</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (this-&gt;id)</span><br><span class="line">    &#123;</span><br><span class="line">        temphead = snakehead1;</span><br><span class="line">        tempbody = snakebody1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        temphead = snakehead0;</span><br><span class="line">        tempbody = snakebody0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> move[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;; <span class="comment">// 移动方向数组：由四个一维数组组成，分别代表向上下左右运动</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> temptail[<span class="number">2</span>] = &#123;this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">0</span>], this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">1</span>]&#125;; <span class="comment">// 创建一个数组用来存放蛇尾所在位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先将后面所有身体段向前移动一位</span></span><br><span class="line">    <span class="keyword">for</span> (i = this-&gt;length - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把前一位的位置赋给后一位</span></span><br><span class="line">        this-&gt;body_position[i][<span class="number">0</span>] = this-&gt;body_position[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        this-&gt;body_position[i][<span class="number">1</span>] = this-&gt;body_position[i - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    myprintf(tempbody, this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 将原本蛇头的位置打印为蛇身</span></span><br><span class="line">    <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] = tempbody;     <span class="comment">// 在地图上相应地进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将蛇头依据方向进行移动</span></span><br><span class="line">    this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>] += move[this-&gt;move_direction][<span class="number">0</span>];</span><br><span class="line">    this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>] += move[this-&gt;move_direction][<span class="number">1</span>];</span><br><span class="line">    myprintf(temphead, this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 打印新的蛇头</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果碰壁或碰到身体设置蛇已经死亡</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == wall || <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == snakebody0 || <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] == snakebody1)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;isdead = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>[this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>]][this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>]] = temphead; <span class="comment">// 在地图上相应地进行更新</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果吃到食物设置蛇变长</span></span><br><span class="line">    <span class="keyword">if</span> (is_eating_food(this-&gt;body_position[<span class="number">0</span>][<span class="number">0</span>], this-&gt;body_position[<span class="number">0</span>][<span class="number">1</span>])) <span class="comment">// 蛇头的位置是否在食物的位置</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 由于尾部在地图上和画面上尾部的位置都还没有去除，因此也不必更改</span></span><br><span class="line">        this-&gt;length++;</span><br><span class="line">        this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">0</span>] = temptail[<span class="number">0</span>];</span><br><span class="line">        this-&gt;body_position[this-&gt;length - <span class="number">1</span>][<span class="number">1</span>] = temptail[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 如果没吃到食物就将尾部清除</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 在蛇的位置信息 body_positiong 中已经清除</span></span><br><span class="line">        myprintf(nothing, temptail[<span class="number">0</span>], temptail[<span class="number">1</span>]); <span class="comment">// 在画面上清除尾部</span></span><br><span class="line">        <span class="built_in">map</span>[temptail[<span class="number">0</span>]][temptail[<span class="number">1</span>]] = nothing;     <span class="comment">// 在地图信息上清除尾部</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程笔记 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言小游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 TOPSIS 优劣解距离算法</title>
      <link href="/2022/08/10/cTOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/"/>
      <url>/2022/08/10/cTOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>全称 “Technique for Order Preference by Similarity to Ideal Solution”，即“逼近理想解排序法”</p><p>该算法主要用于解决评价类问题，用于确定各个方案层的最终得分</p><p>优点在于能充分利用原始数据的信息， 其结果能精确地反映各评价方案之间的差距。</p><p>TOPSIS 和 AHP 的主要差异在于相关功能和适用问题范围的差异</p><ul><li>TOPSIS 更加适用于解决原始数据相当充分几乎可以进行定量分析的情景</li><li>AHP 算法更加适用于已知条件较为模糊和复杂，难于完全定量分析的情景</li></ul><blockquote><p>事实上，优劣解距离算法和层次分析法可以结合</p></blockquote><h2 id="主要原理"><a href="#主要原理" class="headerlink" title="主要原理"></a>主要原理</h2><p>TOPSIS 的核心原理主要是“指标正向化”方法与“标准化消除量纲影响”方法两个方法的合理性，事实上，这两个方法也是 TOPSIS 和 AHP 的主要区别</p><p>幸运的是，这两个方法的合理性并不需要我们长篇大论地证明，只需要我们使用合理的语言在使用时稍加阐述即可，严格的证明已经由运筹学家解决</p><h1 id="（二）模型步骤"><a href="#（二）模型步骤" class="headerlink" title="（二）模型步骤"></a>（二）模型步骤</h1><h2 id="将明确获取的指标整合成表格"><a href="#将明确获取的指标整合成表格" class="headerlink" title="将明确获取的指标整合成表格"></a>将明确获取的指标整合成表格</h2><p>我们依然采用层次分析法的例子，不同的是，这次，我们的所有要素都有非常准确的数据来源（假设这些数据都已经被我们获取）</p><ul><li>“健康指数”数据由相关专业研究人员评定</li><li>“价格”数据是以人民币为单位的绝对数值</li><li>“距离”数据经过精确测量得到</li><li>“咸淡程度”数据由食物含盐量精确测定</li><li>“等待时间”数据由RUC小喇叭上学生反馈的平均等待时间确定</li></ul><p>将这些信息整理成表格如下：</p><div class="table-container"><table><thead><tr><th>餐厅名称</th><th>餐厅得分(待求值)</th><th>价格</th><th>健康指数</th><th>距离</th><th>咸淡程度</th><th>等待时间</th></tr></thead><tbody><tr><td>东区二楼</td><td></td><td>16</td><td>90</td><td>1.31</td><td>53</td><td>5.21</td></tr><tr><td>西区一楼</td><td></td><td>10</td><td>83</td><td>0.45</td><td>66</td><td>3.45</td></tr><tr><td>中区二楼</td><td></td><td>13</td><td>83</td><td>1.34</td><td>34</td><td>4.03</td></tr></tbody></table></div><h2 id="对表格中的数据进行正向化处理"><a href="#对表格中的数据进行正向化处理" class="headerlink" title="对表格中的数据进行正向化处理"></a>对表格中的数据进行正向化处理</h2><p>我们发现表格中的数据并不完全是同一类型的数据</p><p>事实上，TOPSIS 中用到的数据可以被我们分为四种：</p><ul><li>极大型指标：指标越大越好</li><li>极小型指标：指标越小越好</li><li>中间型指标：指标越接近某个值越好</li><li>区间型指标：指标处在某个区间内最好，区间外的越靠近这个区间越好</li></ul><blockquote><p>比如上面的例子，健康指数是极大型指标，价格、距离和等待时间是极小型指标，而咸淡程度则是区间型数据</p></blockquote><p>下面，我们给出统一指标类型的方法——将所有指标都转成极大型指标，即正向化处理</p><ol><li>对于极小型指标</li></ol><p>找出这组数据的最大值 $x_{max}$ ，每个数据 $x_i$ 对应的正向化以后的指标就是 $x_{max} - x_i$</p><ol><li>对于中间型指标</li></ol><p>列出这组数据和中间型指标的差值，这个差值就是一组极小型指标，采用 1 中的处理方法进行类似的处理，最后做一步<strong>区间赋分处理</strong></p><p>假设正向化处理的函数为 <code>positiveChange</code>，则处理的公式为：</p><script type="math/tex; mode=display">    d_{max} = max\{|x_i - x_{best}|\},\forall i = 1,2,\dots ,n</script><script type="math/tex; mode=display">     positiveChange(x) =  \frac{d_{max} - |x-x_{best}|}{d_{max}}</script><ol><li>对于区间型指标</li></ol><p>如果数据处于区间内，则直接赋予最大值，即 1</p><p>如果数据位于区间外，则计算数据和区间边界的距离</p><p>设区间为 $[a,b]$ ，我们将计算过程分成下面的几步：</p><ul><li>求出所有数据和区间边界的最大距离 $d_{max}$</li></ul><script type="math/tex; mode=display">d_{max} = max(a - min\{x_i\},max\{x_i\}-b),\forall i = 1,2,\dots,n</script><ul><li>求出每点和区间边界的距离 <code>d(x)</code>，代入公式计，假设正向化处理的函数为 <code>positiveChange</code></li></ul><script type="math/tex; mode=display">    d(x) =     \begin{cases}    a - x,\quad x < a\\    x - b, \quad x > b    \end{cases}</script><script type="math/tex; mode=display">    positiveChange(x) =     \begin{cases}    1,\quad x \in [a, b]\\    \frac{d_{max} - d(x)}{d_{max}}, \quad x \notin [a,b]    \end{cases}</script><h2 id="对表格中的数据进行标准化处理"><a href="#对表格中的数据进行标准化处理" class="headerlink" title="对表格中的数据进行标准化处理"></a>对表格中的数据进行标准化处理</h2><p>在进行正向化处理之后，我们得到了增长意义统一（类型）的一组数据</p><p>然而，在统一意义之后，还应该进行统一的是单位：对于单位我们采用标准化处理的统一方法</p><p>标准化方法是，假设方案 $1,2,3,\dots,n$ 的在同一个因素评价得分分别是 $a_1,a_2,\dots,a_n$</p><p>那么进行标准化以后他们的得分变为 $b_1,b_2,\dots,b_n$ ，应该满足：</p><script type="math/tex; mode=display">b_i = \frac{a_i}{\sqrt{\sum_{k=1}^na_k^2}}</script><p>首先我们将表格数据罗列成正向化矩阵，其中同一列表示同一因素评价下各方案的得分，同一行表示同一方案下不同因素的得分情况，假设一共有 $m$ 个因素和 $n$ 个方案，则</p><p>假设原矩阵（正向化后）为：</p><script type="math/tex; mode=display">\begin{pmatrix}    x_{11}&x_{12}&\cdots&x_{1m}\\    x_{21}&x_{22}&\cdots&x_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    x_{n1}&x_{n2}&\cdots&x_{nm}\end{pmatrix}</script><p>将这个矩阵进行标准化后为：</p><script type="math/tex; mode=display">\begin{pmatrix}    z_{11}&z_{12}&\cdots&z_{1m}\\    z_{21}&z_{22}&\cdots&z_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    z_{n1}&z_{n2}&\cdots&z_{nm}\end{pmatrix}</script><p>同理应该满足$z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^nx_{ij}^2}} , \forall j = 1,2,\dots,m$</p><h2 id="对不同指标赋予一定的权重（可选）"><a href="#对不同指标赋予一定的权重（可选）" class="headerlink" title="对不同指标赋予一定的权重（可选）"></a>对不同指标赋予一定的权重（可选）</h2><p>我们还可以使用层次分析法对不同权重的重要程度作出分析，具体参见 <code>AHP.md</code> ， 假设已经通过分析得到这些要素的权重分别为 $w_1,w_2,\dots,w_m$</p><h2 id="根据指标权重和表格数据给出最终得分"><a href="#根据指标权重和表格数据给出最终得分" class="headerlink" title="根据指标权重和表格数据给出最终得分"></a>根据指标权重和表格数据给出最终得分</h2><p>经过上述过程，我们现在已经得到了标准化后的矩阵了，即</p><script type="math/tex; mode=display">\begin{pmatrix}    z_{11}&z_{12}&\cdots&z_{1m}\\    z_{21}&z_{22}&\cdots&z_{2m}\\    \vdots&\vdots&\ddots&\vdots\\    z_{n1}&z_{n2}&\cdots&z_{nm}\end{pmatrix}</script><p>现在我们还要经过一步处理得到最终的得分，在列出公式之前还是应该提醒一下：</p><p>同一列表示同一因素评价下各方案的得分，同一行表示同一方案下不同因素的得分情况，假设一共有 $m$ 个因素和 $n$ 个方案</p><p>我们整合出一个最大值向量：它包含了 $m$ 个分量，表示这 $m$ 个因素的最大指标，即：</p><script type="math/tex; mode=display">    Z^{max} = (\underbrace{max\{z_{11},z_{21},\cdots,z_{n1}\},max\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,max\{z_{1m},z_{2m},\cdots,z_{nm}\}}_{共 m 个分量})</script><p>同理，我们也可以定义最小值向量</p><script type="math/tex; mode=display">    Z^{min} = (\underbrace{min\{z_{11},z_{21},\cdots,z_{n1}\},min\{z_{12},z_{22},\cdots,z_{n2}\},\cdots,min\{z_{1m},z_{2m},\cdots,z_{nm}\}}_{共 m 个分量})</script><p>我们知道任意一行向量表示一个方案的所有因素的得分</p><p>第 $i$ 个方案对应的行向量（各因素得分）为 $z_{i1},z_{i2},\cdots,z_{im}$，我们可以定义这个方案和最大值向量的距离</p><script type="math/tex; mode=display">    D^{from-max}_i = \sqrt{\sum^{m}_{j=1}(Z^{max}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><p>同理我们也可以定义这个方案对应的行向量（各因素得分）和最小值向量的距离</p><script type="math/tex; mode=display">    D^{from-min}_i = \sqrt{\sum^{m}_{j=1}(Z^{min}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><blockquote><p>值得注意的是，我们上面两个公式的计算是默认每个因素之间重要程度的比值为 $w_1:w_2:\cdots:w_n = 1:1:\cdots :1$ 的，如果我们根据一些方法（如 AHP 、熵权法 etc.）得到了不同因素的权重，那么上面两个公式应该改成：</p><script type="math/tex; mode=display">D^{from-max}_i = \sqrt{\sum^{m}_{j=1}w_j(Z^{max}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script><script type="math/tex; mode=display">D^{from-min}_i = \sqrt{\sum^{m}_{j=1}w_j(Z^{min}_j-z_{ij})^m} \quad,\quad \forall i = 1,2,\cdots,n</script></blockquote><p>这样，我们可以计算出这个方案的得分，设第 $i$ 行对应的方案的得分为 $s_i$，应该有</p><script type="math/tex; mode=display">    s_i = \frac{D^{from-min}_i}{D^{from-min}_i+D^{from-max}_i}</script><p>可以用下面的图表示</p><center><img src = https://s1.ax1x.com/2022/08/08/vQpGDK.png width = 55%></center><p>使用和层次分析法一样的归一化方法，即可得到最终得分，进而得到最终排名</p><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol><li>将明确获取的指标整合成表格（行是方案，列是因素）</li><li>对表格中的数据进行正向化处理</li><li>对表格中的数据进行标准化处理（统一单位）</li><li>对不同指标赋予一定的权重（可选）</li><li>根据指标权重和表格数据给出最终得分</li></ol><h1 id="（三）代码实现"><a href="#（三）代码实现" class="headerlink" title="（三）代码实现"></a>（三）代码实现</h1><blockquote><p>以下代码可以在我的 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/TOPSIS%E4%BC%98%E5%8A%A3%E8%A7%A3%E8%B7%9D%E7%A6%BB%E7%AE%97%E6%B3%95">GitHub 仓库</a> 中下载</p></blockquote><ul><li>主代码部分</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">clc, clear;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第一步：读取矩阵的内容</span></span><br><span class="line">data <span class="built_in">=</span> readmatrix(<span class="string">&#x27;TOPSIS.xls&#x27;</span>);</span><br><span class="line">[n,m] <span class="built_in">=</span> size(data);</span><br><span class="line">disp([<span class="string">&#x27;您一共输入了 &#x27;</span>, num2str(n), <span class="string">&#x27; 个待评价对象, &#x27;</span>, <span class="string">&#x27;一共有 &#x27;</span>, num2str(m),<span class="string">&#x27; 个评价因素&#x27;</span>]);</span><br><span class="line">needToPositiveChange <span class="built_in">=</span> input([<span class="string">&#x27;这 &#x27;</span>,num2str(m),<span class="string">&#x27; 个因素是否需要先经过正向化处理，需要请输入1，不需要请输入0：&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第二步：对需要进行正向化的列进行正向化</span></span><br><span class="line"><span class="built_in">if</span> needToPositiveChange <span class="built_in">=</span><span class="built_in">=</span> <span class="number">1</span>   <span class="comment">% 表示需要正向化</span></span><br><span class="line">    pos <span class="built_in">=</span> input([<span class="string">&#x27;请以数组的形式输入需要正向化处理的因素所在的列，例如第1，2，3列需要处理，就输入[1,2,3]：&#x27;</span>]);</span><br><span class="line">    PositiveChangeType <span class="built_in">=</span> input(<span class="string">&#x27;请以数组形式依次输入需要处理的这些列的指标类型（1：极小型；2：中间型；3：极大型）：&#x27;</span>);</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span>:size(pos,<span class="number">2</span>)</span><br><span class="line">        <span class="comment">% PositiveChange 是我们自定义的一个函数</span></span><br><span class="line">        <span class="comment">% 第一个参数接受一个数组，代表一个因素下的所有方案的评分</span></span><br><span class="line">        <span class="comment">% 第二个参数接受一个数，代表一个因素的指标类型</span></span><br><span class="line">        <span class="comment">% 第三个参数接受一个数，代表这个因素在原始矩阵中的列数</span></span><br><span class="line">        data(:,pos(i)) <span class="built_in">=</span> PositiveChange(data(:,pos(i)), PositiveChangeType(i), pos(i));  <span class="comment">% 将原始矩阵的相列进行正向化</span></span><br><span class="line">    end</span><br><span class="line">    disp(<span class="string">&#x27;正向化后的矩阵为：&#x27;</span>);</span><br><span class="line">    disp(data);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：将正向化后的矩阵标准化</span></span><br><span class="line"><span class="comment">% repmat 函数用于将数组等价拷贝 n 次构成矩阵</span></span><br><span class="line">standard_data <span class="built_in">=</span> data./repmat(sum(data .* data).^<span class="number">0.5</span> , n, <span class="number">1</span>);</span><br><span class="line">disp(<span class="string">&#x27;标准化后的矩阵为：&#x27;</span>);</span><br><span class="line">disp(standard_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：分别计算出和最大向量与最小向量之间的距离，得出评分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面一行代码求出各方案和最大值向量之间的距离</span></span><br><span class="line">d_from_max <span class="built_in">=</span> sum([(standard_data - repmat(max(standard_data), n, <span class="number">1</span>)) .^ <span class="number">2</span>], <span class="number">2</span>) .^ <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 下面一行代码求出各方案和最小值向量之间的距离</span></span><br><span class="line">d_from_min <span class="built_in">=</span> sum([(standard_data - repmat(min(standard_data), n, <span class="number">1</span>)) .^ <span class="number">2</span>], <span class="number">2</span>) .^ <span class="number">0.5</span>;</span><br><span class="line"><span class="comment">% 计算出得分</span></span><br><span class="line">scores <span class="built_in">=</span> d_from_min ./ (d_from_min + d_from_max);</span><br><span class="line"><span class="comment">% 进行归一化</span></span><br><span class="line">standard_scores <span class="built_in">=</span> scores / sum(scores);</span><br><span class="line"><span class="comment">% 降序排序，得到索引</span></span><br><span class="line">[sorted_standard_scores, scores_index] <span class="built_in">=</span> sort(standard_scores, <span class="string">&#x27;descend&#x27;</span>);</span><br><span class="line"></span><br><span class="line">disp(<span class="string">&#x27;最后的得分如下：&#x27;</span>);</span><br><span class="line">disp(standard_scores); <span class="comment">% 显示得分</span></span><br><span class="line">disp(<span class="string">&#x27;排名索引如下：&#x27;</span>);</span><br><span class="line">disp(scores_index);</span><br></pre></td></tr></table></figure><ul><li>正向化转换函数  <code>PositiveChange</code> 函数代码</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function [changed_data] <span class="built_in">=</span> PositiveChange(data, <span class="keyword">type</span>, pos)</span><br><span class="line">    <span class="built_in">if</span> <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">1</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是极小型&#x27;</span>);</span><br><span class="line">       changed_data <span class="built_in">=</span> max(data) - data;</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    elseif <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">2</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是中间型&#x27;</span>);</span><br><span class="line">       best <span class="built_in">=</span> input(<span class="string">&#x27;请输入它的最优值：&#x27;</span>);</span><br><span class="line">       maxD_from_best <span class="built_in">=</span> max(abs(data - best));</span><br><span class="line">       changed_data <span class="built_in">=</span> <span class="number">1</span> - abs(data - best)/maxD_from_best;</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    elseif <span class="keyword">type</span> <span class="built_in">=</span><span class="built_in">=</span> <span class="number">3</span></span><br><span class="line">       disp(<span class="string">&#x27;您输入的第 &#x27;</span>, num2str(pos), <span class="string">&#x27; 列是区间型&#x27;</span>);</span><br><span class="line">       low <span class="built_in">=</span> input(<span class="string">&#x27;请输出区间的下界&#x27;</span>);</span><br><span class="line">       high <span class="built_in">=</span> input(<span class="string">&#x27;请输出区间的上界&#x27;</span>);</span><br><span class="line">       maxD_from_inter <span class="built_in">=</span> max([low - min(data), max(data) - high]);</span><br><span class="line">       datasize <span class="built_in">=</span> size(data, <span class="number">1</span>);</span><br><span class="line">       changed_data <span class="built_in">=</span> zeros(datasize, <span class="number">1</span>);</span><br><span class="line">       for i <span class="built_in">=</span> <span class="number">1</span>:datasize</span><br><span class="line">           <span class="built_in">if</span> data(i) &lt; low</span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span> - (low - data(i))/maxD_from_inter;</span><br><span class="line">           elseif data(i) &gt; high</span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span> - (data(i) - high)/maxD_from_inter;</span><br><span class="line">           <span class="built_in">else</span></span><br><span class="line">               changed_data(i) <span class="built_in">=</span> <span class="number">1</span>;</span><br><span class="line">           end</span><br><span class="line">       end</span><br><span class="line">       disp(<span class="string">&#x27;----------------------------------------------------------&#x27;</span>);</span><br><span class="line">    <span class="built_in">else</span></span><br><span class="line">       disp(<span class="string">&#x27;请确保输入数据的是 1，2，3 中的其中一个&#x27;</span>);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 DF 数据拟合算法（Data Fitting）</title>
      <link href="/2022/08/07/cDF%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88/"/>
      <url>/2022/08/07/cDF%E6%95%B0%E6%8D%AE%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="什么是数据拟合"><a href="#什么是数据拟合" class="headerlink" title="什么是数据拟合"></a>什么是数据拟合</h2><p>已知一组（二维）数据，即平面上的 $n$ 个点 $(x_i,y_i),\quad \forall i = 1,2,\cdots,n $， $x_i$ 互不相同，寻求一个函数（曲线） $f(x)$ ，使得 $f(x)$ 在某种意义（准则）下与所有的数据点最为接近，这个过程就是<strong>数据拟合</strong></p><h2 id="曲线拟合的线性最小二乘法"><a href="#曲线拟合的线性最小二乘法" class="headerlink" title="曲线拟合的线性最小二乘法"></a>曲线拟合的线性最小二乘法</h2><p>一般情况下，我们指的“准则”就是线性最小二乘法，线性最小二乘法是解决曲线拟合最常用的方法</p><blockquote><p>本文的符号中，字母上加 ^ 符号表示拟合值</p></blockquote><p>我们假设通过拟合得到的线性函数是：$\widehat{y_i} = \widehat{k}x_i+\widehat{b}$</p><p>那么经过最小二乘法确定参数的方法就是：$\widehat{k},\widehat{b}=arg_{k,b}min(\sum_{i=1}^n|y_i-\widehat{y_i}|)$</p><p>经过数学推导，可以得到线性最小二乘法拟合的参数求解公式：</p><p><img src="https://s1.ax1x.com/2022/08/08/vMvYf1.png" alt="Image"></p><p><img src="https://s1.ax1x.com/2022/08/08/vMvUl6.png" alt="Image"></p><blockquote><p>事实上，拟合的方法远不止线性拟合，这里先以线性拟合作为引子</p></blockquote><h2 id="数据拟合和数据插值的区别"><a href="#数据拟合和数据插值的区别" class="headerlink" title="数据拟合和数据插值的区别"></a>数据拟合和数据插值的区别</h2><blockquote><p>这里直接粘贴写在另一篇笔记中的内容：</p></blockquote><ul><li><p>插值：求已知有限个数据点的近似函数。数模比赛中，常常需要根据已知的样本点进行数据的处理和分析，对于数据量少到不足以去分析问题，而必须生成一些合理的数据，这时我们就会考虑采用插值算法</p></li><li><p>拟合：已知有限个数据点，求近似函数，在样本点较少的情况下，用拟合算法拟合出来的曲线并没有插值算法得到的准确。如果样本点太多，那么插值算法得到的多项式次数过高，会造成“龙格现象”，尽管插值可以通过分段进行解决，但有时我们更希望得到一个精确的函数，因此我们倾向于使用拟合算法进行替代</p></li></ul><blockquote><p>拟合不要求过已知的数据点（插值则要求），而是按某种意义下（一般是最小二乘意义下）得到和所有点的分布最“接近”的函数</p><p>插值和拟合在使用时需要进行区分，根据不同的使用情景来确定不同的方法</p></blockquote><h1 id="（二）拟合效果评价"><a href="#（二）拟合效果评价" class="headerlink" title="（二）拟合效果评价"></a>（二）拟合效果评价</h1><p>我们一般依据下面三个指标来确定拟合的好坏：</p><h2 id="误差平方和"><a href="#误差平方和" class="headerlink" title="误差平方和"></a>误差平方和</h2><p>误差平方和：$SSE = \sum_{i=1}^n(y_i-\widehat{y_i})^2$</p><p>根据误差平方和还能给出均方差的计算公式</p><script type="math/tex; mode=display">MSE = \frac{SSE}{n} = \frac{1}{n}\sum_{i=1}^n(y_i-\widehat{y_i})^2</script><h2 id="回归平方和"><a href="#回归平方和" class="headerlink" title="回归平方和"></a>回归平方和</h2><p>回归平方和：$SSR = \sum_{i=1}^n(\widehat{y_i}-\overline{y})^2$</p><h2 id="拟合优度"><a href="#拟合优度" class="headerlink" title="拟合优度"></a>拟合优度</h2><p>总体平方和：$SST = \sum_{i=1}^n(y_i-\overline{y})^2$</p><p>不难看出会有：$SST=SSE+SSR$</p><p>我们可以用可以用拟合优度（可决系数）作为拟合好坏的评价指标：</p><script type="math/tex; mode=display">    0 \leq R^2 = \frac{SSR}{SST} = \frac{SST-SSE}{SST} \leq 1</script><p>那么， $\frac{SSR}{SST}$ 越大，即 $R^2$ 越接近 $1$ ，就有误差越小，拟合效果越好 </p><blockquote><p>ATTENTION：使用这种评价标准要求参数是一次的，在设计拟合函数时应该注意</p></blockquote><h1 id="（三）多项式拟合函数-polyfit"><a href="#（三）多项式拟合函数-polyfit" class="headerlink" title="（三）多项式拟合函数 polyfit"></a>（三）多项式拟合函数 <code>polyfit</code></h1><h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><ul><li><p>多项式拟合函数 <code>coeff = polyfit(x_sample, y_sample, degree)</code> </p><ul><li><p>第一个参数传入样本点的横坐标数组</p></li><li><p>第二个参数传入样本点的纵坐标数组</p></li><li><p>第三个参数传入我们需要构造的多项式的次数</p></li><li><p>返回值 <code>coeff</code> 是多项式的系数数组</p></li></ul></li><li><p>多项式值计算函数 <code>y_output = polyval(ceoff, x_input)</code></p><ul><li><p>第一个参数传入多项式的系数数组</p></li><li><p>第二个参数传入多项式的自变量值数组</p></li><li><p>返回值 <code>y_output</code> 是多项式的因变量值数组</p></li></ul></li></ul><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下代码保存在 <code>polyfit_test.m</code> 中，可前往 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm">GitHub 仓库下载</a></p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">x_sample <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line"></span><br><span class="line">y_sample <span class="built_in">=</span> [<span class="number">9</span> <span class="number">7</span> <span class="number">6</span> <span class="number">3</span> -<span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">7</span> <span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">plot(x_sample, y_sample, <span class="string">&#x27;bo&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hold on;</span><br><span class="line"></span><br><span class="line">coeff <span class="built_in">=</span> polyfit(x_sample, y_sample, <span class="number">3</span>);   <span class="comment">%三阶多项式拟合</span></span><br><span class="line"></span><br><span class="line">x_input <span class="built_in">=</span> <span class="number">0</span>:.<span class="number">2</span>:<span class="number">10</span>;  </span><br><span class="line"></span><br><span class="line">y_output <span class="built_in">=</span> polyval(coeff, x_input);  <span class="comment">%求对应y值</span></span><br><span class="line"></span><br><span class="line">plot(x_input, y_output, <span class="string">&#x27;r-&#x27;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>输出结果如下，蓝色散点图表示输入样本点，红色实线表示拟合函数</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvNSx.png width = 47%></center><h1 id="（四）万能模型拟合-fit"><a href="#（四）万能模型拟合-fit" class="headerlink" title="（四）万能模型拟合 fit"></a>（四）万能模型拟合 <code>fit</code></h1><blockquote><p>注意：在 <code>MATLAB</code> 中还有一个叫做 <code>ninfit</code> 的函数，两个函数有一定的区别，这里只介绍 <code>fit</code></p><p><code>fit</code> 函数也是在曲线拟合工具箱 <code>Curve Fitting Toolbox</code> 中采用的函数</p></blockquote><h2 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h2><p><code>[fitresult, gof] = fit( xData, yData, fit_type, options );</code></p><ul><li><p>第一个参数传入样本点的自变量坐标数组</p><blockquote><p>不一定是 $x$ 轴坐标，也可以是 $x,y$ 两轴坐标合并为一个数组作为自变量，如下</p><p><code>[fitresult, gof] = fit( [xData, yData], zData, ft, &#39;Normalize&#39;, &#39;on&#39; );</code></p></blockquote></li><li><p>第二个参数传入样本点的因变量坐标数组</p></li><li><p>第三个参数传入拟合函数的拟合类型，需要先用 <code>fittype</code> 函数处理，如下</p><ul><li>如果拟合类型是 <code>fit</code> 函数已经内置的类型，直接使用 <code>ft = fittype( &#39;gaussl&#39; );    % 高斯拟合</code></li><li><p>如果拟合类型不是 <code>fit</code> 函数已经内置的类型，而是我们自己新定义的类型，那么可以如下操作</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 下面采用匿名函数的方法进行定义，但你并不需要精通掌握匿名函数的规则，只需要知道下面的格式和规则</span></span><br><span class="line"><span class="comment">% 命名格式是：fittype(@(参数列表) 拟合函数形式)</span></span><br><span class="line"><span class="comment">% 注意自变量必须是 x</span></span><br><span class="line"><span class="comment">% 注意参数要放在自变量前面，在下面的代码中，匿名函数参数的形式为(a, b, c, x)，便遵循了这一规则</span></span><br><span class="line">ft <span class="built_in">=</span> fittype(@(a, b, c, x) a*x^<span class="number">3</span> + b* x^<span class="number">2</span> + c*x );</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第一个返回值是拟合得到的函数模型结果</p></li><li><p>第二个返回值是包含拟合优度信息的结构体</p></li></ul><blockquote><p>如何使用这两个返回值会在（五）中介绍，它们等价于（五）中的 <code>fittedmodel</code> 和 <code>goodness</code></p></blockquote><h2 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h2><p>以下代码保存在 <code>fit_test1.m</code> 中，可前往 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm">GitHub 仓库下载</a></p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function [fitresult, gof] <span class="built_in">=</span> fit_test2(x_sample, y_sample, z_sample)</span><br><span class="line"><span class="comment">%CREATEFIT(X_SAMPLE,Y_SAMPLE,Z_SAMPLE)</span></span><br><span class="line"><span class="comment">%  创建一个拟合。</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  要进行 &#x27;傅里叶拟合2&#x27; 拟合的数据:</span></span><br><span class="line"><span class="comment">%      X 输入: x_sample</span></span><br><span class="line"><span class="comment">%      Y 输入: y_sample</span></span><br><span class="line"><span class="comment">%      Z 输出: z_sample</span></span><br><span class="line"><span class="comment">%  输出:</span></span><br><span class="line"><span class="comment">%      fitresult: 表示拟合的拟合对象</span></span><br><span class="line"><span class="comment">%      gof: 带有拟合优度信息的结构体</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 拟合: &#x27;傅里叶拟合2&#x27;。</span></span><br><span class="line">[xData, yData, zData] <span class="built_in">=</span> prepareSurfaceData( x_sample, y_sample, z_sample );</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置 fittype 和选项。</span></span><br><span class="line">ft <span class="built_in">=</span> <span class="string">&#x27;linearinterp&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 对数据进行模型拟合。</span></span><br><span class="line">[fitresult, gof] <span class="built_in">=</span> fit( [xData, yData], zData, ft, <span class="string">&#x27;Normalize&#x27;</span>, <span class="string">&#x27;on&#x27;</span> );</span><br></pre></td></tr></table></figure><blockquote><p>用图窗显示结果如下</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMv0mD.png width = 45%></center><h1 id="（五）利用-Curve-Fitting-Toolbox-进行拟合"><a href="#（五）利用-Curve-Fitting-Toolbox-进行拟合" class="headerlink" title="（五）利用 Curve Fitting Toolbox 进行拟合"></a>（五）利用 Curve Fitting Toolbox 进行拟合</h1><blockquote><p>没有安装该应用需要提前安装：<code>Curve Fitting Toolbox</code></p><p>这个工具箱事实上是调用了 <code>MATLAB</code> 的内置函数，并且提供了方便可视化界面和绘图操作</p></blockquote><p>利用工具箱进行函数的操作非常容易，简要步骤如下：</p><ol><li>在当前工作区创建数据</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; x_sample = [1 2 3 4 5 6 7 8 9];</span><br><span class="line">&gt;&gt; y_sample = [9 7 6 3 -1 2 5 7 20];</span><br><span class="line">&gt;&gt; x_input = 0:.2:10;</span><br></pre></td></tr></table></figure><ol><li>打开曲线拟合器，在曲线拟合器中选择数据（会自动在列表中呈现工作区数据以供选择）</li></ol><center><img src = https://s1.ax1x.com/2022/08/08/vMva6K.png width = 32%></center><ol><li>选择不同模型，优化拟合结果</li></ol><blockquote><p>该工具箱能够自动导出拟合优度，如下：</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvJYR.png width = 22%></center><ol><li>导出拟合模型、图窗，如下：</li></ol><blockquote><p>下图为拟合图窗</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vMvdOO.png width = 45%></center><blockquote><p>拟合模型可以导出到工作区，然后直接作为函数调用</p></blockquote><ul><li><p>我们将模型导为 <code>fittedmodel</code> ，就能够直接在命令行中输入 <code>&gt;&gt; fittedmodel(x_input)</code> 进行预测，其中 <code>x_input</code> 指的是待预测数组，这个函数将输出预测得到的值 <code>y_output</code>，直接在命令行中输入 <code>&gt;&gt; fittedmodel</code> 也可以直接查看拟合的函数模型</p></li><li><p>我们将合优度导为 <code>goodness</code> ，可以直接在命令行中输入 <code>&gt;&gt; goodness</code> 查看拟合优度结构体字段</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 DI 数据插值算法（Data Interpolation）</title>
      <link href="/2022/08/07/cDI%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC/"/>
      <url>/2022/08/07/cDI%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="插值和拟合的概念"><a href="#插值和拟合的概念" class="headerlink" title="插值和拟合的概念"></a>插值和拟合的概念</h2><ul><li><p>插值：求已知有限个数据点的近似函数。数模比赛中，常常需要根据已知的样本点进行数据的处理和分析，对于数据量少到不足以去分析问题，而必须生成一些合理的数据，这时我们就会考虑采用插值算法</p></li><li><p>拟合：已知有限个数据点，求近似函数，在样本点较少的情况下，用拟合算法拟合出来的曲线并没有插值算法得到的准确。如果样本点太多，那么插值算法得到的多项式次数过高，会造成“龙格现象”，尽管插值可以通过分段进行解决，但有时我们更希望得到一个精确的函数，因此我们倾向于使用拟合算法进行替代</p></li></ul><blockquote><p>拟合不要求过已知的数据点（插值则要求），而是按某种意义下（一般是最小二乘意义下）得到和所有点的分布最“接近”的函数</p><p>插值和拟合在使用时需要进行区分，根据不同的使用情景来确定不同的方法</p></blockquote><h2 id="概念提示"><a href="#概念提示" class="headerlink" title="概念提示"></a>概念提示</h2><ul><li><p>被插值函数：原始函数，一系列点遵循这个原始函数来分布，被插值函数可能是不存在的，但是我们每次插值前假定所有样本点遵照这个被插值函数进行分布</p></li><li><p>插值函数：由我们根据样本点构造出来的函数，其宗旨是尽量符合被插值函数，即同时满足：完全符合已知样点分布的情况，尽量接近被插值函数中未知点的分布情况</p></li></ul><h2 id="插值算法的应用方法"><a href="#插值算法的应用方法" class="headerlink" title="插值算法的应用方法"></a>插值算法的应用方法</h2><ol><li><p>得到所有已知的样本点</p></li><li><p>选择合适合理的插值算法</p></li><li><p>根据这种插值算法和已知的样本点确认插值函数</p><blockquote><p>该笔记中使用的 <code>MATLAB</code> 函数都有统一的输入形式：第一个参数是样本点数组的 $x$ 值（数组），第二个参数是样本点数组的 $x$ 值（数组），第三个参数是插值点数组的横坐标 $x_input$（数组）</p></blockquote></li><li>根据插值函数就能够得到样本点以外的其它（我们自行构造的）数据</li></ol><h1 id="（二）插值算法原理"><a href="#（二）插值算法原理" class="headerlink" title="（二）插值算法原理"></a>（二）插值算法原理</h1><p>假设有 $n+1$ 个互不相同的节点 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，其中若$i\ne j$ 则 $x_i \ne x_j$</p><p>则存在唯一的多项式：$I_n(x) = a_0 + a_1x + a_2x^2+\cdots+a_nx^n$</p><p>使得$I_n(x_j) = y_j,\quad \forall j = 0,1,2,\cdots,n$</p><blockquote><p>根据线性代数的基本知识，我们知道过 $n+1$ 个横坐标互不相同的点能且只能确定唯一一个 $n$ 次方程</p><p>利用代数学的知识解释就是：</p><p>如果设待插值函数的 $n+1$ 个已知点为 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，而插值函数 $I_n(x)$ 的所有系数看作一组代求的未知量 $(a_0,a_1,\cdots,a_n)$，那么这组未知量就是下面方程的解</p><script type="math/tex; mode=display">A = \begin{pmatrix} 1&x_0&\cdots&x_0^n\\ 1&x_1&\cdots&x_1^n\\ \vdots&\vdots&\ddots&\vdots\\ 1&x_n&\cdots&x_n^n \end{pmatrix} ,\quad X = (a_0,a_1,\cdots,a_n)^T,\quad Y = (y_0,y_1,\cdots,y_n)^T,\quad AX = Y</script><p>其中不难发现 $A$ 为范特蒙德行列式， $|A| = \prod_{i=1}^n\prod_{j=0}^{i-1}(x_i-x_j) \ne 0$ ，故根据克莱姆法则，方程有唯一解，即<strong>在确定次数德情况下</strong>，符合条件的方程有且只有一个</p></blockquote><h1 id="（三）-插值算法1：分段线性插值算法"><a href="#（三）-插值算法1：分段线性插值算法" class="headerlink" title="（三） 插值算法1：分段线性插值算法"></a>（三） 插值算法1：分段线性插值算法</h1><h2 id="分段插值介绍"><a href="#分段插值介绍" class="headerlink" title="分段插值介绍"></a>分段插值介绍</h2><p>分段线性插值算法非常简单，就是在获得的任意两个样本点之间计算一次函数，这样就能通过 $n$ 个样本点得到 $n-1$ 段的分段一次函数，其优点就是简单明晰，运算量小，缺点是在节点不够多时可能不够精确，得到的结果也不够光滑（存在角点），即分段函数的交接处可能不具有导数</p><h2 id="分段插值原理"><a href="#分段插值原理" class="headerlink" title="分段插值原理"></a>分段插值原理</h2><p>假设有两个相邻节点 $(x_1,y_1),(x_2,y_2)$，那么在这两个相邻节点之间的一次线性方程为</p><script type="math/tex; mode=display">y = \frac{x-x_2}{x_1-x_2}y_1+\frac{x-x_1}{x_2-x_1}y_2</script><p>证明过程涉及初中数学，不过多解释</p><h2 id="分段插值法代码"><a href="#分段插值法代码" class="headerlink" title="分段插值法代码"></a>分段插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> PLI(x, y, x_input) </span><br><span class="line"><span class="comment">% Piecewise_Linear_Interpolate</span></span><br><span class="line"><span class="comment">% 该函数实现分段线性插值</span></span><br><span class="line"><span class="comment">% (x,y)为已知的数据点，这两个参数应该是长度一致的数组</span></span><br><span class="line"><span class="comment">% x_input为待插值的横坐标</span></span><br><span class="line"><span class="comment">% y_output为插值后的到的结果</span></span><br><span class="line"> </span><br><span class="line">sizex <span class="built_in">=</span> length(x);</span><br><span class="line">size_x_input <span class="built_in">=</span> length(x_input);</span><br><span class="line">y_output <span class="built_in">=</span> zeros(size_x_input);</span><br><span class="line"></span><br><span class="line">for j <span class="built_in">=</span> <span class="number">1</span> : size_x_input</span><br><span class="line">    for i <span class="built_in">=</span> <span class="number">1</span> : sizex - <span class="number">1</span></span><br><span class="line">        <span class="built_in">if</span> (x_input(j) &gt; x(i) &amp;&amp; x_input(j) <span class="built_in">&lt;=</span> x(i+<span class="number">1</span>)) <span class="comment">% 判断 x_input 在那个区间内</span></span><br><span class="line">            <span class="comment">% 在相应的区间中套用公式求出 y_output</span></span><br><span class="line">            y_output(j) <span class="built_in">=</span> ((x_input(j) - x(i + <span class="number">1</span>)) / (x(i) - x(i+<span class="number">1</span>))) * y(i) + (((x_input(j) - x(i))/(x(i + <span class="number">1</span>) - x(i))) * y(i + <span class="number">1</span>));  </span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><ul><li>分段插值测试代码</li></ul><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%分段线性插值测试</span></span><br><span class="line">x <span class="built_in">=</span> <span class="number">0</span> : <span class="number">2</span>*pi;</span><br><span class="line">y <span class="built_in">=</span> exp(x);   <span class="comment">% 构造一个指数模型作为被插值函数</span></span><br><span class="line">x_input <span class="built_in">=</span> <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">6</span>;</span><br><span class="line">y_output <span class="built_in">=</span> PLI(x,y,x_input);</span><br><span class="line">plot(x, y, <span class="string">&#x27;b+&#x27;</span>, x_input, y_output, <span class="string">&#x27;r:&#x27;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>测试代码在 <code>MATLAB</code> 上的输出结果如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpQ3R.png width = 42%></center><h1 id="（四）插值算法2：拉格朗日多项式插值法"><a href="#（四）插值算法2：拉格朗日多项式插值法" class="headerlink" title="（四）插值算法2：拉格朗日多项式插值法"></a>（四）插值算法2：拉格朗日多项式插值法</h1><h2 id="拉格朗日多项式插值法原理"><a href="#拉格朗日多项式插值法原理" class="headerlink" title="拉格朗日多项式插值法原理"></a>拉格朗日多项式插值法原理</h2><p>如上我们已经验证如下 $n+1$ 次方程一定会有 $n+1$ 个根，分别是多项式 $I_n(x) = a_0 + a_1x + a_2x^2+\cdots+a_nx^n$ 的所有系数</p><script type="math/tex; mode=display">A = \begin{pmatrix} 1&x_0&\cdots&x_0^n\\ 1&x_1&\cdots&x_1^n\\ \vdots&\vdots&\ddots&\vdots\\ 1&x_n&\cdots&x_n^n \end{pmatrix} ,\quad X = (a_0,a_1,\cdots,a_n)^T,\quad Y = (y_0,y_1,\cdots,y_n)^T,\quad AX = Y</script><p>根据这些信息，我们可以直接给出 $n+1$ 次方程的形式，即：</p><script type="math/tex; mode=display">    I(x) = y_1\frac{(x-x_2)(x-x_3)\cdots(x-x_n)}{(x_1-x_2)(x_1-x_3)\cdots(x_1-x_n)}+y_2\frac{(x-x_1)(x-x_3)\cdots(x-x_n)}{(x_2-x_1)(x_2-x_3)\cdots(x_2-x_n)}+\cdots+y_n\frac{(x-x_1)(x-x_2)\cdots(x-x_{n-1})}{(x_n-x_1)(x_n-x_2)\cdots(x_n-x_{n-1})}</script><p>简写为：</p><script type="math/tex; mode=display">    \sum_{i=1}^ny_i\prod_{j=1,j\ne i}^n\frac{x-x_j}{x_i-x_j}</script><blockquote><p>上面这个式子就是插值多项式，这个结论只需要将所有点 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$ 代入验证即可，至于如何构造出的这个巧妙的式子，我们并不需要深入了解</p></blockquote><h2 id="拉格朗日多项式插值法代码"><a href="#拉格朗日多项式插值法代码" class="headerlink" title="拉格朗日多项式插值法代码"></a>拉格朗日多项式插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> LI(x, y, x_input)</span><br><span class="line"><span class="comment">% 样本点数据以数组 x , y 输入，插值点以数组 input_x 输入，输出数组output_y为插值。</span></span><br><span class="line">size_x <span class="built_in">=</span> length(x);</span><br><span class="line">size_x_input <span class="built_in">=</span> length(x_input);</span><br><span class="line">y_output <span class="built_in">=</span> zeros(size_x_input);</span><br><span class="line"></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : size_x_input</span><br><span class="line">    z <span class="built_in">=</span> x_input(i);</span><br><span class="line">    s <span class="built_in">=</span> <span class="number">0.0</span>;</span><br><span class="line">    for k <span class="built_in">=</span> <span class="number">1</span> : size_x</span><br><span class="line">        p <span class="built_in">=</span> <span class="number">1.0</span>;</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : size_x</span><br><span class="line">            <span class="built_in">if</span> j ~<span class="built_in">=</span> k</span><br><span class="line">            p <span class="built_in">=</span> p * (z - x(j))/(x(k) - x(j));</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">        s <span class="built_in">=</span> p*y(k) + s;</span><br><span class="line">    end</span><br><span class="line">    y_output(i) <span class="built_in">=</span> s;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>直接使用分段插值的测试代码测试该函数，得到拟合的函数图像如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpu4J.png width = 42%></center><h1 id="（五）插值算法3：牛顿插值法"><a href="#（五）插值算法3：牛顿插值法" class="headerlink" title="（五）插值算法3：牛顿插值法"></a>（五）插值算法3：牛顿插值法</h1><h2 id="牛顿插值法介绍"><a href="#牛顿插值法介绍" class="headerlink" title="牛顿插值法介绍"></a>牛顿插值法介绍</h2><p>拉格朗日插值公式在插值节点发生改变时，插值公式随之就要重新计算生成。事实上，牛顿插值法和拉格朗日插值法的结果相同，但是表示形式不同，由此形成的计算思路也不相同</p><h2 id="牛顿插值法原理"><a href="#牛顿插值法原理" class="headerlink" title="牛顿插值法原理"></a>牛顿插值法原理</h2><p>首先应该先定义<strong>差商</strong>的概念：</p><script type="math/tex; mode=display">一阶差商：f[x_i,x_j] = \frac{f(x_i)-f(x_j)}{x_i-x_j}</script><script type="math/tex; mode=display">二阶差商： f[x_i,x_j,x_k] = \frac{f[x_i,x_j]-f[x_j,x_k]}{x_i-x_k}</script><script type="math/tex; mode=display">k阶差商：f[x_0,x_1,\cdots,x_n] = \frac{f[x_0,x_1,\cdots,x_{n-1}]-f[x_1,x_2,\cdots,x_n]}{x_0-x_n}</script><p>在这样的定义下，可以得到插值的计算公式，假设有 $n+1$ 个样本点为 $(x_i,y_i),\quad \forall i = 0,1,2,\cdots,n$，那么有：</p><script type="math/tex; mode=display">f(x) = a_0+a_1(x-x_0)+\cdots+a_n(x-x_0)(x-x_1)\cdots(x-x_{n-1})</script><script type="math/tex; mode=display">其中\quad a_k = f[x_0,x_1,\cdots,x_k],\quad \forall k = 0,1,2,\cdots,n</script><h2 id="牛顿插值法的优越性"><a href="#牛顿插值法的优越性" class="headerlink" title="牛顿插值法的优越性"></a>牛顿插值法的优越性</h2><p><strong>可以通过继承已经计算得到的结果实现灵活而强大的可扩展性</strong></p><p>比如新添加一个样本节点 $(x_{n+1},y_{n+1})$ ，对于拉格朗日插值法而言，需要重构整个式子，再计算所有结果，这势必造成大量的计算冗余和浪费</p><p>而牛顿插值法的特殊形式在于 $k$ 阶差商和 $x_{k+1}$ 毫无关系，这意味着插值计算式 $f(x) = a_0+a_1(x-x_0)+\cdots+a_n(x-x_0)(x-x_1)\cdots(x-x_{n-1})$ 的前 $n$ 项都不必改动，只需要在最后进一步计算出 $a_n$ 然后在插值计算式末尾再添加一项即可，这个方法具有很强的计算优越性</p><h2 id="牛顿插值法代码"><a href="#牛顿插值法代码" class="headerlink" title="牛顿插值法代码"></a>牛顿插值法代码</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">function y_output <span class="built_in">=</span> NI(x, y, x_input)</span><br><span class="line">x_size <span class="built_in">=</span> length(x);</span><br><span class="line">x_input_size <span class="built_in">=</span> length(x_input);</span><br><span class="line">dqTable <span class="built_in">=</span> zeros(x_size,x_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 对差商表第一列赋值</span></span><br><span class="line">for k <span class="built_in">=</span> <span class="number">1</span> : x_size      </span><br><span class="line">    dqTable(k) <span class="built_in">=</span> y(k);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求差商表</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">2</span> : x_size       <span class="comment">% 差商表从0阶开始,矩阵从1维开始存储</span></span><br><span class="line">    for k <span class="built_in">=</span> i : x_size</span><br><span class="line">        dqTable(k, i) <span class="built_in">=</span> (dqTable(k, i-<span class="number">1</span>) - dqTable(k-<span class="number">1</span>, i-<span class="number">1</span>)) / (x(k) - x(k + <span class="number">1</span> - i));  </span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">disp(<span class="string">&#x27;差商表如下：&#x27;</span>);</span><br><span class="line">disp(dqTable);</span><br><span class="line"></span><br><span class="line">y_output <span class="built_in">=</span> zeros(x_input_size);  </span><br><span class="line"></span><br><span class="line"><span class="comment">%% 求插值多项式</span></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span> : x_input_size</span><br><span class="line">    for k <span class="built_in">=</span> <span class="number">2</span> : x_size</span><br><span class="line">        t <span class="built_in">=</span> <span class="number">1</span>;</span><br><span class="line">        for j <span class="built_in">=</span> <span class="number">1</span> : k-<span class="number">1</span></span><br><span class="line">            t <span class="built_in">=</span> t * (x_input(i) - x(j));</span><br><span class="line">            <span class="comment">% disp(t)</span></span><br><span class="line">        end</span><br><span class="line">        y_output(i) <span class="built_in">=</span> dqTable(k,k) * t + y_output(i);</span><br><span class="line">    end</span><br><span class="line">    y_output(i) <span class="built_in">=</span> dqTable(<span class="number">1</span>,<span class="number">1</span>) + y_output(i);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="comment">% disp(y_output)</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure><blockquote><p>直接使用分段插值的测试代码测试该函数，得到拟合的函数图像如下（蓝色加号是样本点，红色点线是插值点的连线）</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQpMC9.png width = 42%></center><h2 id="补充：龙格现象"><a href="#补充：龙格现象" class="headerlink" title="补充：龙格现象"></a>补充：龙格现象</h2><p>在数值分析中，高次插值会产生龙格现象（Runge phenomenon）。即在两端处波动极大，产生明显的震荡。</p><p>也因此，我们在实践中一般<strong>不轻易使用高次插值</strong></p><blockquote><p>如下图，红色线条是原始标准函数，蓝色线条是我们根据不同的插值节点选取得到的拟合函数</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQp1jx.png width = 42%></center><h1 id="（六）插值算法4：埃尔米特插值法"><a href="#（六）插值算法4：埃尔米特插值法" class="headerlink" title="（六）插值算法4：埃尔米特插值法"></a>（六）插值算法4：埃尔米特插值法</h1><h2 id="埃尔米特插值法介绍"><a href="#埃尔米特插值法介绍" class="headerlink" title="埃尔米特插值法介绍"></a>埃尔米特插值法介绍</h2><p>埃尔米特（Hermite）分段插值方法，不仅能够满足在节点处与函数同值，而且能够实现函数有相同的一阶、二阶甚至更高阶的导数值</p><p>由于它优越的特性，Hermite 插值法是解决数学建模中预测类问题的最常用的方法</p><ul><li>埃尔米特插值方法的原理</li></ul><center><img src = https://s1.ax1x.com/2022/08/08/vQplg1.png width = 82%>[原理具体还可以参照这里（点击跳转）](https://blog.csdn.net/SanyHo/article/details/106849323)</center><h2 id="埃尔米特插值方法代码实现"><a href="#埃尔米特插值方法代码实现" class="headerlink" title="埃尔米特插值方法代码实现"></a>埃尔米特插值方法代码实现</h2><p>Hermite 插值有现成可用的 markdown 函数，如下：</p><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x <span class="built_in">=</span> -<span class="number">3</span>:<span class="number">3</span>; </span><br><span class="line">y <span class="built_in">=</span> [-<span class="number">1</span> -<span class="number">1</span> -<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>]; </span><br><span class="line">xq1 <span class="built_in">=</span> -<span class="number">3</span>:.<span class="number">01</span>:<span class="number">3</span>;</span><br><span class="line">p <span class="built_in">=</span> pchip(x,y,xq1);</span><br><span class="line">s <span class="built_in">=</span> spline(x,y,xq1);</span><br><span class="line">m <span class="built_in">=</span> makima(x,y,xq1);</span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xq1,p,<span class="string">&#x27;-&#x27;</span>,xq1,s,<span class="string">&#x27;-.&#x27;</span>,xq1,m,<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">legend(<span class="string">&#x27;Sample Points&#x27;</span>,<span class="string">&#x27;pchip&#x27;</span>,<span class="string">&#x27;spline&#x27;</span>,<span class="string">&#x27;makima&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br></pre></td></tr></table></figure><center><img src = https://s1.ax1x.com/2022/08/08/vQp8u6.png width = 42%></center><p>其中 <code>spline</code> 表示三次样条插值，而 <code>pchip</code> 表示三次分段埃尔米特插值</p><blockquote><p>这里顺带一提，上述线性插值法事实上也有 <code>MATLAB</code> 函数 <code>interp1</code>可以调用，如下</p></blockquote><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">x <span class="built_in">=</span> <span class="number">0</span>:<span class="number">2</span>*pi;    </span><br><span class="line">y <span class="built_in">=</span> sin(x);    </span><br><span class="line">xx <span class="built_in">=</span> <span class="number">0</span>:<span class="number">0.5</span>:<span class="number">2</span>*pi;    </span><br><span class="line">  </span><br><span class="line"><span class="comment">% interp1对sin函数进行分段线性插值，调用interp1的时候，默认的是分段线性插值    </span></span><br><span class="line">y1 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;linear&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y1,<span class="string">&#x27;r&#x27;</span>)    </span><br><span class="line">title(<span class="string">&#x27;分段线性插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 临近插值    </span></span><br><span class="line">y2 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;nearest&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y2,<span class="string">&#x27;r&#x27;</span>);    </span><br><span class="line">title(<span class="string">&#x27;临近插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 使用非结终止条件的样条插值    </span></span><br><span class="line">y3 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;spline&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y3,<span class="string">&#x27;r&#x27;</span>)    </span><br><span class="line">title(<span class="string">&#x27;使用非结终止条件的样条插值&#x27;</span>)    </span><br><span class="line">    </span><br><span class="line"><span class="comment">% 保形分段三次插值    </span></span><br><span class="line">y4 <span class="built_in">=</span> interp1(x,y,xx,<span class="string">&#x27;pchip&#x27;</span>);    </span><br><span class="line">subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>);  </span><br><span class="line">plot(x,y,<span class="string">&#x27;o&#x27;</span>,xx,y4,<span class="string">&#x27;r&#x27;</span>);    </span><br><span class="line">title(<span class="string">&#x27;保形分段三次插值&#x27;</span>)    </span><br></pre></td></tr></table></figure><blockquote><p>函数形式为 <code>y_output = interp1(x, y, x_input, &#39;method&#39;)</code> ， <code>method</code> 默认为 ‘linear’，有以下可选值</p></blockquote><p><img src="https://s1.ax1x.com/2022/08/08/vQpJHO.png" alt=""></p><p>上面列举的两个函数 <code>pchip</code> 和 <code>interp1</code> 都可以通过调用函数返回多项式结构体，具体可以参考 <a href="https://ww2.mathworks.cn/help//matlab/ref/pchip.html#bvjbxbd-2">官方文档 phip </a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html#btwp6lt-5">官方文档 interp1 </a></p><h1 id="（七）插值算法5：三次样条插值法"><a href="#（七）插值算法5：三次样条插值法" class="headerlink" title="（七）插值算法5：三次样条插值法"></a>（七）插值算法5：三次样条插值法</h1><h2 id="样条插值介绍"><a href="#样条插值介绍" class="headerlink" title="样条插值介绍"></a>样条插值介绍</h2><p>许多工程技术中提出的计算问题对插值函数的光滑性有较高要求，如飞机的机翼外形，内燃机的进、排气门的凸轮曲线，都要求曲线具有较高的光滑程度，不仅要连续，而且要有<strong>连续的曲率</strong>，这就导致了样条插值的产生。</p><p>样条（Spline）本来是工程设计中使用的一种绘图工具，它是富有弹性的细木条或细金属条。绘图员利用它把一些已知点连接成一条光滑曲线（称为样条曲线），并使连接点处有连续的曲率。</p><p>数学上将具有一定光滑性的分段多项式称为样条函数，即有：</p><p>对于给定区间 $[a,b]$ 中的 $a = x_0&lt;x_1&lt;\cdots&lt;x_{n-1}&lt;x_n=b$ ，如果函数 $f(x)$ 满足在每个小区间 $[x_{i-1},x_i]$ 上 $f(x)$ 是 $k$ 次多项式且具有 $k-1$ 阶连续导数，那么 $f(x)$ 就被称为样条函数</p><p>因此三次样条插值法中构造出的插值函数应该是具有 $2$ 阶连续导数的分段三次函数</p><h2 id="三次样条插值代码"><a href="#三次样条插值代码" class="headerlink" title="三次样条插值代码"></a>三次样条插值代码</h2><p>由于 <code>MATLAB</code> 上已经有已经编写封装的函数提供调用，因此我们这里就不再深入挖掘原理</p><p>三次样条插值的调用方法有两种：</p><p>一种是通过 <code>interp1</code> 函数并将 <code>method</code> 参数设置为 <code>spline</code></p><p>另一种是通过直接调用 <code>spline</code> 函数，它的参数输入和结果输出和 <code>pchip</code> 非常相似，这里不再重复论述，可以参考 <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html">官方文档 spline</a></p><h2 id="三次样条插值和三次埃尔米特分段插值的区别"><a href="#三次样条插值和三次埃尔米特分段插值的区别" class="headerlink" title="三次样条插值和三次埃尔米特分段插值的区别"></a>三次样条插值和三次埃尔米特分段插值的区别</h2><p>一方面，三次样条插值（<code>spline</code>）比三次埃尔米特分段插值（<code>pchip</code>）更加光滑，<code>spline</code>支持 $2$ 阶的导数连续，而 <code>pchip</code> 只能支持 $1$ 阶的导数连续</p><p>另一方面， <code>pchip</code>虽然牺牲了光滑性，但却是能够保形状的， <code>spline</code> 则不一定能够保形状</p><blockquote><p>可以用下面一张图展示它们的区别</p></blockquote><center><img src = https://s1.ax1x.com/2022/08/08/vQp8u6.png width = 42%></center>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模竞赛 AHP 层次分析法</title>
      <link href="/2022/08/06/cAHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2022/08/06/cAHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="（一）GUIDANCE"><a href="#（一）GUIDANCE" class="headerlink" title="（一）GUIDANCE"></a>（一）GUIDANCE</h1><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>全称“层次权重决策分析方法”，一种解决多目标的复杂问题的定性与定量相结合的决策分析方法</p><p>在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>层次分析法根据问题的性质和要达到的总目标，将问题分解为不同的组成因素，并按照因素间的相互关联影响以及隶属关系将因素按不同层次聚集组合，形成一个多层次的分析结构模型，从而最终使问题归结为最低层（方案、措施层）相对于最高层（总目标层）的相对重要权值的确定或相对优劣次序的排定。</li><li>一致矩阵法的合理性：矩阵的一致程度越强，说明我们对不同因素的重要性做出的评估的“矛盾程度”越小，说明我们作出评估越准确</li></ol><hr><h1 id="（二）模型步骤"><a href="#（二）模型步骤" class="headerlink" title="（二）模型步骤"></a>（二）模型步骤</h1><h2 id="步骤一：建立层次结构模型"><a href="#步骤一：建立层次结构模型" class="headerlink" title="步骤一：建立层次结构模型"></a>步骤一：建立层次结构模型</h2><p>1） 确定最高层（总目标）、中间层（考虑的因素）、最低层（等待评估&amp;选择的方案），这三个层又被称为目标层、准则层和方案层</p><blockquote><p>事实上，准则层可以不只有一层，如果定的准则超过 9 个，一般我们选择进一步分出子准则层。</p></blockquote><p>2） 作图方法：<code>vscode</code> 插件 <code>Draw.io Integration</code>，如下：</p>   <center><img src = https://s1.ax1x.com/2022/08/06/vuos8H.png width = 55%></center><h2 id="步骤二：定性分析-amp-定性计算得到准则层判断矩阵"><a href="#步骤二：定性分析-amp-定性计算得到准则层判断矩阵" class="headerlink" title="步骤二：定性分析&amp;定性计算得到准则层判断矩阵"></a>步骤二：定性分析&amp;定性计算得到准则层判断矩阵</h2><p>1） 收集资料，对于准则层提出的各种准则的重要程度有一定的判断依据</p><p>2） 作出判断矩阵</p><div class="table-container"><table><thead><tr><th>因素/因素</th><th>价格</th><th>距离</th><th>口味</th><th>等待时间</th><th>餐厅装潢</th></tr></thead><tbody><tr><td>价格</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td><td>$a_{14}$</td><td>$a_{15}$</td></tr><tr><td>距离</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td><td>$a_{24}$</td><td>$a_{25}$</td></tr><tr><td>口味</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td><td>$a_{34}$</td><td>$a_{35}$</td></tr><tr><td>等待时间</td><td>$a_{41}$</td><td>$a_{42}$</td><td>$a_{43}$</td><td>$a_{44}$</td><td>$a_{45}$</td></tr><tr><td>餐厅装潢</td><td>$a_{51}$</td><td>$a_{52}$</td><td>$a_{53}$</td><td>$a_{54}$</td><td>$a_{55}$</td></tr></tbody></table></div><p>3） 两两进行互相比较分析（而不是把所有因素放在一起比较）</p><p>   一般而言，我们使用下面的标度方法：</p><div class="table-container"><table><thead><tr><th>$a_{ij}$ 值</th><th>含义</th></tr></thead><tbody><tr><td>$1$</td><td>因素 $i$ 和因素 $j$ 重要性相同</td></tr><tr><td>$3$</td><td>因素 $i$ 比因素 $j$ 稍微重要</td></tr><tr><td>$5$</td><td>因素 $i$ 比因素 $j$ 明显重要</td></tr><tr><td>$7$</td><td>因素 $i$ 比因素 $j$ 强烈重要</td></tr><tr><td>$9$</td><td>因素 $i$ 比因素 $j$ 极端重要</td></tr><tr><td>$2, 4, 6, 8$</td><td>中间值</td></tr><tr><td>上述值的倒数</td><td>$a_{ij} a_{ji} = 1$</td></tr></tbody></table></div><p>4） 比较过程中尽量考虑相对尺度，以提高准确度</p><ul><li>首先应该满足的是判断矩阵是一个正互矩阵：即满足 $a_{ij} {a_{ji}} = 1$</li><li>其次应该考虑作出的判断不应该明显有悖于已经作出的判断</li><li><p>判断矩阵的标度应该优先考虑题目中给出的信息和严谨的学术论文给出</p><p>严格遵循上面三个原则，我们给出判断矩阵各个方格中应该填的值</p><p>| 因素/因素 | 价格          | 距离          | 口味          | 等待时间 | 餐厅装潢 |<br>| ————- | ——————- | ——————- | ——————- | ———— | ———— |<br>| 价格      | $1$           | $1$           | $\frac{1}{3}$ | $2$      | $2$      |<br>| 距离      | $1$           | $1$           | $\frac{1}{3}$ | $2$      | $2$      |<br>| 口味      | $3$           | $3$           | $1$           | $6$      | $6$      |<br>| 等待时间  | $\frac{1}{2}$ | $\frac{1}{2}$ | $\frac{1}{6}$ | $1$      | $1$      |<br>| 餐厅装潢  | $\frac{1}{2}$ | $\frac{1}{2}$ | $\frac{1}{6}$ | $1$      | $1$      |</p><blockquote><p>由于我们遵循的判断标准非常严苛，我们发现上表有这样的特点：价格的标度是口味的标度 $\frac{1}{3}$ ，等待时间的标度是口味的 $\frac{1}{6}$ ，而价格的标度<strong>刚好</strong>是等待时间标度的 $2$ 倍，换句话说，即便在不同的因素之间，它们的重要程度也严格遵循相对尺度（$a_{ij}a_{jk} = a_{ik}$）</p><p>上面的说明也许使人困惑，但还可以这样理解：两两互相比较，这要求我们进行 $\frac{n(n-1)}{2}$ 次判断，但是由于严谨的标准，这 $\frac{n(n-1)}{2}$ 次判断的效果和只用同一个变量得到所有其它变量标度的效果一致</p><p>但是事实上我们给出的判断并不总是那么准确，有可能会出现变量不完全满足相对尺度的情形，这时我们需要通过对判断矩阵进行一致性检验来测算出现的误差是否在我们可以接受的范围内</p></blockquote></li></ul><h2 id="步骤三：对判断矩阵进行一致性检验"><a href="#步骤三：对判断矩阵进行一致性检验" class="headerlink" title="步骤三：对判断矩阵进行一致性检验"></a>步骤三：对判断矩阵进行一致性检验</h2><p>符号定义：</p><p>判断矩阵的最大特征根记为 $\lambda$ ，判断矩阵的规模（行数）记为 $n$ ，判断矩阵的一致性指标 $CI$ （衡量判断矩阵的一致性程度），随机一致性指标 $RI$ （一个通过查已知表得到的值），一致性比率 $CR$</p><p>1） 求出最大特征根 $\lambda$ </p><p>2） 求出矩阵的一致性指标 $CI$ </p><script type="math/tex; mode=display">CI = \frac{\lambda - n}{n-1}</script><p>3） 查表得到随机一致性指标 $RI$ </p><div class="table-container"><table><thead><tr><th>$n$</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>$RI$</td><td>0</td><td>0</td><td>0.58</td><td>0.90</td><td>1.12</td><td>1.24</td><td>1.32</td><td>1.41</td><td>1.45</td><td>1.49</td><td>1.51</td></tr></tbody></table></div><p>4） 求出一致性比率 $CR$ </p><script type="math/tex; mode=display">CR  = \frac{CI}{RI}</script><blockquote><p>一般情况下我们认为一致性比率 $CR &lt; 0.1$时，它的不一致程度在我们的允许范围内</p></blockquote><h2 id="步骤四：求解判断矩阵权重向量"><a href="#步骤四：求解判断矩阵权重向量" class="headerlink" title="步骤四：求解判断矩阵权重向量"></a>步骤四：求解判断矩阵权重向量</h2><p>求解权重向量一般有三种方法，可以全部使用，然后互相检验</p><p>前置知识：什么时向量归一化？</p><p>$(a_1,a_2,\dots,a_n)$ 归一化后为 $(\frac{a_1}{a_1+a_2+\dots+a_n},\frac{a_2}{a_1+a_2+\dots+a_n},\dots,\frac{a_1}{a_1+a_2+\dots+a_n})$</p><ul><li>算术平均法</li></ul><p>步骤：先将列向量全部归一化，再求解每一行的算术平均值，将这些算术平均值整合成一个列向量，再将这个列向量进行归一化，就能得到权重向量。</p><p>权重向量的第 $i$ 个分量为 $w_i$</p><script type="math/tex; mode=display">      w_i = \frac{1}{n}\sum_{j = 1}^{n}\frac{a_{ij}}{\sum_{k=1}^na_{kj}}</script><ul><li>几何平均法</li></ul><p>步骤：计算每一行的几何平均值（这个方法不需要先进行归一化），将这些几何平均值整合成一个列向量，再将这些向量进行归一化，就能得到权重向量。</p><p>权重向量的第 $i$ 个分量为 $w_i$</p><script type="math/tex; mode=display">      w_i = \frac{(\prod_{j=1}^na_{ij})^\frac{1}{n}}{\sum_{k=1}^{n}(\prod_{j=1}^na_{kj})^\frac{1}{n}}</script><ul><li>特征根法</li></ul><p>可以根据 2.5 的内容（一致矩阵的性质 3 ）得知：事实上一致的判断矩阵的最大特征值对应的特征向量可以直接视为第一列向量各分量的 k 倍（ k 是一个常数），将它归一化以后就是权重向量</p><p>这样，在一致性可以接受的情况下，我们只要求出最大特征值对应的特征向量，也能用来表示权重向量</p><p>步骤：求出判断矩阵的最大特征值对应的特征向量，将这个特征向量直接进行归一化得到权重向量</p><h2 id="求解各个方案在不同因素下的权重向量"><a href="#求解各个方案在不同因素下的权重向量" class="headerlink" title="求解各个方案在不同因素下的权重向量"></a>求解各个方案在不同因素下的权重向量</h2><p>使用如上描述的三种方法，同样可以列出各个方案在不同因素下的权重向量，如下我们依旧先给出方案层的判断矩阵</p><div class="table-container"><table><thead><tr><th>价格</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>距离</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>口味</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>等待时间</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>食堂装潢</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>东区二楼</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>西区一楼</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>中区二楼</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr></tbody></table></div><p>根据这五个表格，可以经过 2.4 列举的三种方法求解出五个一维权重向量，它们分别代表东区二楼、西区一楼和中区二楼在五个不同因素下的评分。</p><h2 id="将准则层和方案层的权重向量整合到一个表格中，进行最终评估"><a href="#将准则层和方案层的权重向量整合到一个表格中，进行最终评估" class="headerlink" title="将准则层和方案层的权重向量整合到一个表格中，进行最终评估"></a>将准则层和方案层的权重向量整合到一个表格中，进行最终评估</h2><p>现在，我们可以根据已经求得的所有数据列出下面的表格</p><div class="table-container"><table><thead><tr><th></th><th>因素权重</th><th>东区二楼</th><th>西区一楼</th><th>中区二楼</th></tr></thead><tbody><tr><td>价格</td><td>$w_1$</td><td>$a_{11}$</td><td>$a_{12}$</td><td>$a_{13}$</td></tr><tr><td>距离</td><td>$w_2$</td><td>$a_{21}$</td><td>$a_{22}$</td><td>$a_{23}$</td></tr><tr><td>口味</td><td>$w_3$</td><td>$a_{31}$</td><td>$a_{32}$</td><td>$a_{33}$</td></tr><tr><td>等待时间</td><td>$w_4$</td><td>$a_{41}$</td><td>$a_{42}$</td><td>$a_{43}$</td></tr><tr><td>食堂装潢</td><td>$w_5$</td><td>$a_{51}$</td><td>$a_{52}$</td><td>$a_{53}$</td></tr><tr><td>最终得分</td><td></td><td>$\sum_{i=1}^5 a_{i1}w_i$</td><td>$\sum_{i=1}^5 a_{i2}w_i$</td><td>$\sum_{i=1}^5 a_{i3}w_i$</td></tr></tbody></table></div><p>只需要比较 $\sum_{i=1}^5 a_{i1}w_i$ 、$\sum_{i=1}^5 a_{i2}w_i$ 和 $\sum_{i=1}^5 a_{i3}w_i$ 的大小就能作出评估</p><h2 id="一点补充（可以不看）：为什么我们这么在意最大特征值"><a href="#一点补充（可以不看）：为什么我们这么在意最大特征值" class="headerlink" title="一点补充（可以不看）：为什么我们这么在意最大特征值"></a>一点补充（可以不看）：为什么我们这么在意最大特征值</h2><p>我们对一致矩阵作出如下的定义：满足 $a_{ij}a_{jk} = a_{ik},1 \le i,j,k \le n$ 的矩阵被我们称为一致矩阵</p><blockquote><p>从这个定义中我们可以知道“一致”意味着什么：我们在作出两两比较判断的全过程严格遵照尺度（可以认为有一个严格遵循的标准）</p></blockquote><p> 一致矩阵的性质</p><p>  1）  一致矩阵的秩为 $1$ ，且一致矩阵任意两行之间成比例</p><p>  2）  一致矩阵的最大特征根为 $tr(判断矩阵) = n$ ，即判断矩阵的迹，其它特征根均为 0 </p><p>  3）  判断矩阵的最大特征值对应的特征向量为 $X = (\frac{k}{a_{11}},\frac{k}{a_{12}},\dots,\frac{k}{a_{1n}})^T$，其中 $k$ 为常数</p><p>我们来不严格地理解一下这些性质</p><ul><li>对于性质 1 </li></ul><p>由于一致矩阵有严格遵循的标准，换言之，我们知道 A 和 B 、C 、D之间的关系，自然也能够得到 B 和 C，B 和 D，C 和 D之间的关系，只需要第一行的信息就能够补充完整整个判断矩阵的内容。</p><p>整个判断矩阵中的有效信息只有第一行的信息，第一行以外的其它行的信息都能够被第一行的信息表示，因此一致矩阵的秩为 1</p><ul><li>对于性质 2 </li></ul><p>显然由于判断矩阵的对角线元素均为 $1$ ，故 $tr(判断矩阵) = n$</p><p>设判断矩阵为 $P$ ，满足 $PX = kX$，即 $(P-kI)X=O$</p><p>取 $k = 0$ 时，得到 $PX = O$，我们知道 $r(P) = 1$，那么显然 X 的基础解系的秩为 $n - 1$（自由未知量的个数） </p><p>那么 $k = 0$ 这一特征根的几何重数为 $n-1$，显然其代数重数大于等于 $n-1$ 且小于 $n$</p><blockquote><p>几何重数永远小于等于代数重数</p></blockquote><p>如果 $k = 0$ 这一特征根代数重数为 $n$ ，显然不能满足特征值的和为 $tr(P) = n$ ，因此它的代数重数为 $n-1$</p><p>剩下的一个特征根必然为 $tr(P) - 0 - 0 - \dots - 0 = tr(P) = n$</p><ul><li>对于性质 3</li></ul><p>$\dots$ $\dots$ 开摆</p><blockquote><p>综上，我们已经得到一个一致矩阵的最大特征值为 $n$ ，事实上，如果一个判断矩阵的最大特征值越接近 $n$ ，我们会认为它越接近一致的状态</p></blockquote><h2 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h2><ul><li>考虑的因素和对象不能过多：平均随机一致性指标 $RI$ 的 $n$ 最大是 15 ，并且 n 太大容易产生误差</li><li>已经有充分已知数据的情形下不适合再使用层次分析法，因为层次分析法的一个重要的过程是我们根据事实和资料来确定标度，在已有数据均已确定的情形下显然不再适合自行确定标度</li></ul><h2 id="步骤总结"><a href="#步骤总结" class="headerlink" title="步骤总结"></a>步骤总结</h2><ol><li><p>列出总目标层、准则层、方案层</p></li><li><p>查找资料，填充准则层的判断矩阵</p><ul><li>对准则层的判断矩阵进行一致性检验，如不能通过应该调整矩阵的值直至通过</li><li>利用三种方法求出准则层的权重向量 W</li></ul></li><li><p>查找资料，分别就各个准则层因素来填充方案层的判断矩阵</p><ul><li>对每个方案层的判断矩阵进行一致性检验，如不能通过应该调整矩阵的值直至通过</li><li>利用三种方法求出每个方案层的权重向量 V</li></ul></li><li><p>将准则层的权重向量 W 和每个方案层的权重向量 V 列在一张表格中，进行最终分数评估</p></li></ol><hr><h1 id="（三）代码构建思路"><a href="#（三）代码构建思路" class="headerlink" title="（三）代码构建思路"></a>（三）代码构建思路</h1><h2 id="文本文件格式设置如下："><a href="#文本文件格式设置如下：" class="headerlink" title="文本文件格式设置如下："></a>文本文件格式设置如下：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">请在下一行的开头分别输入准则层（先）和方案层（后）的规模（使用空格隔开）：</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入准则层矩阵</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入各个方案层的矩阵（注意顺序）</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure><p>只需要按照格式输入即可，比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">请在下一行的开头分别输入准则层（先）和方案层（后）的规模（使用空格隔开）：</span><br><span class="line">5 3</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入准则层矩阵</span><br><span class="line">1 0.5 4 3 3</span><br><span class="line">2 1 8 6 6</span><br><span class="line">0.25 0.125 1 0.875 0.875</span><br><span class="line">0.333 0.167 1.333 1 1</span><br><span class="line">0.333 0.167 1.333 1 1</span><br><span class="line">-----------------------------------------------------------------------</span><br><span class="line">请在下面输入各个方案层的矩阵（注意顺序）</span><br><span class="line">1 2 4</span><br><span class="line">0.5 1 2</span><br><span class="line">0.25 0.5 1</span><br><span class="line">1 0.333 0.125</span><br><span class="line">3 1 0.333</span><br><span class="line">8 3 1</span><br><span class="line">1 1 3</span><br><span class="line">1 1 3</span><br><span class="line">0.333 0.333 1</span><br><span class="line">1 3 4</span><br><span class="line">0.333 1 1</span><br><span class="line">0.25 1 1</span><br><span class="line">1 1 0.25</span><br><span class="line">1 1 0.25</span><br><span class="line">4 4 1</span><br><span class="line">-----------------------------------------------------------------------</span><br></pre></td></tr></table></figure></p><h2 id="代码文件已经附上详细注释"><a href="#代码文件已经附上详细注释" class="headerlink" title="代码文件已经附上详细注释"></a>代码文件已经附上详细注释</h2><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">clc, clear  <span class="comment">% 清空当前的命令行窗口</span></span><br><span class="line">inFile <span class="built_in">=</span> fopen(<span class="string">&#x27;ahpInput.txt&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>); <span class="comment">% 以只读方式打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> (inFile <span class="built_in">=</span><span class="built_in">=</span> -<span class="number">1</span>) <span class="comment">% 如果文件无法打开则输出报错信息</span></span><br><span class="line">    disp(<span class="string">&quot;无法打开文件！&quot;</span>);</span><br><span class="line"><span class="built_in">else</span></span><br><span class="line">    disp(<span class="string">&#x27;成功打开文件！&#x27;</span>);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">rowCnt <span class="built_in">=</span> fscanf(inFile,<span class="string">&#x27;%d %d\n&#x27;</span>,[<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取分割行</span></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">factor <span class="built_in">=</span> rand(rowCnt(<span class="number">1</span>,<span class="number">1</span>),rowCnt(<span class="number">1</span>,<span class="number">1</span>));  <span class="comment">% 定义准则层</span></span><br><span class="line"></span><br><span class="line">for i <span class="built_in">=</span> <span class="number">1</span>:rowCnt(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    for j <span class="built_in">=</span> <span class="number">1</span>:rowCnt(<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        factor(i,j) <span class="built_in">=</span> fscanf(inFile ,<span class="string">&#x27;%f&#x27;</span>, [<span class="number">1</span>,<span class="number">1</span>]); <span class="comment">% 读取准则层矩阵</span></span><br><span class="line">        <span class="built_in">if</span> (j <span class="built_in">=</span><span class="built_in">=</span> rowCnt(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">            fscanf(inFile,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取分割行</span></span><br><span class="line">fgetl(inFile); <span class="comment">% 读取文字行</span></span><br><span class="line"></span><br><span class="line">RI <span class="built_in">=</span> [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.58</span>,<span class="number">0.9</span>,<span class="number">1.12</span>,<span class="number">1.24</span>,<span class="number">1.32</span>,<span class="number">1.41</span>,<span class="number">1.45</span>,<span class="number">1.49</span>,<span class="number">1.52</span>,<span class="number">1.54</span>,<span class="number">1.56</span>,<span class="number">1.58</span>,<span class="number">1.59</span>]; <span class="comment">% 定义随机平均一致性指标</span></span><br><span class="line"></span><br><span class="line">[eigenvectors , eigenvalues] <span class="built_in">=</span> eig(factor);  <span class="comment">% 求出判断矩阵的所有特征值构成对角阵eigenvalues，以及所有特征向量构成矩阵eigenvectors</span></span><br><span class="line">max_eigenvalue <span class="built_in">=</span> max(diag(eigenvalues)); <span class="comment">% 求出最大的特征向量</span></span><br><span class="line">whichColumn <span class="built_in">=</span> find(diag(eigenvalues) <span class="built_in">=</span><span class="built_in">=</span> max_eigenvalue); <span class="comment">% 找出最大的特征值对应的特征向量在哪一列</span></span><br><span class="line">weightVector <span class="built_in">=</span> eigenvectors(:,whichColumn)/sum(eigenvectors(:,whichColumn)); <span class="comment">% 将找到的特征向量进行归一化处理</span></span><br><span class="line">disp(<span class="string">&quot;准则矩阵的权重向量是&quot;</span>);</span><br><span class="line">disp(weightVector<span class="string">&#x27;);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CR0 = (max_eigenvalue - rowCnt(1,1))/(rowCnt(1,1) - 1)/RI(rowCnt(1,1));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if CR0 &lt; 0.1</span></span><br><span class="line"><span class="string">    disp([&#x27;</span>准则层判断矩阵的 CR 值为<span class="string">&#x27;, CR0, &#x27;</span>,一致性达到标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    disp([&#x27;</span>准则层判断矩阵的 CR 值为<span class="string">&#x27;, CR0, &#x27;</span>,一致性未达标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">weightVector_plan = zeros(rowCnt(1,2),rowCnt(1,1));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i = 1:rowCnt(1,1)</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    plan = zeros(rowCnt(1,2),rowCnt(1,2));    % 定义方案层矩阵</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    for j = 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">        for k = 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">            plan(j,k) = fscanf(inFile ,&#x27;</span><span class="comment">%f&#x27;,[1,1]);  % 逐行输入得到各各要素下的方案层矩阵</span></span><br><span class="line">            <span class="built_in">if</span> (k <span class="built_in">=</span><span class="built_in">=</span> rowCnt(<span class="number">1</span>,<span class="number">1</span>))</span><br><span class="line">                fscanf(inFile,<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            end</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    [eigenvectors_plan , eigenvalues_plan] <span class="built_in">=</span> eig(plan);  <span class="comment">% 求出判断矩阵的所有特征值构成对角阵eigenvalues，以及所有特征向量构成矩阵eigenvectors</span></span><br><span class="line">    max_eigenvalue_plan <span class="built_in">=</span> max(diag(eigenvalues_plan)); <span class="comment">% 求出最大的特征向量</span></span><br><span class="line">    whichColumn2 <span class="built_in">=</span> find(diag(eigenvalues_plan) <span class="built_in">=</span><span class="built_in">=</span> max_eigenvalue_plan); <span class="comment">% 找出最大的特征值对应的特征向量在哪一列</span></span><br><span class="line">    weightVector_plan(:,i) <span class="built_in">=</span> eigenvectors_plan(:,whichColumn2)/sum(eigenvectors_plan(:,whichColumn2)); <span class="comment">% 将找到的特征向量进行归一化处理</span></span><br><span class="line">    disp([<span class="string">&#x27;因素&#x27;</span>, num2str(i) ,<span class="string">&#x27;对应的各方案判断矩阵的权重向量是&#x27;</span>]);</span><br><span class="line">    disp(weightVector_plan(:,i)<span class="string">&#x27;);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    CR1 = (max_eigenvalue_plan - rowCnt(1,2))/(rowCnt(1,2) - 1)/RI(rowCnt(1,2));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    if CR1 &lt; 0.1</span></span><br><span class="line"><span class="string">        disp([&#x27;</span>因素<span class="string">&#x27;, num2str(i), &#x27;</span>各方案判断矩阵的 CR 值为<span class="string">&#x27;, num2str(CR1), &#x27;</span>,一致性达到标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">    else</span></span><br><span class="line"><span class="string">        disp([&#x27;</span>因素<span class="string">&#x27;, num2str(i), &#x27;</span>各方案判断矩阵的 CR 值为<span class="string">&#x27;, num2str(CR1), &#x27;</span>,一致性未达标准<span class="string">&#x27; newline]);</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scores = zeros(rowCnt(1,2));</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i= 1:rowCnt(1,2)</span></span><br><span class="line"><span class="string">    scores(i) = sum(weightVector_plan(i,:)&#x27;</span>.*weightVector);</span><br><span class="line">    disp([<span class="string">&#x27;方案&#x27;</span>, num2str(i) ,<span class="string">&#x27;的得分为&#x27;</span> , num2str(scores(i))]);</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">fclose(inFile);</span><br></pre></td></tr></table></figure><blockquote><p>提示：输入示例和算法代码可以参见我的 <a href="https://github.com/CentrifugalAI/MCM/tree/main/coding/moding_algorithm/AHP%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95">GitHub 仓库</a>（点击访问）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 竞赛笔记 </category>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
